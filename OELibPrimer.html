<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="StarOffice/5.1 (Linux)">
	<META NAME="AUTHOR" CONTENT="Matthew Stahl">
	<META NAME="CREATED" CONTENT="19991224;13140000">
	<META NAME="CHANGEDBY" CONTENT=" ">
	<META NAME="CHANGED" CONTENT="20000427;11310700">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
	<STYLE>
	<!--
		@page { size: 8.5in 11in; margin: 1in }
		TD P { color: #000000 }
		ADDRESS { color: #000000 }
		P { color: #000000 }
		DD { color: #000000 }
		A:link { color: #0000ee }
		A:visited { color: #551a8b }
	-->
	</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ee" VLINK="#551a8b" BGCOLOR="#ffffff">
<P ALIGN=CENTER><B><FONT SIZE=6>OELib Primer</FONT></B> 
</P>
<P ALIGN=CENTER><B><FONT SIZE=4>An Introduction to Programming with
the OpenEye Library</FONT></B> 
</P>
<P ALIGN=CENTER><B><FONT SIZE=4>by Matthew T. Stahl</FONT></B> 
</P>
<HR>
<P ALIGN=CENTER><FONT SIZE=5><B>Table of Contents</B></FONT></P>
<P><BR><BR>
</P>
<P STYLE="margin-bottom: 0in"><A HREF="#introduction" NAME="TOCintroduction"><B><FONT SIZE=3>Introduction</FONT></B></A>
</P>
<P STYLE="margin-bottom: 0in"><A HREF="#Molecule and Related Classes"><B><FONT SIZE=3>Molecule
and Related Classes</FONT></B></A> 
</P>
<DL>
	<DD><A HREF="#OEMol"><FONT SIZE=3>OEMol</FONT></A></DD><DD>
	<A HREF="#OEAtom"><FONT SIZE=3>OEAtom</FONT></A></DD><DD>
	<A HREF="#OEBond"><FONT SIZE=3>OEBond</FONT></A></DD><DD>
	<A HREF="#OEResidue"><FONT SIZE=3>OEResidue</FONT></A></DD><DD>
	<A HREF="#OERing"><FONT SIZE=3>OERing</FONT></A></DD></DL>
<P>
<A HREF="#Molecule Operator Classes"><B><FONT SIZE=3>Molecule
Operator Classes</FONT></B></A></P>
<DL>
	<DD><A HREF="#OESmartsPattern"><FONT SIZE=3>OESmartsPattern</FONT></A></DD><DD>
	<A HREF="#OEAtomTyper"><FONT SIZE=3>OEAtomTyper</FONT></A></DD><DD>
	<A HREF="#patty"><FONT SIZE=3>patty</FONT></A></DD><DD>
	<A HREF="#OEGastChrg"><FONT SIZE=3>OEGastChrg</FONT></A></DD></DL>
<P>
<A HREF="#Utility Classes"><B><FONT SIZE=3>Utility Classes</FONT></B></A></P>
<DL>
	<DD><A HREF="#OEBitVec"><FONT SIZE=3>OEBitVec</FONT></A></DD><DD>
	<A HREF="#OEStopwatch"><FONT SIZE=3>OEStopwatch</FONT></A></DD><DD>
	<A HREF="#OEExtensionTable"><FONT SIZE=3>OEExtensionTable</FONT></A></DD><DD>
	<A HREF="#CommandLine"><FONT SIZE=3>CommandLine</FONT></A></DD></DL>
<P>
<A HREF="#Atom Data Translation Classes"><B><FONT SIZE=3>Atom Data
Translation Classes</FONT></B></A></P>
<DL>
	<DD><A HREF="#OEElementTable"><FONT SIZE=3>OEElementTable</FONT></A></DD><DD>
	<A HREF="#OETypeTable"><FONT SIZE=3>OETypeTable</FONT></A></DD></DL>
<P>
<A HREF="#Math Classes"><B><FONT SIZE=3>Math Classes</FONT></B></A></P>
<DL>
	<DD><A HREF="#Vector"><FONT SIZE=3>Vector</FONT></A></DD><DD>
	<A HREF="#Matrix3x3"><FONT SIZE=3>Matrix3x3</FONT></A></DD></DL>
<P>
<A HREF="#Examples"><B><FONT SIZE=3>Examples</FONT></B></A></P>
<DL>
	<DD><A HREF="#Largest Ring Extraction"><FONT SIZE=3>Largest Ring
	Extraction</FONT></A></DD><DD>
	<A HREF="#SMARTS Grep"><FONT SIZE=3>SMARTS Grep</FONT></A></DD></DL>
<P>
<A HREF="#Acknowledgments"><B><FONT SIZE=3>Acknowledgments</FONT></B></A></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<HR>
<P STYLE="margin-bottom: 0in; page-break-before: always"><A NAME="Introduction"></A>
<B><FONT SIZE=3>Introduction</FONT></B> 
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>It is fair to say that
OELib is a direct result of Babel. Programmers have long known that
application development is facilitated by building software on top of
libraries rich in functionality. Babel was the first experience I had
in working with a molecule library. In addition to developing Babel,
Pat Walters and I developed `OBabel' at Vertex Pharmaceuticals.
OBabel was the first attempt at developing an object oriented
molecule library. Although OBabel was a successful project, my
departure from Vertex Pharmaceuticals provided a great opportunity to
include much of what I had learned in previous projects into a new
molecule class library. OELib was designed to be flexible,
extensible, portable, and efficient class library for processing
small molecules. I hope that others find it as useful as I have.</FONT>
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>I admire open-source
projects. Linux and the Free Software Foundation are both great
examples of how summing the spare time of Geeks and Hackers can
result in useful projects. Although the potential audience is small,
I hope to take advantage many of the great minds writing chemical
software by making OELib available to others. Two things can be
accomplished by releasing source code to OELib. First, development
time can be shortened by basing projects on OELib. The less people
have to reinvent the wheel (or the function) the better. Second, by
releasing the source code hopefully other programmers can contribute
to the project. Joe Corkery, Brian Goldman, Anthony Nicholls, Roger
Sayle, and Pat Walters have already made significant contributions to
OELib. As the list of contributors grows all the users of OELib
benefit.</FONT> 
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>This primer is not
intended to be an exhaustive manual. OELib is still too young and
changing too rapidly to write a manual that will not be sorely
lacking soon after the first draft. The primer will hopefully be
sufficient to get developers started with the basic functionality of
OELib. Writing a program to perform simple manipulations of molecules
should possible after reading and understanding the material in the
primer. More complex software based on OELib will require the
developer to dig into the headers and source code to understand all
of the classes and member functions.</FONT> 
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<HR>
<P STYLE="margin-bottom: 0in"><A NAME="Molecule and Related Classes"></A>
<B><FONT SIZE=3>Molecule and Related Classes</FONT></B> 
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><A NAME="OEMol"></A><FONT SIZE=3><U>OEMo</U>l</FONT>
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The most important class
in OELib is OEMol, or the molecule class. The OEMol class is designed
to store all the basic information associated with a molecule, to
make manipulations on the connection table of a molecule facile, and
to provide member functions which automatically perceive information
about a molecule. A guided tour of the OEMol class is a good place to
start.</FONT> 
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>An OEMol class can be
declared in either of the following ways</FONT> 
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<ADDRESS STYLE="font-style: normal"><FONT COLOR="#000080">OEMol mol; </FONT>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">//or</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">OEMol
mol(SDF,MOL2); </FONT>
</ADDRESS>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The second declaration
type sets the input and output formats for a molecule. For example</FONT></P>
<ADDRESS><BR><SPAN STYLE="font-style: normal"><FONT SIZE=3><FONT COLOR="#000080">#include
&lt;iostream.h&gt;</FONT></FONT></SPAN></ADDRESS>
<ADDRESS><FONT COLOR="#000080">#include &quot;mol.h&quot;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int main(int argc,char **argv)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEMol mol(SDF,MOL2);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cin &gt;&gt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cout &lt;&lt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">return(1);</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">}</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><BR><FONT SIZE=3>will read in a
molecule in SD file format from stdin (or the C++ equivalent cin) and
write a MOL2 format file out to standard out. Additionally, The input
and output formats can be altered after declaring an OEMol by the
member functions</FONT></P>
<ADDRESS><BR><SPAN STYLE="font-style: normal"><FONT SIZE=3><FONT COLOR="#000099">void
SetInputType(enum io_type type);</FONT></FONT></SPAN></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">void
SetOutputType(enum io_type type);</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><BR><FONT SIZE=3>where the current
values of enum io_type are</FONT> <BR>&nbsp;</P>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">enum
io_type {UNDEFINED,SDF,MOL2,PDB,DELPDB,SMI,BOX,FIX,OEBINARY}</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>The following
lines of code show how to set the input and output types of an OEMol
through the member functions</FONT></P>
<ADDRESS>&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">OEMol mol;</FONT></FONT></I></ADDRESS>
<ADDRESS><FONT COLOR="#000080">mol.SetInputType(SDF);</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080"><I><FONT SIZE=3>mol.SetOutputType(MOL2);</FONT></I>
</FONT>
</ADDRESS>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Once a molecule has been
read into an OEMol the atoms and bonds can be accessed by the
following methods</FONT></P>
<ADDRESS>&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">OEAtom
*atom;</FONT></FONT></I></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080"><I>atom =
mol.GetAtom(5);</I> //random access of an atom</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <FONT SIZE=3>or</FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<ADDRESS>&nbsp; <I><FONT SIZE=3><FONT COLOR="#000080">OEBond *bond;</FONT></FONT></I></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080"><I>bond =
mol.GetBond(14);</I> //random access of a bond</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <FONT SIZE=3>or</FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<ADDRESS>&nbsp; <I><FONT SIZE=3><FONT COLOR="#000080">OEAtom *atom;</FONT></FONT></I></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OEAtom*&gt;::iterator i;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080"><I>for
(atom = mol.BeginAtom(i);atom;atom = mol.NextAtom(i))</I> //iterator
access</FONT></ADDRESS>
<P>or</P>
<ADDRESS><FONT COLOR="#000080"><FONT SIZE=3><I>OEBond *bond;</I></FONT></FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OEBond*&gt;::iterator i;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080"><I>for
(bond = mol.BeginBond(i);bond;bond = mol.NextBond(i))</I> //iterator
access</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>It is important
to note that atom arrays begin at one and bond arrays begin at zero.
Requesting atom zero</FONT></P>
<ADDRESS STYLE="margin-bottom: 0.2in">&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">OEAtom
*atom = mol.GetAtom(0);</FONT></FONT></I></ADDRESS>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>will result in an error,
but</FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">OEBond
*bond = mol.GetBond(0);</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>is perfectly valid.</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The ambiguity of numbering
issues and off-by-one errors led to the use of iterators in OELib. An
iterator is essentially just a pointer, but when used in conjunction
with Standard Template Library (STL) vectors it provides an
unambiguous way to loop over arrays. OEMols store their atom and bond
information in STL vectors. Since vectors are template based, a
vector of any user defined type can be declared. OEMols declare
vector&lt;OEAtom*&gt; and vector&lt;OEBond*&gt; to store atom and
bond information. Iterators are then a natural way to loop over the
vectors of atoms and bonds.</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Before going on to the
OEAtom and OEBond classes in more detail it is important to point out
several things about the OEMol class. Much of the information
contained in a molecule can be accessed or modified by Get or Set
methods. For instance, the <I>GetAtom()</I> method has already been
discussed. The following member functions are examples of Get and Set
methods in OEMol</FONT> <BR>&nbsp;</P>
<ADDRESS><FONT COLOR="#000080">//***data retrieval methods***</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void *GetData(string &amp;);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void *GetData(const char *);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool HasFlag(int flag);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">const char *GetTitle();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">enum io_type GetInputType();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">enum io_type GetOutputType();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEAtom *GetAtom(int);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEBond *GetBond(int);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEBond *GetBond(int, int);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">float GetEnergy();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp; </FONT>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">//***data modification methods***</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp; </FONT>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetTitle(char *title)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetTitle(string &amp;title)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetEnergy(float energy)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetInputType(enum io_type type)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetOutputType(enum io_type type)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool SetCoordsFromArray(float *);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetData(string &amp;,void *);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetData(const char *,void *);</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">void
SetFlag(int flag);</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>Of the
preceding member functions <I>GetData</I> and <I>SetData</I> deserve
special attention. The data structure of OEMol can be include all
types of data through the GetData() and SetData() routines.
Attribute/Value data can be added to an OEMol in the following manner</FONT></P>
<ADDRESS>&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">int *foo =
new int [100];</FONT></FONT></I></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">mol.SetData(&quot;IntegerArray&quot;,(void*)foo);</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>and retrieved
from the molecule by</FONT></P>
<ADDRESS>&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">int *foo;</FONT></FONT></I></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">foo =
(int*)mol.GetData(&quot;IntegerArray&quot;);</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>The onus of
freeing the memory stored with GetData is on the user as the pointer
to the data inside OEMol is released when the <I>Clear()</I> member
function is called.</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The following OEMol member
functions are useful manipulation routines</FONT></P>
<ADDRESS>&nbsp; <BR><FONT SIZE=3><FONT COLOR="#000080">//***<I>molecule
modification methods***</I></FONT></FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool Clear(); //clears all data out of
an OEMol for re-use</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void ToInertialFrame();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void RenumberAtoms(vector&lt;int&gt;&amp;);
//re-order atoms to those specified in the vector</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool Kekulize(); //convert an aromatic
to a kekule structure</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool DeleteHydrogens();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool DeleteNonPolarHydrogens();
//delete hydrogens attached to carbon</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool AddHydrogens();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool AddPolarHydrogens(); //add
hydrogens to hetero-atoms</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool StripSalts(); //delete all but
the largest contiguous structure</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">Vector Center();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">Vector Center(vector&lt;int&gt; &amp;);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">Vector Center(int);</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">void
Translate(const Vector &amp;v);</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The following are useful
perception member functions for OEMol.</FONT></P>
<ADDRESS>&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">//***molecule
utilities and perception methods***</FONT></FONT></I></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void FindSSSR(); //smallest set of
smallest rings</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void FindRingAtomsAndBonds();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void FindChildren(vector&lt;int&gt;
&amp;,int,int); //find all atoms connected to one end of a bond</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void ContigFragList(vector&lt;vector&lt;int&gt;
&gt;&amp;); //get a list of contiguous units in a molecule</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void FindLargestFragment(OEBitVec &amp;);
//find the largest contiguous unit of a molecule</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">//align a molecule by rotating such
that the two atoms lie on top of the two points</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void
Align(OEAtom*,OEAtom*,Vector&amp;,Vector&amp;);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool RemoveData(const char*); //Remove
Data previously stored with SetData()</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">bool
HasNonZeroCoords();</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>The basics of
the OEMol class have now been covered. For more details and the inner
workings of OEMol please look at mol.h and mol.cpp in the OELib
distribution. To understand more about what can be done with the
OEMol class it is necessary to look at the associated data classes.</FONT></P>
<P STYLE="margin-bottom: 0in"><A NAME="OEAtom"></A>&nbsp; <BR><U><FONT SIZE=3>OEAtom</FONT></U></P>
<P STYLE="text-indent: 0.5in; margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>To
understand the OEAtom class it is important to state a key decision
on which the design was based. In OBabel the atom class existed, but
it was only a data container. All data access and modification of
atoms was done through the molecule. The result was a molecule class
that was very large an unwieldy. I decided to make the OEAtom class
smarter, and separate out many of the atom specific routines into the
OEAtom thereby decentralizing and shrinking the OEMol class. As a
result the OEAtom class not only holds data, but facilitates
extraction of data perceived from both the atom and the molecule.</FONT></P>
<P STYLE="text-indent: 0.5in; margin-bottom: 0in"><BR>
</P>
<P>A number of data extraction methods perform what is called `Lazy
Evaluation', which is essentially on the fly evaluation. For example,
when an atom is queried as to whether it is cyclic or what it's
hybridization state is the information is perceived automatically.
The perception of a particular trait is actually performed on the
entire molecule the first time it is requested of an atom or bond,
and stored for subsequent requests for the same trait of additional
atoms or bonds.The OEAtom class is similar to OEMol and the whole of
OELib in that data access and modification is done through Get and
Set methods. The following are Get and Set methods in OEAtom</P>
<ADDRESS><FONT COLOR="#000080">//***methods to set atomic
information***</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetIdx(int idx);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetHyb(int hyb);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetAtomicNum(int atomicnum);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetFormalCharge(int fcharge);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetType(char *type);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetType(string &amp;type);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetPartialCharge(float pcharge);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetVector(Vector v);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetVector(float x,float y, float
z);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetFlag(int flag);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetParent(OEMol *ptr);</FONT></ADDRESS>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">//***methods to retrieve atomic
information***</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp; <BR><I><FONT SIZE=3>int
GetFlag();</FONT></I></FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetHyb();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetAtomicNum();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetStereo();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetFormalCharge();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetValence();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetHvyValence(); //number of
connected non-hydrogen atoms</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">char *GetType();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">float GetX(); //return the X
coordinate</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">float GetY();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">float GetZ();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">float GetPartialCharge();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">Vector &amp;GetVector(); //return the
coordinates</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEResidue *GetResidue();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEMol *GetParent();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool GetNewBondVector(Vector&amp;,float);</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">OEBond
*GetBond(OEAtom *);</FONT></ADDRESS>
<P>&nbsp; <BR><FONT SIZE=3>The following code demonstrates how to
print out the atom numbers, element numbers, and coordinates of a
molecule.</FONT></P>
<ADDRESS><FONT COLOR="#000080">&nbsp; <BR><I><FONT SIZE=3>OEMol
mol(SDF,SDF);</FONT></I></FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cin &gt;&gt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEAtom *atom;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OEAtom*&gt;::iterator i;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (atom = mol.BeginAtom(i);atom;atom
= mol.NextAtom(i))</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cout &lt;&lt;
atom-&gt;GetIdx() &lt;&lt; ` `;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cout &lt;&lt;
atom-&gt;GetAtomicNum() &lt;&lt; ` `;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cout &lt;&lt;
atom-&gt;GetVector() &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">}</FONT></ADDRESS>
<P>&nbsp; <BR><FONT SIZE=3>The OEAtom class also has a number of
convenience methods for extracting property information from an atom.</FONT></P>
<ADDRESS><FONT COLOR="#000080">//***requests for atomic property
information***</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int CountFreeOxygens();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int ImplicitHydrogenCount();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int ExplicitHydrogenCount();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int MemberOfRingCount();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int BOSum(); //sum of the bond orders
of the bonds to the atom</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool HasFlag(int flag);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool HasResidue();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsHydrogen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsCarbon();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsNitrogen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsOxygen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsSulfur();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsPhosphorus();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsConnected(OEAtom*);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsOneThree(OEAtom*);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsOneFour(OEAtom*);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsCarboxylOxygen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsPhosphateOxygen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsSulfateOxygen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsNitroOxygen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsAmideNitrogen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsPolarHydrogen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsNonPolarHydrogen();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsAromaticAtom();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsInRing();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsInRingSize(int);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool HasAlphaBetaUnsat(bool
includePandS=true);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool HasBondOfOrder(int);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool HasSingleBond();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool HasDoubleBond();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool HasAromaticBond();</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><BR><BR>
</ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>A number of the property
member functions indicate that atoms have some knowlege of their
covalently attached neighbor atoms. Bonding information is partly
redundant within a molecule in that an OEMol has a complete list of
bonds in a molecule, and an OEAtom has a list bonds of which it is a
member. The following code demonstrates how an OEAtom uses its bond
information to loop over atoms attached to itself.</FONT></P>
<ADDRESS>&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">OEMol
mol(SDF,SDF);</FONT></FONT></I></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cin &gt;&gt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEAtom *atom,*nbr;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OEBond*&gt;::iterator i;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">atom = mol.GetAtom(1);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (nbr =
atom-&gt;BeginNbrAtom(i);nbr;nbr = atom-&gt;NextNbrAtom(i))</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cout &lt;&lt; &quot;atom #&quot; &lt;&lt;
atom-&gt;GetIdx() &lt;&lt; &quot; is attached to atom #&quot; &lt;&lt;
nbr-&gt;GetIdx() &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">}</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>should produce an output
like</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>atom #1 is attached to
atom #2</FONT></P>
<P STYLE="margin-bottom: 0in"><A NAME="OEBond"></A>&nbsp; <BR><U><FONT SIZE=3>OEBond</FONT></U></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The OEBond class is
straightforward in its data access and modification methods. OEBonds
store pointers to the atoms on each end of the bond. In storing
pointers to atoms instead of integer indices, the necessity of having
to reorder bonds when atoms are shuffled, added, or delete is
obviated.</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>&nbsp; </FONT>
</P>
<ADDRESS>/<FONT COLOR="#000080">/***bond modification methods***</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetIdx(int idx);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetBO(int order);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetBegin(OEAtom *begin);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetEnd(OEAtom *end);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetFlag(int flag);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetLength(OEAtom*,float);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void Set(int,OEAtom*,OEAtom*,int,int);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp; </FONT>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">//***bond data request methods***</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp; </FONT>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetBO();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetBondOrder();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetFlag();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetBeginAtomIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetEndAtomIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEAtom *GetBeginAtom();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEAtom *GetEndAtom();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEAtom *GetNbrAtom(OEAtom *ptr);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">float GetEquibLength();</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">int
GetNbrAtomIdx(OEAtom *ptr);</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Several convenience
property methods are provided</FONT></P>
<ADDRESS><BR><I><FONT SIZE=3><FONT COLOR="#000099">/</FONT><FONT COLOR="#000080">/***property
request methods***</FONT></FONT></I></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsRotor();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsAmide();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsEster();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool IsCarbonyl();</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">bool
IsInRing();</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3><U>OEResidue</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Residue information drawn
from PDB or MOL2 files are stored in the OEResidue class. OEResidues
are stored inside the OEAtom class. The residue information for an
atom can be requested in the following way</FONT></P>
<ADDRESS>&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">OEAtom
*atom;</FONT></FONT></I></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEResidue *r;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">atom = mol.GetAtom(1);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">r = atom-&gt;GetResidue();</FONT></ADDRESS>
<ADDRESS>&nbsp; <BR><FONT SIZE=3>The following are OEResidue member
functions.</FONT></ADDRESS>
<ADDRESS>&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">void
SetSerialNum(int sernum);</FONT></FONT></I></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetChainNum(int chainnum);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetNum(int resnum);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetName(string &amp;resname);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetAtomID(string &amp;atomid);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">void SetHetAtom(bool val);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetSerialNum();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetChainNum();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int GetNum();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">string &amp;GetName();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">string &amp;GetAtomID();</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">bool
IsHetAtom();</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><A NAME="OERing"></A><FONT SIZE=3><U>OERing</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Ring information beyond
atom and bond membership is usually not necessary, but more
information can be had about the rings in a molecule. The OERing
class is used to store the information from a Smallest Set of
Smallest Rings (SSSR) perception of a molecule. The OEMol member
function GetSSSR() stores the information it perceives in a
vector&lt;OERing*&gt; inside the molecule. Perception is only done
once for a molecule unless the connection table is modified. The
following code demonstrates how to extract the SSSR information.</FONT></P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEMol mol(SDF,SDF);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cin &gt;&gt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OERing*&gt; vr;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">vr =
mol.GetSSSR();</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>OERings store the atom
numbers of the atoms in each of the smallest set of smallest rings in
both a vector&lt;int&gt; and an OEBitVec (described later in this
document). An example of how to print out the atom numbers present in
all SSSR rings is show below.</FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<ADDRESS><FONT COLOR="#000080"><FONT SIZE=3><I>vector&lt;OERing*&gt;::iterator
i;</I></FONT></FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;int&gt;::iterator j;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OERing*&gt; *rlist =
(vector&lt;OERing*&gt;*)mol.GetData(&quot;RingList&quot;);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (i = rlist-&gt;begin();i !=
rlist-&gt;end();i++)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; for(j =
(*i)-&gt;_path.begin();j != (*i)-&gt;_path.end();j++)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; *j &lt;&lt; ` `;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">}</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>will produce
something like the following output for benzene</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>1 2 3 4 5 6</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Ring information is
automatically deleted from an OEMol when it goes out of scope or the
Clear() member function is called.</FONT></P>
<HR>
<P STYLE="margin-bottom: 0in"><A NAME="Molecule Operator Classes"></A>
<FONT SIZE=3><B>Molecule Operator Classes</B></FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Molecule operator classes
add information to or discover information about molecule. Although
some operator classes could have been made member functions, they are
necessary in all applications using the OEMol class and therefore
were broken out into operator classes to avoid excessive code bloat
and complexity of the OEMol class.</FONT></P>
<P STYLE="margin-bottom: 0in"><A NAME="OESmartsPattern"></A><FONT SIZE=3><U>OESmartsPattern</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Substructure search is an
incredibly useful tool in the context of a small molecule programming
library. Having an efficient substructure search engine reduces the
amount of hard code needed for molecule perception, as well as
increases the flexibility of certain operations. For instance, atom
typing can be easily performed based on hard coded rules of element
type and bond orders (or hybridization). Alternatively, atom typing
can also be done by matching a set of substructure rules read at run
time. In the latter case customization based on application (such as
changing the pH) becomes a facile operation. Fortunately for OELib
and it's users, Roger Sayle donated a SMARTS parser which became the
basis for SMARTS matching in OELib.</FONT></P>
<P><FONT SIZE=3>The SMARTS matcher, or OESmartsPattern, is a separate
object which can match patterns in the OEMol class. The following
code demonstrates how to use the OESmartsPattern class.</FONT></P>
<ADDRESS><FONT COLOR="#000080"><I><FONT SIZE=3>OEMol mol(SDF,SDF);</FONT></I>
</FONT>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">cin &gt;&gt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OESmartsPattern sp;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">sp.Init(&quot;CC&quot;);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">sp.Match(mol);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;vector&lt;int&gt; &gt;
maplist;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">maplist = sp.GetMapList();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">//or maplist = sp.GetUMapList();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">//print out the results</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;vector&lt;int&gt;
&gt;::iterator i;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;int&gt;::iterator j;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (i = maplist.begin();i !=
maplist.end();i++)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; for (j =
i-&gt;begin();j != i-&gt;end();j++)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout &lt;&lt; j &lt;&lt; ' `;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">}</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><BR><BR>
</ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The preceding code reads
in a molecule, initializes a smarts pattern of two single-bonded
carbons, and locates all instances of the pattern in the molecule.
Note that calling the Match(OEMol&amp;) function does not return the
results of the substructure match. The results from a match are
stored in the OESmartsPattern, and a call to <I>GetMapList()</I> or
<I>GetUMapList()</I> must be made to extract the results. The
function <I>GetMapList()</I> returns all matches of a particular
pattern while <I>GetUMapList()</I> returns only the unique matches.
For instance, the pattern [OD1]~C~[OD1] describes a carboxylate
group. This pattern will match both atom number permutations of the
carboxylate, and if <I>GetMapList()</I> is called, both matches will
be returned. If <I>GetUMapList()</I> is called only unique matches of
the pattern will be returned. A unique match is defined as one which
does not cover the identical atoms that a previous match has covered.</FONT></P>
<P STYLE="margin-bottom: 0in"><A NAME="OEAtomTyper"></A><FONT SIZE=3><U>OEAtomTyper</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The OEAtomTyper class is
designed to read in a list of atom typing rules and apply them to
molecules. The code that performs atom typing is not usually used
directly as atom typing, hybridization assignment, implicit valence
assignment and charge are all done automatically when their
corresponding values are requested of atoms.</FONT></P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">atom-&gt;GetType();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">atom-&gt;GetFormalCharge();</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">atom-&gt;GetHyb();</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Atom types are defined in
the file atomtyp.txt which is composed of two sections. The list of
atom is at the head of the file and appears as</FONT></P>
<DL>
	<DD>***ATOM_TYPES*** 
	</DD><DD>
	1 N3 3 0 3 
	</DD><DD>
	2 N3+ 3 1 4</DD><DD>
	3 N2 2 0 3 
	</DD><DD>
	4 N1 1 0 2 
	</DD><DD STYLE="margin-bottom: 0.2in">
	5 Npl 2 0 3 
	</DD></DL>
<P STYLE="margin-bottom: 0in">
<FONT SIZE=3>Each atom type line contains a reference number, the
internal atom type, hybri</FONT>dization, formal charge, and implicit
valence. The reference numbers for each of the atom types are used in
the second section in association with SMARTS patterns.</P>
<DL>
	<DD>***SMARTS_PATTERNS***</DD><DD>
	P(~[OD1])(~[OD1])~[OD1] 25 36 36 36</DD><DD>
	n 6</DD><DD>
	NC=O 10 18 14</DD><DD>
	NS(=O)=O 1 29 14 14</DD><DD>
	[Nr0]~[C,C+]([#6,#7])~[Nr0] 7 18 0 7</DD><DD>
	[OD1]~N~[OD1] 14 8 14 
	</DD><DD STYLE="margin-bottom: 0.2in">
	<BR><BR>
	</DD></DL>
<P STYLE="margin-bottom: 0in">
The reference numbers following the SMARTS patterns correspond to the
reference numbers given in the atom types section. Atoms matching the
SMARTS patterns will be assigned to the type given by the reference
number unless the reference number is zero. Only the first SMARTS
pattern that covers an atom will be used to assign the atom type. All
subsequent matches of other patterns do not affect an atom's type.
SMARTS patterns are applied in order they appear in atomtyp.txt so
specific patterns should be defined toward the top of the patterns
section and more general patterns toward the bottom. 
</P>
<P STYLE="margin-bottom: 0in">The atom typing system in OELib gives
the user a great deal of control over customizing typing rules. Since
SMARTS patterns determine how OELib perceives a molecule it is rather
trival to write a rule set that reflects the state of functional
groups in any type of media. Charge and protonation states can
reflect a wide variety of pH's in aqueos environments, or organic
solvents. Translating file formats that have low information content
about atom types to those with high information content becomes a
process with much higher certainty and specificity than a system with
hardcoded rules.</P>
<P STYLE="margin-bottom: 0in"><A NAME="patty"></A><FONT SIZE=3><U>patty</U></FONT></P>
<P><FONT SIZE=3>Patty stands for <U>p</U>rogrammable <U>at</U>om
<U>ty</U>per. The patty class was kindly donated by W. Patrick
Walters. The patty class provides a more flexible means for atom
typing than the OEAtomTyper. The behavior of patty is similar to the
OEAtomTyper in that rules apply only to the first atom in the SMARTS
pattern. The patty class can read any free format ASCII file which
contains SMARTS patterns associated with user defined atom type. The
following is an example of a valid patty rule</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>O=C hbacceptor</FONT> 
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The following is a code
sample that demonstrates the use of patty class.</FONT> 
</P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080"><I><FONT SIZE=3>OEMol mol(SDF,SDF);</FONT></I>
</FONT>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">cin &gt;&gt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">string rulefile = &quot;rules.txt&quot;;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">patty p;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">p.read_rules(p);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;string&gt; type;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">p.assign_types(mol,type);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (int i = 1;i &lt;=
mol.NumAtoms();i++)</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;
cout &lt;&lt; &quot;atom number &quot; &lt;&lt; i &lt;&lt; &quot; was
given a type &quot; &lt;&lt; type[i] &lt;&lt; endl;</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The array indices in the
vector&lt;string&gt; into which the result values are placed match
the corresponding atom numbers. Since atoms are numbered beginning
from one, the first element in the vector&lt;string&gt; is empty, and
the values are placed in [1...mol.NumAtoms()].</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3><U>OEGastChrg</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The OEGastChrg class is
responsible for the assignment of partial charges to a molecule
according to the Gasteiger charge model. When the partial charge of
an atom is requested and partial charges do not yet exist for the
molecule the OEGastChrg class will aut</FONT>omatically be called to
assign charges for the molecule. If charges have been read in for a
molecule the following code shows how to force the recalculation of
partial charges.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<ADDRESS><FONT COLOR="#000080">OEMol mol(MOL2,SDF);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cin &gt;&gt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">mol.UnsetPartialChargesPerceived();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEAtom *atom;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OEAtom*&gt;::iterator i;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (atom = mol.BeginAtom(i);atom;atom
= mol.NextAtom(i))</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;atom
number = &quot; &lt;&lt; atom-&gt;GetIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;
charge = &quot; &lt;&lt; atom-&gt;GetPartialCharge() &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">}</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Formal charges are used as
seed values of the initial charge of atoms, and the partial charge is
propagated to neighboring atoms. For example, quaternary amines would
have a +1 charge, and the effect of the positive charge would be felt
by neighboring atoms according to the Gasteiger model.</FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<HR>
<P STYLE="margin-bottom: 0in"><A NAME="Utility Classes"></A><FONT SIZE=3><B>Utility
Classes</B></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Utility classes provide
functionality that is commonly desired in software in general. These
classes facilitate the construction of larger end user programs based
on OELib.</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3><U>OEBitVec</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The OEBitVec class is a
fast and efficient bitstring class that is handy to use as a truth
table. Truth tables are an easy way to store whether a list of items
has a particular propery. Instances of OEBitVec can by dynamically
resized, and have a number of overloaded operators that make code
simple and readable. The following examples demonstrate uses of the
OEBitVec class.</FONT></P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEBitVec bv1,bv2,bv3;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bv1.SetBitOn(5);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bv2.SetBitOff(200);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bv1 |= bv2;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bv1 = bv1 &amp; bv2;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">if (bv1.Empty()) //Empty() returns
true if no bits are set on</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;bv1
= &quot; &lt;&lt; bv1 &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">}</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp; <BR><I><FONT SIZE=3>int bit;</FONT></I></FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (bit = bv1.NextBit(0);bit !=
bv1.EndBit();bit = bv1.NextBit(bit))</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;the
next bit turned on is &quot; &lt;&lt; bit &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">}</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>For a full
description of the OEBitVec class member functions please consult the
header file bitvec.h.</FONT><BR><U><FONT SIZE=3>OEStopwatch</FONT></U></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The OEStopwatch class
makes timing the execution of blocks of code to microsecond accuracy
very simple. The class effectively has two functions, <I>Start()</I>
and <I>Elapsed()</I>. The usage of the OEStopwatch class is
demonstrated by the following code.</FONT></P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEStopwatch sw;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">sw.Start();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">//insert code here</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">cout &lt;&lt;
&quot;Elapsed time = &quot; &lt;&lt; sw.Elapsed() &lt;&lt; endl;</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><BR><FONT SIZE=3>Although based on
system specific function calls, OEStopwatch works on Unix flavored
systems as well as Microsoft Operating systems.</FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3><U>OEExtensionTable</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>A number of file
extensions are common to certain formats of molecule file types. The
OEExtensionTable class facilitates setting input and output types in
the OEMol class based on input and output file names. The
OEExtensionTable class is dependent on a file called extable.txt to
provide the extension to type translation. The following is an
example extable.txt file</FONT></P>
<DL>
	<DD>EXTENSION TYPE</DD><DD>
	sdf sdf</DD><DD>
	mdl sdf</DD><DD>
	mol sdf</DD><DD>
	mol2 mol2</DD><DD>
	pdb pdb</DD><DD>
	ent pdb</DD><DD>
	smi smi</DD><DD>
	box box</DD><DD STYLE="margin-bottom: 0.2in">
	mmd mmd</DD></DL>
<P STYLE="margin-bottom: 0in">
&nbsp; <BR><FONT SIZE=3>The default constructor for the
OEExtensionTable class takes a single parameter specifying the name
of the environment variable which points to the default copy of the
extable.txt file. The OEExtensionTable class will look first at the
current working directory to see if a copy the extable.txt file
exists. If extable.txt is not found, the class with then look in the
directory pointed to by the environment variable for a global copy of
the file. An example of the initialization and usage follows</FONT></P>
<ADDRESS>&nbsp; <BR><I><FONT SIZE=3><FONT COLOR="#000080">OEExtensionTable
extable;</FONT></FONT></I></ADDRESS>
<ADDRESS><FONT COLOR="#000080">enum io_type inputType,outputType;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">inputType =
extable.FilenameToType(&quot;foo.mol2&quot;);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">outputType =
extable.FilenameToType(&quot;bar.sdf&quot;);</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">OEMol
mol(inputType,outputType);</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The input and output types
taken from the extensions on the filenames and used in the molecule
constructor.</FONT></P>
<P><FONT SIZE=3><U>CommandLine</U></FONT></P>
<P><FONT SIZE=3>The command line class provides a means of facile
development of command line interfaces (CLI). The basic idea is that
the CLI is predefined in a class which then parses what was typed on
the command line, checks for errors, and stores the relevant data
until retrieval is necessary. The following code demonstrates how to
define a command line interface.</FONT></P>
<ADDRESS><FONT COLOR="#000080"><FONT SIZE=3><I>Void Usage()</I></FONT></FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cerr &lt;&lt;
&quot;usage statement here&quot; &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; exit(0);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">}</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp; <BR><I><FONT SIZE=3>int
main(int argc,char **argv)</FONT></I></FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bool on;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int val;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;string&gt; files;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">CommandLine cmdline;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cmdline.SetUsageFunction(Usage);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cmdline.AddFlag(&quot;-on&quot;,on);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cmdline.AddFlag(&quot;-value&quot;,val,10);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cmdline.AddFlag(&quot;-files&quot;,files);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cmdline.ProcessArguments(argc,argv);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cerr &lt;&lt; &quot;the state of on is
= &quot; &lt;&lt; on &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cerr &lt;&lt; &quot;the value of val
is = &quot; &lt;&lt; val &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;string&gt;::iterator i;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (i = files.begin();i!=
files.end();i++)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cerr &lt;&lt; &quot;file = &quot; &lt;&lt;
*i &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">}</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in">&nbsp; <BR><FONT SIZE=3>It is important
to set a usage function in the command line class that alerts the
user to errors in the arguments given on the command line. If unknown
flags are used or arguments to flags are omitted the user can be
alerted to the error. The command line interface is defined by the
<I>AddFlag</I>() functions. As the command line arguments are parsed
the values associated with each flag are placed in the variable given
in the <I>AddFlag</I>() function. Default values can be given as a
third argument such as <I>AddFlag(&quot;-val&quot;,val,10)</I>.
Booleans are set to false by default, and turned on if the associated
flag is given on the command line. Please see the file commandline.h
in the distribution for the full list of member functions of the
command line class.</FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<HR>
<P STYLE="margin-bottom: 0in"><A NAME="Atom Data Translation Classes"></A>
<B><FONT SIZE=3>Atom Data Translation Classes</FONT></B> 
</P>
<P STYLE="margin-bottom: 0in"><A NAME="OEElementTable"></A><U><FONT SIZE=3>OEElementTable</FONT></U>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Translating element data
is a common task given that many file formats give either element
symbol or atomic number information, but not both. The OEElementTable
class facilitates conversion between textual and numeric element
information. An instance of the OEElementTable class is declared as a
global in data.cpp. Source files that include the header file mol.h
automatically have an extern definition to the global in data.cpp.
The following code sample demonstrates the use of the OEElementTable
class.</FONT> 
</P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080"><I><FONT SIZE=3>cout &lt;&lt; &quot;The
symbol for element 6 is &quot; &lt;&lt; etab.GetSymbol(6) &lt;&lt;
endl;</FONT></I> </FONT>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">cout &lt;&lt; &quot;The atomic number
for Sulfur is &quot; &lt;&lt; etab.GetAtomicNum(16) &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">cout &lt;&lt;
&quot;The vanDerWaal radius for Nitrogen is &quot; &lt;&lt;
etab.GetVdwRad(7);</FONT></ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3><U>OETypeTable</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Molecular file formats
frequently store information about atoms in an atom type field. Some
formats store only the element for each atom, while others include
hybridization and local environments, such as the mol2 atom type
field. The OETypeTable class acts as a translation table to convert
atom types between a number of different molecular file formats. The
constructor for OETypeTable automatically reads the text file
types.txt. Just as OEElementTable, an instance of OETypeTable is
declared as a global in data.cpp and is referenced as extern
OETypeTable ttab in mol.h.&nbsp; The following code demonstrates how
to use the OETypeTable class to translate the internal representation
of atom types in an OEMol to Sybyl Mol2 atom types.</FONT></P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">ttab.SetFromType(&quot;INT&quot;);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">ttab.SetToType(&quot;SYB&quot;);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEAtom *atom;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OEAtom*&gt;::iterator i;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">string src,dst;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (atom = mol.BeginAtom(i);atom;atom
= mol.EndAtom(i))</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; src =
atom-&gt;GetType();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;
ttab.Translate(dst,src);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;atom
number &quot; &lt;&lt; atom-&gt;GetIdx() &lt;&lt; &quot;has mol2 type
&quot; &lt;&lt; dst &lt;&lt; endl;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">}</FONT></ADDRESS>
<ADDRESS><BR>
</ADDRESS>
<HR>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3><B>Math Classes</B></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3><U>Vector</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>The Vector class was
designed to simplify operations with floating point coordinates. To
this end many of the common operations have been overloaded for
simplicity. Vector addition, subtraction, scalar multiplication, dot
product, cross product, magnitude and a number of other utility
functions are built in to the vector class. For a full description of
the class member functions please consult the header file Vector.h.
The following code demonstrates several of the functions of the
vector class.</FONT></P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">Vector v1,v2,v3;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">v1 = VX;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">v2 = VY;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">v3 = cross(v1,v2);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">v3 *= 2.5;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">v3.normalize();</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><BR><BR>
</ADDRESS>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3><U>Matrix3x3</U></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Rotating points in space
can be performed by a vector-matrix multiplication. The Matrix3x3
class is designed as a helper to the Vector class for rotating points
in space. The rotation matrix may be initialised by passing in the
array of floating point values, by passing euler angles, or a
rotation vector and angle of rotation about that vector. Once set,
the Matrix3x3 class can be used to rotate Vectors by the overloaded
multiplication operator. The following demonstrates the usage of the
Matrix3x3 class.</FONT></P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">Matrix3x3 mat;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">mat.SetupRotMat(0.0,180.0,0.0);
//rotate theta by 180 degrees</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">Vector v = VX;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080"><I>v *= mat;</I> //apply the rotation</FONT></ADDRESS>
<ADDRESS><BR>
</ADDRESS>
<HR>
<P STYLE="margin-bottom: 0in"><A NAME="Examples"></A><B><FONT SIZE=3>Examples</FONT></B>
</P>
<P STYLE="margin-bottom: 0in"><A NAME="Largest Ring Extraction"></A><U><FONT SIZE=3>Largest
Ring Extraction</FONT></U> 
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Finding the largest ring
system in a molecule is a useful example of how to loop over atoms
and bonds in a molecule, as well as proper usage of the OEBitVec
class. The FindLargestRingSystem function uses the method of
expanding shells to identify ring systems. A seed atom is chosen
which is part of a cycle, and all bonds of the seed are crossed if
the bonds are part of a ring system. The same operations are
performed to the new shell that has been created by following cyclic
bonds. When no more shells are found a ring system has been
identified, and it is stored if it is larger than any previously
identified ring system. The bits corresponding to the atoms numbers
in the largest ring system are turned on the OEBitVec bv which is
passed as the second argument to the function.</FONT> 
</P>
<ADDRESS><BR>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080"><I><FONT SIZE=3>void
FindLargestRingSystem(OEMol &amp;mol,OEBitVec &amp;bv)</FONT></I> </FONT>
</ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">bv.Clear(); //unset all bits</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int j;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEAtom *atom,*nbr;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OEAtom*&gt;::iterator i;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">vector&lt;OEBond*&gt;::iterator k;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEBitVec rsys,curr,used,next;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (atom = mol.BeginAtom(i);atom;atom
= mol.NextAtom(i)) //loop over all atoms</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; if
(atom-&gt;IsInRing() &amp;&amp; !used[atom-&gt;GetIdx()])</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// if the atom is a member of a ring and hasn't already been visited</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; {</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsys.Clear();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
curr.Clear();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsys |= atom-&gt;GetIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
curr |= atom-&gt;GetIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
used |= atom-&gt;GetIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">//set an atom on in the curr bitvec -
then loop over all of the neighbors of atoms</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">//in the curr bitvec and put them in
the next bitvec. Transfer the next bitvec</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">//to the curr bitvec when no new
neighbors are found.</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; while
(!curr.Empty())</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; {</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
next.Clear();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (j = curr.NextBit(0);j != curr.EndBit();j = curr.NextBit(j))</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
atom = mol.GetAtom(j);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (nbr = atom-&gt;BeginNbrAtom(k);nbr;nbr = atom-&gt;NextNbrAtom(k))</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ((*k)-&gt;IsInRing() &amp;&amp; !used[nbr-&gt;GetIdx()])</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
next |= nbr-&gt;GetIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
used |= nbr-&gt;GetIdx();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rsys |= next;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
curr = next;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; }</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; if
(rsys.CountBits() &gt; bv.CountBits())</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; bv = rsys;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">&nbsp;&nbsp;&nbsp; }</FONT></ADDRESS>
<ADDRESS STYLE="margin-bottom: 0.2in"><FONT COLOR="#000080">}</FONT></ADDRESS>
<P><A NAME="SMARTS Grep"></A><U>SMARTS Grep</U></P>
<P STYLE="text-decoration: none">A crude method of substructure
searching can be accomplished in much the same way as the Unix<SUP>tm</SUP>
grep command. The SMARTS grep program given below takes a SMARTS
string and a smiles filename on the command line. All molecules that
match the SMARTS pattern are then written to standard out. Note that
the program can be modified to read from any file format that OELib
supports, as well as write out any file format just by changing the
declaration of OEMol.</P>
<ADDRESS><FONT COLOR="#000080">#include &quot;mol.h&quot;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">#include &quot;oeutil.h&quot;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">#include &quot;parsmart.h&quot;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">using namespace std;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">using namespace OpenEye;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">int main(int argc,char **argv)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">if (argc != 3)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">string err = &quot;Usage: &quot;;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">err += argv[0];</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">err += &quot; \&quot;PATTERN\&quot;
filename.smi&quot;;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">ThrowError(err);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">exit(0);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">}</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OESmartsPattern sp;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">sp.Init(argv[1]);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">ifstream ifs;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">if (!SafeOpen(ifs,argv[2])) return(1);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">OEMol mol(SMI,SMI);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">for (;;)</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">{</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">mol.Clear();</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">ifs &gt;&gt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">if (mol.Empty()) break;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">if (sp.Match(mol))</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">cout &lt;&lt; mol;</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">}</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">return(1);</FONT></ADDRESS>
<ADDRESS><FONT COLOR="#000080">}</FONT> 
</ADDRESS>
<ADDRESS><BR>
</ADDRESS>
<HR>
<P ALIGN=CENTER><A NAME="Acknowledgments"></A><FONT SIZE=3><B>Acknowledgments</B></FONT></P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3>Many thanks to those who
have participated in the development of OELib.</FONT> 
</P>
<DL>
	<DD><FONT SIZE=3>Joe Corkery</FONT> 
	</DD><DD>
	Brian Goldman</DD><DD>
	Anthony Nicholls</DD><DD>
	Roger Sayle</DD><DD STYLE="margin-bottom: 0.2in">
	Patrick Walters</DD></DL>
<P STYLE="margin-bottom: 0in">
<BR>
</P>
</BODY>
</HTML>