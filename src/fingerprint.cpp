/**********************************************************************
Fingerprint.cpp: Handle fingerprints.

Copyright (C) 2004 by Fabien Fontaine.

This file is part of the Open Babel project.
For more information, see <http://openbabel.sourceforge.net/>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
***********************************************************************/
/*

/** \class fingerprint
\brief 2D Fingerprint class

To compute the fingerprint fpt for a molecule mol
\code
  fingerprint fpt(mol.GetTitle());
  fpt.HashMol(mol);  
\endcode

The fingerprint computation requires the execution of the following steps:
- Obtain the fragments
- Remove duplicate fragments and get a hash number for each fragment
- Obtain the fingerprint of the fragments

The fragments are obtained by means of a recursive algorithm. The algorithm finds all linear fragments up to a size of seven atoms. Cyclic fragments are also identified by checking if there are ring closures in the linear fragment. However, the algorithm does not identify branched fragments if there are not part of a ring. 
for example CC(C)C will have the fragments:
C
CC  
CCC 
and C1C(C)C1 will have the fragments:
C
CC
CCC
C1CC1
CC1CC1

Duplicate fragments, i.e. fragment generated by the same atoms, are removed from the fragment list. The only fragment that are kept are the ones which produce the lowest hash numbers.
The hash number for a fragment is an integer number which is generated from the atoms and bonds of the fragment. The value of this number depends on the position, the atomic number and type (aromatic or not) of the atoms of the fragment, the position and the type of the bonds of the fragments, the position and the type of the ring closures.

The fingerprint is a bitstring of 1021 bits. It is evident that there are many more possible fragments than 1021, and consequently the hash number is often higher than 1021. It is easy to obtain a number lower than 1021 from the hash number, just by dividing the hash number by 1021 and by keeping the reminder. this reminder is then used to set a bit to one in the fingerprint.
Actually, the size of the bitstring is of 1024 bits but we divide by 1021 because 1021 is a prime number which produces a better hashing than an even number such as 1024. Consequently, the three last bits of the fingerprint are always set to zero.    

To print the fingerprint in ascii format use the function printFingerprint.

*/

#include "mol.h"
#include "fingerprint.h"

using namespace std;

namespace OpenBabel {

///////////////////////////////////////////////////////////////////////////////
//! \brief  Compute and print the fingerprint into ofs
bool WriteFingerprint(ostream &ofs, OBMol &mol)
{
  fingerprint fpt(mol.GetTitle());
  fpt.HashMol(mol);
  fpt.printFingerprint(ofs);

  return(true);
}


///////////////////////////////////////////////////////////////////////////////
//! \brief print at which atom a ring close
void AtomRing::printRingClosure(void)
{
  vector<int>::iterator i;

  for(i=_ringClosure.begin(); i != _ringClosure.end(); i++) {
    cout << ":" << *i ;
  }
}

///////////////////////////////////////////////////////////////////////////////
//! \brief fragment constructor
fragment::fragment(OBAtom *atom) 
{
  AtomRing ar(atom);
  _atoms.push_back(ar);
  _hash=0;
  int i;
  for(i=0; i<MAX_FRAGMENT_SIZE; i++) 
    _index[i]=0;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Get the last atom of the list
OBAtom *fragment::GetLastAtom(void) 
{
  if (_atoms.empty()) 
    return NULL;
  else
    return (_atoms.back()).GetAtom();
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Get the atom before the last atom
OBAtom* fragment::GetBeforeLastAtom(void)
{
  if (_atoms.size() < 2)
    return NULL;
  
  list<AtomRing>::iterator i = _atoms.end();
  i--;i--;
  return (*i).GetAtom();
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Find if there are ring closure and add them 
void fragment::SetRingClosure(OBAtom *atom)
{
  list<AtomRing>::iterator i;
  int n, Idx = atom->GetIdx(), pos=0;
  for(i = _atoms.begin(), n=1; i != _atoms.end(); i++, n++) {
    if ( (*i).GetAtomIdx() == Idx)
      pos = n;      
  }
  (_atoms.back()).AddRingClosure(pos);
  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Print the atoms of a fragment
void fragment::printAtoms(void)
{
  list<AtomRing>::iterator i;
  for(i= _atoms.begin(); i != _atoms.end(); i++) {
    cout << (*i).GetAtomIdx();
    (*i).printRingClosure();
    cout << " ";
  }
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Return the atom index of atom i of the fragment
int fragment::getIndex(int i)
{
  if (i<MAX_FRAGMENT_SIZE) 
    return _index[i];
  else {
    cerr << "Error: Index higher than fragment size\n";
    return 0;
  }
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Store the index of each atom of the fragment
void fragment::setIndexes(void)
{
  list<AtomRing>::iterator i;
  int Idx, c;
  for(i= _atoms.begin(), c=0; i != _atoms.end(); i++, c++) {
    Idx = (*i).GetAtomIdx();
    if (c == MAX_FRAGMENT_SIZE) {
      cerr << "Error: Fragment bigger than " << MAX_FRAGMENT_SIZE << endl;
      return;
    }
    _index[c]=Idx;
  }

  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Sort the indexes of the atoms of the fragment 
void fragment::sortIndexes(void)
{
  int i;
  for( i=0; i < MAX_FRAGMENT_SIZE; i++) {
    if (_index[i] == 0)
      break;
  }
  
  qsort (_index, i, sizeof (int), *compareInt);

  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Compare two indexes
int compareInt (const void *a, const void *b)
{
 int *v1 = (int *) a, *v2 = (int *) b;
 return (*v1 > *v2) - (*v1 < *v2);
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Print the indexes of the atoms of the fragment
void fragment::printIndexes(void)
{
  int i;
  
  for( i=0; i < MAX_FRAGMENT_SIZE; i++) {
    if (_index[i] == 0)
      break;
    cout << _index[i] << " ";
  }

  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Generate a hash number from the atoms of the fragment
void fragment::setHashNumber(void)
{
  long int anumber=0, bnumber=0, cnumber=0;
  list<AtomRing>::iterator i;
  list<AtomRing>::iterator j;
  OBAtom *atomi, *atomj;
  OBBond *bond;
  //set atom number
  for(i=_atoms.begin(); i != _atoms.end(); i++) {
    atomi = (*i).GetAtom();
    anumber *= 8;
    anumber += atomi->GetAtomicNum();
    anumber *= 2;
    if ( atomi->IsAromatic())
      anumber += 1;
  }
  //set bond number
  OBMol *mol;
  i=j=_atoms.begin();
  j++;
  if (!_atoms.empty()) {
    atomi = (*i).GetAtom();
    mol = (OBMol*) atomi->GetParent();
    for( ; j != _atoms.end(); i++, j++) {
      atomi = (*i).GetAtom();
      atomj = (*j).GetAtom();
      bond = mol->GetBond(atomi,atomj);
      if (!bond) { 
	cout << "Error: No bond between two atoms\n";
	return;
      }
       bnumber *= 4;
       if (bond->IsDouble())
	bnumber +=1;
      if (bond->IsTriple())
	bnumber +=2;
      if (bond->IsAromatic())
	bnumber +=3;     
    }
  }
  //set ring closure number
  vector<int>::iterator v;
  vector<int> rc;
  int ni, nj;
  for(i=_atoms.begin(), ni=1; i != _atoms.end(); i++, ni++) {
    rc = (*i).GetRingClosure();
    atomi = (*i).GetAtom();
    if ( rc.empty() )
      continue;
    for (v = rc.begin(); v != rc.end(); v++) {

      // get the ring closure atom
      for(j=_atoms.begin(), nj=1; j != _atoms.end(); j++, nj++) {
	if (nj== *v) {
	  atomj = (*j).GetAtom();
	  break;
	}
      }
      // get the ring closure bond
      mol = (OBMol*) atomi->GetParent();
      bond = mol->GetBond(atomi,atomj);
      if (!bond) { 
	cout << "Error: No bond between two atoms\n";
	return;
      }
      cnumber *= 8;
      cnumber += ni;
      cnumber *= 8;
      cnumber += nj;
      cnumber *= 4;
      if (bond->IsDouble())
	cnumber +=1;
      if (bond->IsTriple())
	cnumber +=2;
      if (bond->IsAromatic())
	cnumber +=3;
    }
  }
  _hash = anumber + bnumber + cnumber;
  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Fingerprint constructor
fingerprint::fingerprint(const char *name)
{ 
  _name=name; 
  _pf = NULL; 
  _pfsize = 0; 
  _fpt.Resize(1024);
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Find all the linear and cyclic fragment of size MAX_FRAGMENT_SIZE
void fingerprint::GetFragments(OBMol &mol)
{
  
  OBAtom *atom; 
  OBBitVec avisit;
  avisit.Resize(mol.NumAtoms()+1);

  vector<OBNodeBase*>::iterator i;
  for (atom = mol.BeginAtom(i);atom;atom = mol.NextAtom(i)) {
    fragment f(atom);
    expandFragment(f, avisit,1);
  }
  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief recursive finding of the fragments
void fingerprint::expandFragment(fragment &f, OBBitVec &avisit, int n)
{

  OBAtom *atom = f.GetLastAtom();
  OBAtom *blatom = f.GetBeforeLastAtom();
  OBAtom *nbr;
  OBBond *bond;
  std::vector<OBEdgeBase*>::iterator i;
  int natom,Idx;
 
  if ( !atom ) {
    cerr << "Error: empty fragment\n";
    return;
  }
  Idx = atom->GetIdx();
  avisit.SetBitOn(Idx);

  // check for ring closure
  if (blatom)
    for (nbr = atom->BeginNbrAtom(i);nbr;nbr = atom->NextNbrAtom(i)) {
      natom = nbr->GetIdx();
      if (avisit[natom] ) {
	if (blatom->GetIdx() != natom) // ring closure
	  f.SetRingClosure(nbr);
      }
    }
  
  // save the fragment
  _flist.push_back(f);
  if (n < MAX_FRAGMENT_SIZE) {
    //next fragment
    n++;
    for (nbr = atom->BeginNbrAtom(i);nbr;nbr = atom->NextNbrAtom(i))
      {
	natom = nbr->GetIdx();
	if (!avisit[natom] ) {
	  f.addAtom(nbr);
	  expandFragment(f, avisit, n);
	}
	
      }
  }
  f.RemoveLastAtom();
  avisit.SetBitOff(Idx);

  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Print all the fragments
void fingerprint::printFragments(void)
{

  int i;
  for(i=0; i< _flist.size(); i++) {
    cout << "Fragment " << i << ": ";
    (_flist[i]).printAtoms();
    cout << ", ";
    (_flist[i]).printIndexes();
    cout << " hash:";
    (_flist[i]).printHash();
    cout << endl;
  }
  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Sort the atom indexes of each fragment
void fingerprint::sortFragmentIdx(void)
{
  int i;
  for(i=0; i< _flist.size(); i++)
    (_flist[i]).sortIndexes();
  
  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Set the atom indexes of each fragment
void fingerprint::setFragmentIdx(void)
{
  int i;
  for(i=0; i< _flist.size(); i++)
    (_flist[i]).setIndexes();
  
  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Set the pointers to each fragment for sorting
int fingerprint::setPointers(void)
{
  if ( _pf ) {
    free (_pf);
    _pf = NULL;
  }
    //delete [] _pf;
    
  int size = _flist.size();
  vector<fragment>::iterator i;
  fragment *frag, **p;

  //_pf = new fragment*[size];
  _pf = (fragment **) calloc(size,sizeof(fragment *));
  if (!_pf) {
    cerr << "Error unable to alloc memory for pointers\n";
    return 0;
  }
    
  _pfsize = size;
  for(i= _flist.begin(),p=_pf; i != _flist.end(); i++, p++) {
    frag = &(*i);
    *p = frag;
  }

  return 1;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Print the fragment of each pointer
void fingerprint::printPointers(void)
{
  int i;
  fragment *p;
  for(i=0; i< _pfsize; i++) {
    p = _pf[i];
    p->printAtoms();
    cout << ", ";
    p->printIndexes();
    cout << " hash:";
    p->printHash();
    cout << endl;
  }
  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Sort the pointer according to the fragment atom indexes
void fingerprint::sortPointers(void)
{
  qsort (_pf, _pfsize, sizeof (fragment *), *compareFragment);
  return;
}


///////////////////////////////////////////////////////////////////////////////
//! \brief Compare two fragments according to the order of the atom indexes
//  The comparison is valid only if the indexes have been previously sorted
int compareFragment (const void *a, const void *b)
{
 fragment **v1 = (fragment **) a, **v2 = (fragment **) b;
 fragment *f1 = *v1, *f2 = *v2;
 int i;
 for(i=0; i<MAX_FRAGMENT_SIZE; i++)
   {
     if ( f1->getIndex(i) < f2->getIndex(i))
       return -1;
     if ( f1->getIndex(i) > f2->getIndex(i))
       return 1;
   }
 
 return 0;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief For each duplicate fragment take the one with the lowest hash number
void fingerprint::setUniqueFragments(void)
{
  fragment **puf, **pf;
  int isdifferent, i;

  // Store the fragment atom numbers
  setFragmentIdx();

  // Sort these atom numbers for comparison
  sortFragmentIdx();

  // Store the pointers to each fragment
  setPointers();
  
  // Sort these pointer
  sortPointers();
  
  // compute the hash number
  for(i=0; i< _flist.size(); i++) {
    (_flist[i]).setHashNumber();
  }
  // printPointers();
  // Get the fragments with the lower hash number
  if (_pfsize == 0)
    return;
  if ( _pfsize == 1) {
    _uflist.push_back(**_pf);
    return;
  }
  
  puf = _pf;
  for (pf = _pf+1, i=1; i < _pfsize; pf++, i++) {
  
    isdifferent = compareFragment(puf, pf);
    if (isdifferent) {
      _uflist.push_back(**puf);
      puf=pf;
    }
    else {
      if ( (*pf)->getHash() < (*puf)->getHash()  )
	puf = pf;
    }
  }
  _uflist.push_back(**puf);

  //printUniqueFragments();
  return;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Print the unique fragment list
void fingerprint::printUniqueFragments(void)
{

  int i;
  for(i=0; i< _uflist.size(); i++) {
    cout << "Fragment " << i << ": ";
    (_uflist[i]).printAtoms();
    cout << ", ";
    (_uflist[i]).printIndexes();
    cout << " hash:";
    (_uflist[i]).printHash();
    cout << endl;
  }
  return;
}
///////////////////////////////////////////////////////////////////////////////
//! \brief For each hash number set a bit in the bitstring
void fingerprint::HashFragments(void)
{
  vector<fragment>::iterator i;
  long int h;
  int mod, test;
  for(i= _uflist.begin(); i != _uflist.end(); i++) {
    h = i->getHash();
    mod = h % 1021; // hashing with a prime number is better than 1024
    _fpt.SetBitOn(mod);
  }
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Print the fingerprint
void fingerprint::printFingerprint(ostream &ofs)
{
  int i;
  ofs << ">" << _name << endl;
  for(i=0; i< _fpt.GetSize()*SETWORD; i++ ) {
    if (_fpt[i])
      ofs << "1";
    else 
      ofs << "0";
  }
  ofs << endl;
}

///////////////////////////////////////////////////////////////////////////////
//! \brief Run the sequence of operations necessary to compute the fingerprint 
void fingerprint::HashMol(OBMol &mol)
{
  // Obtain all the linear and ring fragments
  GetFragments(mol);
  // Remove duplicate fragments and get a hash number for each fragment
  setUniqueFragments();
  // Obtain the fingerprint of the fragments
  HashFragments();

  return;
}



}
