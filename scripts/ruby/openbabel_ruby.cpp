/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.31
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGRUBY

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC)
#   if (__SUNPRO_CC <= 0x560)
#     define SWIGTEMPLATEDISAMBIGUATOR template
#   else
#     define SWIGTEMPLATEDISAMBIGUATOR 
#   endif
# else
#   define SWIGTEMPLATEDISAMBIGUATOR 
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC)
#   if (__SUNPRO_CC <= 0x560)
#     define SWIGTEMPLATEDISAMBIGUATOR template
#   else
#     define SWIGTEMPLATEDISAMBIGUATOR 
#   endif
# else
#   define SWIGTEMPLATEDISAMBIGUATOR 
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic CAPI SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "3"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The swig conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old swig versions, you usually write code as:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit as:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   that seems to be the same, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   requires also to SWIG_ConvertPtr to return new result values, as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   swig errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()


 */
#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))


/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif




#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store inforomation on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/* think of this as a c++ template<> or a scheme macro */
#define SWIG_TypeCheck_Template(comparison, ty)         \
  if (ty) {                                             \
    swig_cast_info *iter = ty->cast;                    \
    while (iter) {                                      \
      if (comparison) {                                 \
        if (iter == ty->cast) return iter;              \
        /* Move iter to the top of the linked list */   \
        iter->prev->next = iter->next;                  \
        if (iter->next)                                 \
          iter->next->prev = iter->prev;                \
        iter->next = ty->cast;                          \
        iter->prev = 0;                                 \
        if (ty->cast) ty->cast->prev = iter;            \
        ty->cast = iter;                                \
        return iter;                                    \
      }                                                 \
      iter = iter->next;                                \
    }                                                   \
  }                                                     \
  return 0

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
}

/* Same as previous function, except strcmp is replaced with a pointer comparison */
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
  SWIG_TypeCheck_Template(iter->type == from, into);
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



#include <ruby.h>

/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/* RSTRING_LEN, etc are new in Ruby 1.9, but ->ptr and ->len no longer work */
/* Define these for older versions so we can just write code the new way */
#ifndef RSTRING_LEN
# define RSTRING_LEN(x) RSTRING(x)->len
#endif
#ifndef RSTRING_PTR
# define RSTRING_PTR(x) RSTRING(x)->ptr
#endif
#ifndef RARRAY_LEN
# define RARRAY_LEN(x) RARRAY(x)->len
#endif
#ifndef RARRAY_PTR
# define RARRAY_PTR(x) RARRAY(x)->ptr
#endif

/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif


/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */


/* Define some additional error types */
#define SWIG_ObjectPreviouslyDeletedError  -100


/* Define custom exceptions for errors that do not map to existing Ruby
   exceptions.  Note this only works for C++ since a global cannot be
   initialized by a funtion in C.  For C, fallback to rb_eRuntimeError.*/

SWIGINTERN VALUE 
getNullReferenceError(void) {
  static int init = 0;
  static VALUE rb_eNullReferenceError ;
  if (!init) {
    init = 1;
    rb_eNullReferenceError = rb_define_class("NullReferenceError", rb_eRuntimeError);
  }
  return rb_eNullReferenceError;
} 

SWIGINTERN VALUE 
getObjectPreviouslyDeletedError(void) {
  static int init = 0;
  static VALUE rb_eObjectPreviouslyDeleted ;
  if (!init) {
    init = 1;
    rb_eObjectPreviouslyDeleted = rb_define_class("ObjectPreviouslyDeleted", rb_eRuntimeError);
  }
  return rb_eObjectPreviouslyDeleted;
} 


SWIGINTERN VALUE
SWIG_Ruby_ErrorType(int SWIG_code) {
  VALUE type;
  switch (SWIG_code) {
  case SWIG_MemoryError:
    type = rb_eNoMemError;
    break;
  case SWIG_IOError:
    type = rb_eIOError;
    break;
  case SWIG_RuntimeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_IndexError:
    type = rb_eIndexError;
    break;
  case SWIG_TypeError:
    type = rb_eTypeError;
    break;
  case SWIG_DivisionByZero:
    type = rb_eZeroDivError;
    break;
  case SWIG_OverflowError:
    type = rb_eRangeError;
    break;
  case SWIG_SyntaxError:
    type = rb_eSyntaxError;
    break;
  case SWIG_ValueError:
    type = rb_eArgError;
    break;
  case SWIG_SystemError:
    type = rb_eFatal;
    break;
  case SWIG_AttributeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_NullReferenceError:
    type = getNullReferenceError();
    break;
  case SWIG_ObjectPreviouslyDeletedError:
    type = getObjectPreviouslyDeletedError();
    break;
  case SWIG_UnknownError:
    type = rb_eRuntimeError;
    break;
  default:
    type = rb_eRuntimeError;
  }
  return type;
}




/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from 
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif


/* Global Ruby hash table to store Trackings from C/C++
   structs to Ruby Objects. */
static VALUE swig_ruby_trackings;

/* Global variable that stores a reference to the ruby
   hash table delete function. */
static ID swig_ruby_hash_delete = 0;

/* Setup a Ruby hash table to store Trackings */
SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
  /* Create a ruby hash table to store Trackings from C++ 
     objects to Ruby objects.  Also make sure to tell
     the garabage collector about the hash table. */
  swig_ruby_trackings = rb_hash_new();
  rb_gc_register_address(&swig_ruby_trackings);
  
  /* Now store a reference to the hash table delete function
     so that we only have to look it up once.*/
  swig_ruby_hash_delete = rb_intern("delete");
}

/* Get a Ruby number to reference a pointer */
SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr) {
  /* We cast the pointer to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the pointer to a Ruby number */
  unsigned long value = (unsigned long) ptr;
  return LONG2NUM(value);
}

/* Get a Ruby number to reference an object */
SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object) {
  /* We cast the object to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the Object to a Ruby number */
  unsigned long value = (unsigned long) object;
  return LONG2NUM(value);
}

/* Get a Ruby object from a previously stored reference */
SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference) {
  /* The provided Ruby number object is a reference
     to the Ruby object we want.*/

  /* First convert the Ruby number to a C number */
  unsigned long value = NUM2LONG(reference);
  return (VALUE) value;
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
  /* In a Ruby hash table we store the pointer and
     the associated Ruby object.  The trick here is
     that we cannot store the Ruby object directly - if
     we do then it cannot be garbage collected.  So
     instead we typecast it as a unsigned long and
     convert it to a Ruby number object.*/

  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Get a reference to the Ruby object as a Ruby number */
  VALUE value = SWIG_RubyObjectToReference(object);

  /* Store the mapping to the global hash table. */
  rb_hash_aset(swig_ruby_trackings, key, value);
}

/* Get the Ruby object that owns the specified C/C++ struct */
SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Now lookup the value stored in the global hash table */
  VALUE value = rb_hash_aref(swig_ruby_trackings, key);
	
  if (value == Qnil) {
    /* No object exists - return nil. */
    return Qnil;
  }
  else {
    /* Convert this value to Ruby object */
    return SWIG_RubyReferenceToObject(value);
  }
}

/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
   is very important to remove objects once they are destroyed
   since the same memory address may be reused later to create
   a new object. */
SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Delete the object from the hash table by calling Ruby's
     do this we need to call the Hash.delete method.*/
  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object */
SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
  VALUE object = SWIG_RubyInstanceFor(ptr);

  if (object != Qnil) {
    DATA_PTR(object) = 0;
  }
}


#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * Ruby API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN VALUE
SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
  if (NIL_P(target)) {
    target = o;
  } else {
    if (TYPE(target) != T_ARRAY) {
      VALUE o2 = target;
      target = rb_ary_new();
      rb_ary_push(target, o2);
    }
    rb_ary_push(target, o);
  }
  return target;
}

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * rubyrun.swg
 *
 * This file contains the runtime support for Ruby modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0

/* for raw pointers */
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
#define swig_owntype                                    ruby_owntype

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule()	
#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), msg)
#define SWIG_fail                        		goto fail				 


/* Ruby-specific SWIG API */

#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  


/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* cc-mode */
#endif
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
  int trackObjects;
} swig_class;


static VALUE _mSWIG = Qnil;
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

SWIGRUNTIME VALUE 
getExceptionClass(void) {
  static int init = 0;
  static VALUE rubyExceptionClass ;
  if (!init) {
    init = 1;
    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern("Exception"));
  }
  return rubyExceptionClass;
} 

/* This code checks to see if the Ruby object being raised as part
   of an exception inherits from the Ruby class Exception.  If so,
   the object is simply returned.  If not, then a new Ruby exception
   object is created and that will be returned to Ruby.*/
SWIGRUNTIME VALUE
SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
  VALUE exceptionClass = getExceptionClass();
  if (rb_obj_is_kind_of(obj, exceptionClass)) {
    return obj;
  }  else {
    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
  }
}

/* Initialize Ruby runtime support */
SWIGRUNTIME void
SWIG_Ruby_InitRuntime(void)
{
  if (_mSWIG == Qnil) {
    _mSWIG = rb_define_module("SWIG");
  }
}

/* Define Ruby class for C type */
SWIGRUNTIME void
SWIG_Ruby_define_class(swig_type_info *type)
{
  VALUE klass;
  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
  sprintf(klass_name, "TYPE%s", type->name);
  if (NIL_P(_cSWIG_Pointer)) {
    _cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
    rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
  }
  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
  free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
  int own =  flags & SWIG_POINTER_OWN; 
  
  char *klass_name;
  swig_class *sklass;
  VALUE klass;
  VALUE obj;
  
  if (!ptr)
    return Qnil;
  
  if (type->clientdata) {
    sklass = (swig_class *) type->clientdata;
		
    /* Are we tracking this class and have we already returned this Ruby object? */
    if (sklass->trackObjects) {
      obj = SWIG_RubyInstanceFor(ptr);
      
      /* Check the object's type and make sure it has the correct type.
        It might not in cases where methods do things like 
        downcast methods. */
      if (obj != Qnil) {
        VALUE value = rb_iv_get(obj, "__swigtype__");
        char* type_name = RSTRING_PTR(value);
				
        if (strcmp(type->name, type_name) == 0) {
          return obj;
        }
      }
    }

    /* Create a new Ruby object */
    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);

    /* If tracking is on for this class then track this object. */
    if (sklass->trackObjects) {
      SWIG_RubyAddTracking(ptr, obj);
    }
  } else {
    klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
    free((void *) klass_name);
    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
  }
  rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
  
  return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
  VALUE obj;
  swig_class *sklass = (swig_class *) type->clientdata;
  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
  rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
  return obj;
}

/* Get type mangle from class name */
SWIGRUNTIMEINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "__swigtype__");
  return StringValuePtr(stype);
}

/* Acquire a pointer value */
typedef void (*ruby_owntype)(void*);

SWIGRUNTIME ruby_owntype
SWIG_Ruby_AcquirePtr(VALUE obj, ruby_owntype own) {
  if (obj) {
    ruby_owntype oldown = RDATA(obj)->dfree;
    RDATA(obj)->dfree = own;
    return oldown;
  } else {
    return 0;
  }
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)
{
  char *c;
  swig_cast_info *tc;
  void *vptr = 0;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return SWIG_OK;
  } else {
    if (TYPE(obj) != T_DATA) {
      return SWIG_ERROR;
    }
    Data_Get_Struct(obj, void, vptr);
  }
  
  if (own) *own = RDATA(obj)->dfree;
    
  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
    /* Is tracking on for this class? */
    int track = 0;
    if (ty && ty->clientdata) {
      swig_class *sklass = (swig_class *) ty->clientdata;
      track = sklass->trackObjects;
    }
		
    if (track) {
      /* We are tracking objects for this class.  Thus we change the destructor
       * to SWIG_RubyRemoveTracking.  This allows us to
       * remove the mapping from the C++ to Ruby object
       * when the Ruby object is garbage collected.  If we don't
       * do this, then it is possible we will return a reference 
       * to a Ruby object that no longer exists thereby crashing Ruby. */
      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
    } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
        if (vptr == 0) {
          /* The object has already been deleted */
          return SWIG_ObjectPreviouslyDeletedError;
        }
        *ptr = vptr;
        return SWIG_OK;
      }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      return SWIG_ERROR;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      return SWIG_ERROR;
    }
    *ptr = SWIG_TypeCast(tc, vptr);
  } else {
    *ptr = vptr;
  }
  
  return SWIG_OK;
}

/* Check convert */
SWIGRUNTIMEINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c) return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

SWIGRUNTIME VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:
  return SWIG_ERROR;
}

SWIGRUNTIME swig_module_info *
SWIG_Ruby_GetModule(void)
{
  VALUE pointer;
  swig_module_info *ret = 0;
  VALUE verbose = rb_gv_get("VERBOSE");

 /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
  rb_gv_set("VERBOSE", Qfalse);
  
  /* first check if pointer already created */
  pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  if (pointer != Qnil) {
    Data_Get_Struct(pointer, swig_module_info, ret);
  }

  /* reinstate warnings */
  rb_gv_set("VERBOSE", verbose);
  return ret;
}

SWIGRUNTIME void 
SWIG_Ruby_SetModule(swig_module_info *pointer)
{
  /* register a new class */
  VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
  /* create and store the structure pointer to a global variable */
  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
  rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

#ifdef __cplusplus
#if 0
{ /* cc-mode */
#endif
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_OpenBabel__CharPtrLess swig_types[0]
#define SWIGTYPE_p_OpenBabel__DoubleType swig_types[1]
#define SWIGTYPE_p_OpenBabel__FMapType__iterator swig_types[2]
#define SWIGTYPE_p_OpenBabel__FastSearch swig_types[3]
#define SWIGTYPE_p_OpenBabel__FastSearchIndexer swig_types[4]
#define SWIGTYPE_p_OpenBabel__FptIndex swig_types[5]
#define SWIGTYPE_p_OpenBabel__FptIndexHeader swig_types[6]
#define SWIGTYPE_p_OpenBabel__OBAngle swig_types[7]
#define SWIGTYPE_p_OpenBabel__OBAngleData swig_types[8]
#define SWIGTYPE_p_OpenBabel__OBAromaticTyper swig_types[9]
#define SWIGTYPE_p_OpenBabel__OBAtom swig_types[10]
#define SWIGTYPE_p_OpenBabel__OBAtomAtomIter swig_types[11]
#define SWIGTYPE_p_OpenBabel__OBAtomBondIter swig_types[12]
#define SWIGTYPE_p_OpenBabel__OBAtomTyper swig_types[13]
#define SWIGTYPE_p_OpenBabel__OBBase swig_types[14]
#define SWIGTYPE_p_OpenBabel__OBBitVec swig_types[15]
#define SWIGTYPE_p_OpenBabel__OBBond swig_types[16]
#define SWIGTYPE_p_OpenBabel__OBChainsParser swig_types[17]
#define SWIGTYPE_p_OpenBabel__OBChiralData swig_types[18]
#define SWIGTYPE_p_OpenBabel__OBCommentData swig_types[19]
#define SWIGTYPE_p_OpenBabel__OBConformerData swig_types[20]
#define SWIGTYPE_p_OpenBabel__OBConversion swig_types[21]
#define SWIGTYPE_p_OpenBabel__OBElement swig_types[22]
#define SWIGTYPE_p_OpenBabel__OBElementTable swig_types[23]
#define SWIGTYPE_p_OpenBabel__OBError swig_types[24]
#define SWIGTYPE_p_OpenBabel__OBExternalBond swig_types[25]
#define SWIGTYPE_p_OpenBabel__OBExternalBondData swig_types[26]
#define SWIGTYPE_p_OpenBabel__OBFFCalculation swig_types[27]
#define SWIGTYPE_p_OpenBabel__OBFFParameter swig_types[28]
#define SWIGTYPE_p_OpenBabel__OBFingerprint swig_types[29]
#define SWIGTYPE_p_OpenBabel__OBForceField swig_types[30]
#define SWIGTYPE_p_OpenBabel__OBFormat swig_types[31]
#define SWIGTYPE_p_OpenBabel__OBGenericData swig_types[32]
#define SWIGTYPE_p_OpenBabel__OBGlobalDataBase swig_types[33]
#define SWIGTYPE_p_OpenBabel__OBInternalCoord swig_types[34]
#define SWIGTYPE_p_OpenBabel__OBIsotopeTable swig_types[35]
#define SWIGTYPE_p_OpenBabel__OBMessageHandler swig_types[36]
#define SWIGTYPE_p_OpenBabel__OBMol swig_types[37]
#define SWIGTYPE_p_OpenBabel__OBMolAngleIter swig_types[38]
#define SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter swig_types[39]
#define SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter swig_types[40]
#define SWIGTYPE_p_OpenBabel__OBMolAtomIter swig_types[41]
#define SWIGTYPE_p_OpenBabel__OBMolBondIter swig_types[42]
#define SWIGTYPE_p_OpenBabel__OBMolPairIter swig_types[43]
#define SWIGTYPE_p_OpenBabel__OBMolRingIter swig_types[44]
#define SWIGTYPE_p_OpenBabel__OBMolTorsionIter swig_types[45]
#define SWIGTYPE_p_OpenBabel__OBPairData swig_types[46]
#define SWIGTYPE_p_OpenBabel__OBPairTemplateTdouble_t swig_types[47]
#define SWIGTYPE_p_OpenBabel__OBPairTemplateTint_t swig_types[48]
#define SWIGTYPE_p_OpenBabel__OBRTree swig_types[49]
#define SWIGTYPE_p_OpenBabel__OBRandom swig_types[50]
#define SWIGTYPE_p_OpenBabel__OBResidue swig_types[51]
#define SWIGTYPE_p_OpenBabel__OBResidueAtomIter swig_types[52]
#define SWIGTYPE_p_OpenBabel__OBResidueData swig_types[53]
#define SWIGTYPE_p_OpenBabel__OBResidueIter swig_types[54]
#define SWIGTYPE_p_OpenBabel__OBRing swig_types[55]
#define SWIGTYPE_p_OpenBabel__OBRingData swig_types[56]
#define SWIGTYPE_p_OpenBabel__OBRingSearch swig_types[57]
#define SWIGTYPE_p_OpenBabel__OBSSMatch swig_types[58]
#define SWIGTYPE_p_OpenBabel__OBSerialNums swig_types[59]
#define SWIGTYPE_p_OpenBabel__OBSetData swig_types[60]
#define SWIGTYPE_p_OpenBabel__OBSmartsPattern swig_types[61]
#define SWIGTYPE_p_OpenBabel__OBSqrtTbl swig_types[62]
#define SWIGTYPE_p_OpenBabel__OBStopwatch swig_types[63]
#define SWIGTYPE_p_OpenBabel__OBSymmetryData swig_types[64]
#define SWIGTYPE_p_OpenBabel__OBTorsion swig_types[65]
#define SWIGTYPE_p_OpenBabel__OBTorsionData swig_types[66]
#define SWIGTYPE_p_OpenBabel__OBTypeTable swig_types[67]
#define SWIGTYPE_p_OpenBabel__OBUnitCell swig_types[68]
#define SWIGTYPE_p_OpenBabel__OBVibrationData swig_types[69]
#define SWIGTYPE_p_OpenBabel__OBVirtualBond swig_types[70]
#define SWIGTYPE_p_OpenBabel__Pattern swig_types[71]
#define SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t swig_types[72]
#define SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t swig_types[73]
#define SWIGTYPE_p_OpenBabel__Template swig_types[74]
#define SWIGTYPE_p_OpenBabel__matrix3x3 swig_types[75]
#define SWIGTYPE_p_OpenBabel__obLogBuf swig_types[76]
#define SWIGTYPE_p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t swig_types[77]
#define SWIGTYPE_p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t swig_types[78]
#define SWIGTYPE_p_OpenBabel__vector3 swig_types[79]
#define SWIGTYPE_p_a_3__double swig_types[80]
#define SWIGTYPE_p_a_4__char swig_types[81]
#define SWIGTYPE_p_char swig_types[82]
#define SWIGTYPE_p_double swig_types[83]
#define SWIGTYPE_p_int swig_types[84]
#define SWIGTYPE_p_p_OpenBabel__OBAngleData swig_types[85]
#define SWIGTYPE_p_p_OpenBabel__OBChiralData swig_types[86]
#define SWIGTYPE_p_p_OpenBabel__OBCommentData swig_types[87]
#define SWIGTYPE_p_p_OpenBabel__OBConformerData swig_types[88]
#define SWIGTYPE_p_p_OpenBabel__OBExternalBondData swig_types[89]
#define SWIGTYPE_p_p_OpenBabel__OBFormat swig_types[90]
#define SWIGTYPE_p_p_OpenBabel__OBGenericData swig_types[91]
#define SWIGTYPE_p_p_OpenBabel__OBPairData swig_types[92]
#define SWIGTYPE_p_p_OpenBabel__OBRingData swig_types[93]
#define SWIGTYPE_p_p_OpenBabel__OBSerialNums swig_types[94]
#define SWIGTYPE_p_p_OpenBabel__OBSetData swig_types[95]
#define SWIGTYPE_p_p_OpenBabel__OBSymmetryData swig_types[96]
#define SWIGTYPE_p_p_OpenBabel__OBTorsionData swig_types[97]
#define SWIGTYPE_p_p_OpenBabel__OBUnitCell swig_types[98]
#define SWIGTYPE_p_p_OpenBabel__OBVibrationData swig_types[99]
#define SWIGTYPE_p_p_OpenBabel__OBVirtualBond swig_types[100]
#define SWIGTYPE_p_p_double swig_types[101]
#define SWIGTYPE_p_p_int swig_types[102]
#define SWIGTYPE_p_std__dequeTint_t swig_types[103]
#define SWIGTYPE_p_std__ifstream swig_types[104]
#define SWIGTYPE_p_std__istream swig_types[105]
#define SWIGTYPE_p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t swig_types[106]
#define SWIGTYPE_p_std__mapTint_OpenBabel__OBAtom_p_t swig_types[107]
#define SWIGTYPE_p_std__mapTstd__string_std__string_t swig_types[108]
#define SWIGTYPE_p_std__multimapTdouble_unsigned_int_t swig_types[109]
#define SWIGTYPE_p_std__ostream swig_types[110]
#define SWIGTYPE_p_std__out_of_range swig_types[111]
#define SWIGTYPE_p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t swig_types[112]
#define SWIGTYPE_p_std__streampos swig_types[113]
#define SWIGTYPE_p_std__string swig_types[114]
#define SWIGTYPE_p_std__type_info swig_types[115]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t swig_types[116]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator swig_types[117]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t swig_types[118]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator swig_types[119]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t swig_types[120]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBExternalBond_t swig_types[121]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t swig_types[122]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator swig_types[123]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t swig_types[124]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator swig_types[125]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t swig_types[126]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator swig_types[127]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t swig_types[128]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t swig_types[129]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator swig_types[130]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t swig_types[131]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBTorsion_t swig_types[132]
#define SWIGTYPE_p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t swig_types[133]
#define SWIGTYPE_p_std__vectorTOpenBabel__vector3_t swig_types[134]
#define SWIGTYPE_p_std__vectorTdouble_p_t swig_types[135]
#define SWIGTYPE_p_std__vectorTdouble_p_t__iterator swig_types[136]
#define SWIGTYPE_p_std__vectorTdouble_t swig_types[137]
#define SWIGTYPE_p_std__vectorTint_t swig_types[138]
#define SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t swig_types[139]
#define SWIGTYPE_p_std__vectorTstd__pairTstd__string_std__string_t_t swig_types[140]
#define SWIGTYPE_p_std__vectorTstd__string_t swig_types[141]
#define SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t swig_types[142]
#define SWIGTYPE_p_std__vectorTstd__vectorTint_t_t swig_types[143]
#define SWIGTYPE_p_std__vectorTstd__vectorTint_t_t__iterator swig_types[144]
#define SWIGTYPE_p_std__vectorTstd__vectorTunsigned_int_t_t swig_types[145]
#define SWIGTYPE_p_std__vectorTunsigned_int_t swig_types[146]
#define SWIGTYPE_p_std__vectorTunsigned_short_t swig_types[147]
#define SWIGTYPE_p_unsigned_int swig_types[148]
static swig_type_info *swig_types[150];
static swig_module_info swig_module = {swig_types, 149, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_openbabel
#define SWIG_name    "Openbabel"

static VALUE mOpenbabel;

#define SWIGVERSION 0x010331 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


// used to set import/export for Cygwin DLLs
#ifdef WIN32
#define USING_OBDLL
#endif

#include <math.h>

#include <openbabel/obutil.h>
#include <openbabel/rand.h>
#include <openbabel/math/vector3.h>
#include <openbabel/math/matrix3x3.h>
#include <openbabel/generic.h>

#include <openbabel/base.h>
#include <openbabel/mol.h>
#include <openbabel/atom.h>
#include <openbabel/bond.h>
#include <openbabel/residue.h>
#include <openbabel/internalcoord.h>

#include <openbabel/ring.h>
#include <openbabel/obconversion.h>
#include <openbabel/oberror.h>
#include <openbabel/pluginiter.h>
#include <openbabel/fingerprint.h>

#include <openbabel/forcefield.h>

#include <openbabel/data.h>
#include <openbabel/parsmart.h>


#include <stdexcept>


#include <string>

#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))

bool SWIG_BOOL_P(VALUE) {
    // dummy test, RTEST should take care of everything
    return true;
}
bool SWIG_RB2BOOL(VALUE x) {
    return RTEST(x);
}
VALUE SWIG_BOOL2RB(bool b) {
    return b ? Qtrue : Qfalse;
}
double SWIG_NUM2DBL(VALUE x) {
    return (FIXNUM_P(x) ? FIX2INT(x) : NUM2DBL(x));
}
bool SWIG_STRING_P(VALUE x) {
    return TYPE(x) == T_STRING;
}
std::string SWIG_RB2STR(VALUE x) {
    return std::string(RSTRING_PTR(x), RSTRING_LEN(x));
}
VALUE SWIG_STR2RB(const std::string& s) {
    return rb_str_new(s.data(), s.size());
}


#include <map>
#include <algorithm>
#include <stdexcept>


#include <vector>
#include <algorithm>
#include <stdexcept>


#include <string>


#include <limits.h>
#ifndef LLONG_MIN
# define LLONG_MIN	LONG_LONG_MIN
#endif
#ifndef LLONG_MAX
# define LLONG_MAX	LONG_LONG_MAX
#endif
#ifndef ULLONG_MAX
# define ULLONG_MAX	ULONG_LONG_MAX
#endif


SWIGINTERN VALUE
SWIG_ruby_failed(void)
{
  return Qnil;
} 


/*@SWIG:%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  unsigned long *res = (unsigned long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    unsigned long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (VALUE obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


/*@SWIG:%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long *res = (long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_long (VALUE obj, long* val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (VALUE obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


  #define SWIG_From_long   LONG2NUM 


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return ULONG2NUM(value); 
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


SWIGINTERNINLINE VALUE
SWIG_From_bool  (bool value)
{
  return value ? Qtrue : Qfalse;
}

SWIGINTERN int std_vector_Sl_int_Sg__pop(std::vector<int > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                int x = self->back();
                self->pop_back();
                return x;
            }

SWIGINTERNINLINE VALUE
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}

SWIGINTERN int std_vector_Sl_int_Sg____getitem__(std::vector<int > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_int_Sg____setitem__(std::vector<int > *self,int i,int x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_int_Sg__each(std::vector<int > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(INT2NUM((*self)[i]));
            }
SWIGINTERN unsigned int std_vector_Sl_unsigned_SS_int_Sg__pop(std::vector<unsigned int > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                unsigned int x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN unsigned int std_vector_Sl_unsigned_SS_int_Sg____getitem__(std::vector<unsigned int > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_unsigned_SS_int_Sg____setitem__(std::vector<unsigned int > *self,int i,unsigned int x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_unsigned_SS_int_Sg__each(std::vector<unsigned int > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(INT2NUM((*self)[i]));
            }
SWIGINTERN std::vector<int > std_vector_Sl_std_vector_Sl_int_Sg__Sg__pop(std::vector<std::vector<int > > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                std::vector<int > x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN std::vector<int > &std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem__(std::vector<std::vector<int > > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg____setitem__(std::vector<std::vector<int > > *self,int i,std::vector<int > const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__each(std::vector<std::vector<int > > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    std::vector<int >* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_std__vectorTint_t, 0));
                }
            }

/*@SWIG:%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2DBL(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  double *res = (double *)(args[1]);
  *res = (type == T_FLOAT ? NUM2DBL(obj) : (type == T_FIXNUM ? (double) FIX2INT(obj) : rb_big2dbl(obj)));
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_double (VALUE obj, double *val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FLOAT) || (type == T_FIXNUM) || (type == T_BIGNUM)) {
    double v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2DBL), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}

SWIGINTERN double std_vector_Sl_double_Sg__pop(std::vector<double > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                double x = self->back();
                self->pop_back();
                return x;
            }

  #define SWIG_From_double   rb_float_new 

SWIGINTERN double std_vector_Sl_double_Sg____getitem__(std::vector<double > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_double_Sg____setitem__(std::vector<double > *self,int i,double x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_double_Sg__each(std::vector<double > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(rb_float_new((*self)[i]));
            }
SWIGINTERN OpenBabel::vector3 std_vector_Sl_OpenBabel_vector3_Sg__pop(std::vector<OpenBabel::vector3 > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::vector3 x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::vector3 &std_vector_Sl_OpenBabel_vector3_Sg____getitem__(std::vector<OpenBabel::vector3 > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_vector3_Sg____setitem__(std::vector<OpenBabel::vector3 > *self,int i,OpenBabel::vector3 const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_vector3_Sg__each(std::vector<OpenBabel::vector3 > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::vector3* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__vector3, 0));
                }
            }
SWIGINTERN OpenBabel::OBMol std_vector_Sl_OpenBabel_OBMol_Sg__pop(std::vector<OpenBabel::OBMol > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBMol x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBMol &std_vector_Sl_OpenBabel_OBMol_Sg____getitem__(std::vector<OpenBabel::OBMol > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBMol_Sg____setitem__(std::vector<OpenBabel::OBMol > *self,int i,OpenBabel::OBMol const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBMol_Sg__each(std::vector<OpenBabel::OBMol > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBMol* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBMol, 0));
                }
            }
SWIGINTERN OpenBabel::OBBond std_vector_Sl_OpenBabel_OBBond_Sg__pop(std::vector<OpenBabel::OBBond > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBBond x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBBond &std_vector_Sl_OpenBabel_OBBond_Sg____getitem__(std::vector<OpenBabel::OBBond > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBBond_Sg____setitem__(std::vector<OpenBabel::OBBond > *self,int i,OpenBabel::OBBond const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBBond_Sg__each(std::vector<OpenBabel::OBBond > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBBond* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBBond, 0));
                }
            }
SWIGINTERN OpenBabel::OBResidue std_vector_Sl_OpenBabel_OBResidue_Sg__pop(std::vector<OpenBabel::OBResidue > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBResidue x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBResidue &std_vector_Sl_OpenBabel_OBResidue_Sg____getitem__(std::vector<OpenBabel::OBResidue > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBResidue_Sg____setitem__(std::vector<OpenBabel::OBResidue > *self,int i,OpenBabel::OBResidue const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBResidue_Sg__each(std::vector<OpenBabel::OBResidue > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBResidue* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBResidue, 0));
                }
            }
SWIGINTERN OpenBabel::OBRing std_vector_Sl_OpenBabel_OBRing_Sg__pop(std::vector<OpenBabel::OBRing > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBRing x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBRing &std_vector_Sl_OpenBabel_OBRing_Sg____getitem__(std::vector<OpenBabel::OBRing > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBRing_Sg____setitem__(std::vector<OpenBabel::OBRing > *self,int i,OpenBabel::OBRing const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBRing_Sg__each(std::vector<OpenBabel::OBRing > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBRing* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBRing, 0));
                }
            }
SWIGINTERN OpenBabel::OBGenericData *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__pop(std::vector<OpenBabel::OBGenericData * > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBGenericData* x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBGenericData *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____getitem__(std::vector<OpenBabel::OBGenericData * > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____setitem__(std::vector<OpenBabel::OBGenericData * > *self,int i,OpenBabel::OBGenericData *x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__each(std::vector<OpenBabel::OBGenericData * > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBGenericData* x = (*self)[i];
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBGenericData, 0));
                }
            }

SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(VALUE obj, char** cptr, size_t* psize, int *alloc)
{
  if (TYPE(obj) == T_STRING) {
    


    char *cstr = STR2CSTR(obj);
    
    size_t size = RSTRING_LEN(obj) + 1;
    if (cptr)  {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy((new char[size]), cstr, sizeof(char)*(size)));
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      }
    }
    if (psize) *psize = size;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *)vptr;
	if (psize) *psize = vptr ? (strlen((char*)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }  
  return SWIG_TypeError;
}





SWIGINTERN int
SWIG_AsPtr_std_string (VALUE obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > LONG_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : Qnil;
    } else {
      return rb_str_new(carray, static_cast< long >(size));
    }
  } else {
    return Qnil;
  }
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERNINLINE VALUE
SWIG_From_std_string  (const std::string& s)
{
  if (s.size()) {
    return SWIG_FromCharPtrAndSize(s.data(), s.size());
  } else {
    return SWIG_FromCharPtrAndSize(s.c_str(), 0);
  }
}


SWIGINTERN int
SWIG_AsVal_bool (VALUE obj, bool *val)
{
  if (obj == Qtrue) {
    if (val) *val = true;
    return SWIG_OK;
  } else if (obj == Qfalse) {
    if (val) *val = false;
    return SWIG_OK;
  } else {
    int res = 0;
    if (SWIG_AsVal_int (obj, &res) == SWIG_OK) {    
      if (val) *val = res ? true : false;
      return SWIG_OK;
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERNINLINE VALUE
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
}


SWIGINTERN int
SWIG_AsCharArray(VALUE obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (VALUE obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


SWIGINTERN int
SWIG_AsVal_short (VALUE obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< short >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_short  (unsigned short value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_short (VALUE obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > USHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned short >(v);
    }
  }  
  return res;
}

swig_class cVectorInt;

SWIGINTERN VALUE
_wrap_new_vectorInt__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<int > *)new std::vector<int >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<int > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(int)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<int > *)new std::vector<int >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorInt__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  int *arg2 = 0 ;
  std::vector<int > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  int temp2 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(int)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "std::vector<(int)>" "', argument " "2"" of type '" "int""'");
  } 
  temp2 = static_cast< int >(val2);
  arg2 = &temp2;
  result = (std::vector<int > *)new std::vector<int >(arg1,(int const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorInt_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorInt_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTint_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorInt__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = 0 ;
  std::vector<int > *result = 0 ;
  std::vector<int > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp1[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  result = (std::vector<int > *)new std::vector<int >((std::vector<int > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorInt(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorInt__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorInt__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (FIXNUM_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<int >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTint_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorInt__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_vectorInt__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorInt'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  unsigned int result;
  std::vector<int > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (FIXNUM_P(o))
        temp1[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  result = (unsigned int)((std::vector<int > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  bool result;
  std::vector<int > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (FIXNUM_P(o))
        temp1[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  result = (bool)((std::vector<int > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_push(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "push_back" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->push_back(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  try {
    result = (int)std_vector_Sl_int_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    result = (int)std_vector_Sl_int_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "__setitem__" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  try {
    std_vector_Sl_int_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_each(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  std_vector_Sl_int_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_int_Sg_(std::vector<int > *arg1) {
    delete arg1;
}

swig_class cVectorUnsignedInt;

SWIGINTERN VALUE
_wrap_new_vectorUnsignedInt__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<unsigned int > *)new std::vector<unsigned int >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorUnsignedInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<unsigned int > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(unsigned int)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<unsigned int > *)new std::vector<unsigned int >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorUnsignedInt__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int *arg2 = 0 ;
  std::vector<unsigned int > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(unsigned int)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "std::vector<(unsigned int)>" "', argument " "2"" of type '" "unsigned int""'");
  } 
  temp2 = static_cast< unsigned int >(val2);
  arg2 = &temp2;
  result = (std::vector<unsigned int > *)new std::vector<unsigned int >(arg1,(unsigned int const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorUnsignedInt_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorUnsignedInt_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTunsigned_int_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorUnsignedInt__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = 0 ;
  std::vector<unsigned int > *result = 0 ;
  std::vector<unsigned int > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (std::vector<unsigned int > *)new std::vector<unsigned int >((std::vector<unsigned int > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorUnsignedInt(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorUnsignedInt__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorUnsignedInt__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (FIXNUM_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<unsigned int >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorUnsignedInt__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_vectorUnsignedInt__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorUnsignedInt'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  unsigned int result;
  std::vector<unsigned int > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (unsigned int)((std::vector<unsigned int > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  bool result;
  std::vector<unsigned int > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (bool)((std::vector<unsigned int > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_push(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "push_back" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->push_back(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  try {
    result = (unsigned int)std_vector_Sl_unsigned_SS_int_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  int arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    result = (unsigned int)std_vector_Sl_unsigned_SS_int_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "__setitem__" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  try {
    std_vector_Sl_unsigned_SS_int_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_each(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  std_vector_Sl_unsigned_SS_int_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_unsigned_SS_int_Sg_(std::vector<unsigned int > *arg1) {
    delete arg1;
}

swig_class cVvInt;

SWIGINTERN VALUE
_wrap_new_vvInt__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<std::vector<int > > *)new std::vector<std::vector<int > >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vvInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<std::vector<int > > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(std::vector<(int)>)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<std::vector<int > > *)new std::vector<std::vector<int > >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vvInt__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<int > *arg2 = 0 ;
  std::vector<std::vector<int > > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  std::vector<int > temp2 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(std::vector<(int)>)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp2 = std::vector<int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (FIXNUM_P(o))
        temp2[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  result = (std::vector<std::vector<int > > *)new std::vector<std::vector<int > >(arg1,(std::vector<int > const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vvInt_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vvInt_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vvInt__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = 0 ;
  std::vector<std::vector<int > > *result = 0 ;
  std::vector<std::vector<int > > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        std::vector<int >* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_std__vectorTint_t, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 1);
    }
  }
  result = (std::vector<std::vector<int > > *)new std::vector<std::vector<int > >((std::vector<std::vector<int > > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vvInt(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vvInt__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vvInt__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          std::vector<int >* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_std__vectorTint_t,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<std::vector<int > >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTstd__vectorTint_t_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vvInt__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        /* native sequence? */
        if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
          unsigned int size = RARRAY_LEN(argv[1]);
          if (size == 0) {
            /* an empty sequence can be of any type */
            _v = 1;
          } else {
            /* check the first element only */
            VALUE o = RARRAY_PTR(argv[1])[0];
            if (FIXNUM_P(o))
            _v = 1;
            else
            _v = 0;
          }
        } else {
          /* wrapped vector? */
          std::vector<int >* v;
          if (SWIG_ConvertPtr(argv[1],(void **) &v, 
              SWIGTYPE_p_std__vectorTint_t,0) != -1)
          _v = 1;
          else
          _v = 0;
        }
      }
      if (_v) {
        return _wrap_new_vvInt__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vvInt'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  unsigned int result;
  std::vector<std::vector<int > > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        std::vector<int >* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_std__vectorTint_t, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 1);
    }
  }
  result = (unsigned int)((std::vector<std::vector<int > > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  bool result;
  std::vector<std::vector<int > > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        std::vector<int >* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_std__vectorTint_t, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 1);
    }
  }
  result = (bool)((std::vector<std::vector<int > > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_push(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  std::vector<int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  (arg1)->push_back((std::vector<int > const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  std::vector<int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  try {
    result = std_vector_Sl_std_vector_Sl_int_Sg__Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  int arg2 ;
  std::vector<int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      std::vector<int > &_result_ref = std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem__(arg1,arg2);
      result = (std::vector<int > *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  int arg2 ;
  std::vector<int > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::vector<int > temp3 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp3 = std::vector<int >(size);
      arg3 = &temp3;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (FIXNUM_P(o))
        temp3[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  try {
    std_vector_Sl_std_vector_Sl_int_Sg__Sg____setitem__(arg1,arg2,(std::vector<int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_each(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  std_vector_Sl_std_vector_Sl_int_Sg__Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_std_vector_Sl_int_Sg__Sg_(std::vector<std::vector<int > > *arg1) {
    delete arg1;
}

swig_class cVectorDouble;

SWIGINTERN VALUE
_wrap_new_vectorDouble__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<double > *)new std::vector<double >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorDouble__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<double > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(double)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<double > *)new std::vector<double >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorDouble__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  double *arg2 = 0 ;
  std::vector<double > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  double temp2 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(double)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "std::vector<(double)>" "', argument " "2"" of type '" "double""'");
  } 
  temp2 = static_cast< double >(val2);
  arg2 = &temp2;
  result = (std::vector<double > *)new std::vector<double >(arg1,(double const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorDouble_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorDouble_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTdouble_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorDouble__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = 0 ;
  std::vector<double > *result = 0 ;
  std::vector<double > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<double >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (SWIG_FLOAT_P(o))
        temp1[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  result = (std::vector<double > *)new std::vector<double >((std::vector<double > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorDouble(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorDouble__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorDouble__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (SWIG_FLOAT_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<double >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTdouble_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorDouble__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_vectorDouble__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorDouble'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  unsigned int result;
  std::vector<double > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<double >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (SWIG_FLOAT_P(o))
        temp1[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  result = (unsigned int)((std::vector<double > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  bool result;
  std::vector<double > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<double >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (SWIG_FLOAT_P(o))
        temp1[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  result = (bool)((std::vector<double > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_push(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "push_back" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->push_back(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  try {
    result = (double)std_vector_Sl_double_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    result = (double)std_vector_Sl_double_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "__setitem__" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  try {
    std_vector_Sl_double_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_each(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  std_vector_Sl_double_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_double_Sg_(std::vector<double > *arg1) {
    delete arg1;
}

swig_class cVVector3;

SWIGINTERN VALUE
_wrap_new_vVector3__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::vector3 > *)new std::vector<OpenBabel::vector3 >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vVector3__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::vector3 > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::vector3)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::vector3 > *)new std::vector<OpenBabel::vector3 >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vVector3__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::vector3 *arg2 = 0 ;
  std::vector<OpenBabel::vector3 > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::vector3)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::vector3)>" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::vector3)>" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (std::vector<OpenBabel::vector3 > *)new std::vector<OpenBabel::vector3 >(arg1,(OpenBabel::vector3 const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vVector3_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vVector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__vector3_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vVector3__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = 0 ;
  std::vector<OpenBabel::vector3 > *result = 0 ;
  std::vector<OpenBabel::vector3 > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::vector3* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__vector3, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 1);
    }
  }
  result = (std::vector<OpenBabel::vector3 > *)new std::vector<OpenBabel::vector3 >((std::vector<OpenBabel::vector3 > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vVector3(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vVector3__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vVector3__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::vector3* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__vector3,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::vector3 >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__vector3_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vVector3__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vVector3__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vVector3'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::vector3 > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::vector3* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__vector3, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::vector3 > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  bool result;
  std::vector<OpenBabel::vector3 > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::vector3* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__vector3, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::vector3 > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_push(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (arg1)->push_back((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_vector3_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  int arg2 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::vector3 &_result_ref = std_vector_Sl_OpenBabel_vector3_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::vector3 *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  int arg2 ;
  OpenBabel::vector3 *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  try {
    std_vector_Sl_OpenBabel_vector3_Sg____setitem__(arg1,arg2,(OpenBabel::vector3 const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  std_vector_Sl_OpenBabel_vector3_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_vector3_Sg_(std::vector<OpenBabel::vector3 > *arg1) {
    delete arg1;
}

swig_class cVectorMol;

SWIGINTERN VALUE
_wrap_new_vectorMol__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBMol > *)new std::vector<OpenBabel::OBMol >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorMol__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBMol > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBMol)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBMol > *)new std::vector<OpenBabel::OBMol >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorMol__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBMol *arg2 = 0 ;
  std::vector<OpenBabel::OBMol > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBMol)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::OBMol)>" "', argument " "2"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::OBMol)>" "', argument " "2"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (std::vector<OpenBabel::OBMol > *)new std::vector<OpenBabel::OBMol >(arg1,(OpenBabel::OBMol const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorMol_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorMol_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorMol__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = 0 ;
  std::vector<OpenBabel::OBMol > *result = 0 ;
  std::vector<OpenBabel::OBMol > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBMol* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBMol, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBMol > *)new std::vector<OpenBabel::OBMol >((std::vector<OpenBabel::OBMol > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorMol(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorMol__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorMol__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBMol* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBMol,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBMol >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorMol__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorMol__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorMol'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBMol > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBMol* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBMol, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBMol > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBMol > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBMol* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBMol, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBMol > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_push(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (arg1)->push_back((OpenBabel::OBMol const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  OpenBabel::OBMol result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_OBMol_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMol(static_cast< const OpenBabel::OBMol& >(result))), SWIGTYPE_p_OpenBabel__OBMol, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  int arg2 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::OBMol &_result_ref = std_vector_Sl_OpenBabel_OBMol_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::OBMol *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  int arg2 ;
  OpenBabel::OBMol *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBMol * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBMol_Sg____setitem__(arg1,arg2,(OpenBabel::OBMol const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  std_vector_Sl_OpenBabel_OBMol_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBMol_Sg_(std::vector<OpenBabel::OBMol > *arg1) {
    delete arg1;
}

swig_class cVectorBond;

SWIGINTERN VALUE
_wrap_new_vectorBond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBBond > *)new std::vector<OpenBabel::OBBond >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorBond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBBond > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBBond)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBBond > *)new std::vector<OpenBabel::OBBond >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorBond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBBond *arg2 = 0 ;
  std::vector<OpenBabel::OBBond > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBBond)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBBond,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::OBBond)>" "', argument " "2"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::OBBond)>" "', argument " "2"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (std::vector<OpenBabel::OBBond > *)new std::vector<OpenBabel::OBBond >(arg1,(OpenBabel::OBBond const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorBond_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorBond__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = 0 ;
  std::vector<OpenBabel::OBBond > *result = 0 ;
  std::vector<OpenBabel::OBBond > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBBond* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBBond, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBBond > *)new std::vector<OpenBabel::OBBond >((std::vector<OpenBabel::OBBond > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorBond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorBond__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorBond__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBBond* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBBond,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBBond >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorBond__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorBond__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorBond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBBond > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBBond* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBBond, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBBond > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBBond > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBBond* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBBond, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBBond > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_push(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  OpenBabel::OBBond *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBond,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (arg1)->push_back((OpenBabel::OBBond const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  OpenBabel::OBBond result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_OBBond_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBond(static_cast< const OpenBabel::OBBond& >(result))), SWIGTYPE_p_OpenBabel__OBBond, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  int arg2 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::OBBond &_result_ref = std_vector_Sl_OpenBabel_OBBond_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::OBBond *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  int arg2 ;
  OpenBabel::OBBond *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBond,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBBond_Sg____setitem__(arg1,arg2,(OpenBabel::OBBond const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  std_vector_Sl_OpenBabel_OBBond_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBBond_Sg_(std::vector<OpenBabel::OBBond > *arg1) {
    delete arg1;
}

swig_class cVectorResidue;

SWIGINTERN VALUE
_wrap_new_vectorResidue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBResidue > *)new std::vector<OpenBabel::OBResidue >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorResidue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBResidue > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBResidue)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBResidue > *)new std::vector<OpenBabel::OBResidue >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorResidue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBResidue *arg2 = 0 ;
  std::vector<OpenBabel::OBResidue > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBResidue)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::OBResidue)>" "', argument " "2"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::OBResidue)>" "', argument " "2"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  result = (std::vector<OpenBabel::OBResidue > *)new std::vector<OpenBabel::OBResidue >(arg1,(OpenBabel::OBResidue const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorResidue_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorResidue_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorResidue__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = 0 ;
  std::vector<OpenBabel::OBResidue > *result = 0 ;
  std::vector<OpenBabel::OBResidue > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBResidue* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBResidue, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBResidue > *)new std::vector<OpenBabel::OBResidue >((std::vector<OpenBabel::OBResidue > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorResidue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorResidue__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorResidue__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBResidue* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBResidue,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBResidue >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorResidue__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorResidue__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorResidue'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBResidue > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBResidue* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBResidue, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBResidue > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBResidue > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBResidue* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBResidue, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBResidue > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_push(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  OpenBabel::OBResidue *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (arg1)->push_back((OpenBabel::OBResidue const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  OpenBabel::OBResidue result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_OBResidue_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidue(static_cast< const OpenBabel::OBResidue& >(result))), SWIGTYPE_p_OpenBabel__OBResidue, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  int arg2 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::OBResidue &_result_ref = std_vector_Sl_OpenBabel_OBResidue_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::OBResidue *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  int arg2 ;
  OpenBabel::OBResidue *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBResidue * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBResidue_Sg____setitem__(arg1,arg2,(OpenBabel::OBResidue const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  std_vector_Sl_OpenBabel_OBResidue_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBResidue_Sg_(std::vector<OpenBabel::OBResidue > *arg1) {
    delete arg1;
}

swig_class cVectorRing;

SWIGINTERN VALUE
_wrap_new_vectorRing__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBRing > *)new std::vector<OpenBabel::OBRing >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorRing__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBRing > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBRing)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBRing > *)new std::vector<OpenBabel::OBRing >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorRing__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBRing *arg2 = 0 ;
  std::vector<OpenBabel::OBRing > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBRing)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBRing,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::OBRing)>" "', argument " "2"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::OBRing)>" "', argument " "2"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2);
  result = (std::vector<OpenBabel::OBRing > *)new std::vector<OpenBabel::OBRing >(arg1,(OpenBabel::OBRing const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorRing_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorRing_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorRing__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = 0 ;
  std::vector<OpenBabel::OBRing > *result = 0 ;
  std::vector<OpenBabel::OBRing > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBRing* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBRing, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBRing > *)new std::vector<OpenBabel::OBRing >((std::vector<OpenBabel::OBRing > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorRing(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorRing__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorRing__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBRing* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBRing,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBRing >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorRing__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBRing, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorRing__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorRing'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBRing > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBRing* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBRing, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBRing > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBRing > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBRing* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBRing, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBRing > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_push(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  OpenBabel::OBRing *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBRing,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2);
  (arg1)->push_back((OpenBabel::OBRing const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  OpenBabel::OBRing result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_OBRing_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::OBRing(static_cast< const OpenBabel::OBRing& >(result))), SWIGTYPE_p_OpenBabel__OBRing, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  int arg2 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::OBRing &_result_ref = std_vector_Sl_OpenBabel_OBRing_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::OBRing *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  int arg2 ;
  OpenBabel::OBRing *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBRing,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBRing * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBRing_Sg____setitem__(arg1,arg2,(OpenBabel::OBRing const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  std_vector_Sl_OpenBabel_OBRing_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBRing_Sg_(std::vector<OpenBabel::OBRing > *arg1) {
    delete arg1;
}

swig_class cVectorData;

SWIGINTERN VALUE
_wrap_new_vectorData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBGenericData * > *)new std::vector<OpenBabel::OBGenericData * >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(p.OpenBabel::OBGenericData)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBGenericData * > *)new std::vector<OpenBabel::OBGenericData * >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBGenericData **arg2 = 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(p.OpenBabel::OBGenericData)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_p_OpenBabel__OBGenericData,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(p.OpenBabel::OBGenericData)>" "', argument " "2"" of type '" "OpenBabel::OBGenericData *&""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(p.OpenBabel::OBGenericData)>" "', argument " "2"" of type '" "OpenBabel::OBGenericData *&""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData ** >(argp2);
  result = (std::vector<OpenBabel::OBGenericData * > *)new std::vector<OpenBabel::OBGenericData * >(arg1,*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  std::vector<OpenBabel::OBGenericData * > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<OpenBabel::OBGenericData* >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBGenericData* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBGenericData, 1);
        temp1[i] = x;
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBGenericData * > *)new std::vector<OpenBabel::OBGenericData * >((std::vector<OpenBabel::OBGenericData * > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorData__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBGenericData* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBGenericData,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBGenericData* >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBGenericData * > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<OpenBabel::OBGenericData* >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBGenericData* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBGenericData, 1);
        temp1[i] = x;
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBGenericData * > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBGenericData * > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<OpenBabel::OBGenericData* >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBGenericData* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBGenericData, 1);
        temp1[i] = x;
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBGenericData * > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_push(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->push_back(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  try {
    result = (OpenBabel::OBGenericData *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    result = (OpenBabel::OBGenericData *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  int arg2 ;
  OpenBabel::OBGenericData *arg3 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBGenericData * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg_(std::vector<OpenBabel::OBGenericData * > *arg1) {
    delete arg1;
}

swig_class cOBGlobalDataBase;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBGlobalDataBase_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBGlobalDataBase_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBGlobalDataBase);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBGlobalDataBase(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBGlobalDataBase *)new OpenBabel::OBGlobalDataBase();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBGlobalDataBase(OpenBabel::OBGlobalDataBase *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBGlobalDataBase_Init(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Init" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  (arg1)->Init();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGlobalDataBase_GetSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGlobalDataBase_SetReadDirectory(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetReadDirectory" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetReadDirectory" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetReadDirectory(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGlobalDataBase_SetEnvironmentVariable(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnvironmentVariable" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetEnvironmentVariable" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetEnvironmentVariable(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGlobalDataBase_ParseLine(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


swig_class cOBElement;

SWIGINTERN VALUE
_wrap_new_OBElement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBElement *)new OpenBabel::OBElement();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBElement_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBElement_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBElement);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBElement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  double arg4 ;
  int arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  double arg11 ;
  double arg12 ;
  std::string arg13 ;
  OpenBabel::OBElement *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  double val10 ;
  int ecode10 = 0 ;
  double val11 ;
  int ecode11 = 0 ;
  double val12 ;
  int ecode12 = 0 ;
  
  if ((argc < 13) || (argc > 13)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 13)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBElement" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBElement" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBElement" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBElement" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "OpenBabel::OBElement" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_double(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "OpenBabel::OBElement" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  ecode7 = SWIG_AsVal_double(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "OpenBabel::OBElement" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = static_cast< double >(val7);
  ecode8 = SWIG_AsVal_double(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "OpenBabel::OBElement" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = static_cast< double >(val8);
  ecode9 = SWIG_AsVal_double(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "OpenBabel::OBElement" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = static_cast< double >(val9);
  ecode10 = SWIG_AsVal_double(argv[9], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "OpenBabel::OBElement" "', argument " "10"" of type '" "double""'");
  } 
  arg10 = static_cast< double >(val10);
  ecode11 = SWIG_AsVal_double(argv[10], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "OpenBabel::OBElement" "', argument " "11"" of type '" "double""'");
  } 
  arg11 = static_cast< double >(val11);
  ecode12 = SWIG_AsVal_double(argv[11], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "OpenBabel::OBElement" "', argument " "12"" of type '" "double""'");
  } 
  arg12 = static_cast< double >(val12);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[12], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBElement" "', argument " "13"" of type '" "std::string""'"); 
    }
    arg13 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (OpenBabel::OBElement *)new OpenBabel::OBElement(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);DATA_PTR(self) = result;
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBElement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[13];
  int ii;
  
  argc = nargs;
  if (argc > 13) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBElement__SWIG_0(nargs, args, self);
  }
  if (argc == 13) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_double(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_double(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_double(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_double(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      {
                        int res = SWIG_AsVal_double(argv[9], NULL);
                        _v = SWIG_CheckState(res);
                      }
                      if (_v) {
                        {
                          int res = SWIG_AsVal_double(argv[10], NULL);
                          _v = SWIG_CheckState(res);
                        }
                        if (_v) {
                          {
                            int res = SWIG_AsVal_double(argv[11], NULL);
                            _v = SWIG_CheckState(res);
                          }
                          if (_v) {
                            int res = SWIG_AsPtr_std_string(argv[12], (std::string**)(0));
                            _v = SWIG_CheckState(res);
                            if (_v) {
                              return _wrap_new_OBElement__SWIG_1(nargs, args, self);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBElement'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (int)(arg1)->GetAtomicNum();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetSymbol(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSymbol" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (char *)(arg1)->GetSymbol();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetCovalentRad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCovalentRad" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetCovalentRad();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetVdwRad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVdwRad" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetVdwRad();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMass" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetMaxBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMaxBonds" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (int)(arg1)->GetMaxBonds();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetElectroNeg(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetElectroNeg" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetElectroNeg();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetIonization(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIonization" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetIonization();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetElectronAffinity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetElectronAffinity" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetElectronAffinity();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetName(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetName" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (arg1)->GetName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetRed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetRed" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetRed();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetGreen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGreen" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetGreen();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_GetBlue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBlue" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetBlue();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBElement(OpenBabel::OBElement *arg1) {
    delete arg1;
}

swig_class cOBElementTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBElementTable_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBElementTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBElementTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBElementTable(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBElementTable *)new OpenBabel::OBElementTable();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBElementTable(OpenBabel::OBElementTable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBElementTable_ParseLine(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetNumberOfElements(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNumberOfElements" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  result = (unsigned int)(arg1)->GetNumberOfElements();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetAtomicNum__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomicNum" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)(arg1)->GetAtomicNum((char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetAtomicNum__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  char *arg2 = (char *) 0 ;
  int *arg3 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomicNum" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAtomicNum" "', argument " "3"" of type '" "int &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetAtomicNum" "', argument " "3"" of type '" "int &""'"); 
  }
  arg3 = reinterpret_cast< int * >(argp3);
  result = (int)(arg1)->GetAtomicNum((char const *)arg2,*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBElementTable_GetAtomicNum(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBElementTable_GetAtomicNum__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_int, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBElementTable_GetAtomicNum__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBElementTable_GetAtomicNum'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetSymbol(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSymbol" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetSymbol" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (char *)(arg1)->GetSymbol(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetVdwRad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVdwRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetVdwRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetVdwRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetCovalentRad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCovalentRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetCovalentRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetCovalentRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMass" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetMass" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetMass(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_CorrectedBondRad__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectedBondRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CorrectedBondRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CorrectedBondRad" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(arg1)->CorrectedBondRad(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_CorrectedBondRad__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectedBondRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CorrectedBondRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->CorrectedBondRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBElementTable_CorrectedBondRad(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBElementTable_CorrectedBondRad__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBElementTable_CorrectedBondRad__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBElementTable_CorrectedBondRad'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_CorrectedVdwRad__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectedVdwRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CorrectedVdwRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CorrectedVdwRad" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(arg1)->CorrectedVdwRad(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_CorrectedVdwRad__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectedVdwRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CorrectedVdwRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->CorrectedVdwRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBElementTable_CorrectedVdwRad(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBElementTable_CorrectedVdwRad__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBElementTable_CorrectedVdwRad__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBElementTable_CorrectedVdwRad'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetMaxBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMaxBonds" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetMaxBonds" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->GetMaxBonds(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetElectroNeg(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetElectroNeg" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetElectroNeg" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetElectroNeg(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetIonization(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIonization" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetIonization" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetIonization(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetElectronAffinity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetElectronAffinity" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetElectronAffinity" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetElectronAffinity(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetRGB(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  std::vector<double > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetRGB" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetRGB" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->GetRGB(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,rb_float_new(((std::vector<double > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_GetName(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetName" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->GetName(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBIsotopeTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBIsotopeTable_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBIsotopeTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBIsotopeTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBIsotopeTable(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBIsotopeTable *)new OpenBabel::OBIsotopeTable();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBIsotopeTable(OpenBabel::OBIsotopeTable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBIsotopeTable_GetSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBIsotopeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBIsotopeTable_ParseLine(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBIsotopeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBIsotopeTable_GetExactMass__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBIsotopeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetExactMass" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetExactMass" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (double)(arg1)->GetExactMass(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBIsotopeTable_GetExactMass__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ;
  unsigned int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBIsotopeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetExactMass" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (double)(arg1)->GetExactMass(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBIsotopeTable_GetExactMass(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBIsotopeTable_GetExactMass__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBIsotopeTable_GetExactMass__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBIsotopeTable_GetExactMass'");
  return Qnil;
}


swig_class cOBTypeTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBTypeTable_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBTypeTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBTypeTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBTypeTable(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBTypeTable *)new OpenBabel::OBTypeTable();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBTypeTable(OpenBabel::OBTypeTable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBTypeTable_ParseLine(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_GetSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_SetFromType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFromType" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetFromType" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->SetFromType((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_SetToType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetToType" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetToType" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->SetToType((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_Translate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Translate" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)(arg1)->Translate(arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_Translate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Translate" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)(arg1)->Translate(*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_Translate__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  std::string *arg2 = 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (arg1)->Translate((std::string const &)*arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBTypeTable_Translate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTypeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBTypeTable_Translate__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTypeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBTypeTable_Translate__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTypeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBTypeTable_Translate__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBTypeTable_Translate'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_GetFromType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFromType" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  result = (arg1)->GetFromType();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_GetToType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetToType" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  result = (arg1)->GetToType();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBResidueData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBResidueData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBResidueData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidueData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBResidueData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBResidueData *)new OpenBabel::OBResidueData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_ParseLine(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_GetSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_SetResName(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResName" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetResName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->SetResName((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_LookupBO__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  std::string *arg2 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LookupBO" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LookupBO" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupBO" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->LookupBO((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_LookupBO__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LookupBO" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LookupBO" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupBO" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LookupBO" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupBO" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->LookupBO((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueData_LookupBO(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueData_LookupBO__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBResidueData_LookupBO__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueData_LookupBO'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_LookupType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int *arg4 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LookupType" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LookupType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LookupType" "', argument " "3"" of type '" "std::string &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupType" "', argument " "3"" of type '" "std::string &""'"); 
  }
  arg3 = reinterpret_cast< std::string * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "LookupType" "', argument " "4"" of type '" "int &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupType" "', argument " "4"" of type '" "int &""'"); 
  }
  arg4 = reinterpret_cast< int * >(argp4);
  result = (bool)(arg1)->LookupType((std::string const &)*arg2,*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_AssignBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBitVec *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AssignBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AssignBonds" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AssignBonds" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AssignBonds" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AssignBonds" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3);
  result = (bool)(arg1)->AssignBonds(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBResidueData(OpenBabel::OBResidueData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OpenDatafile__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::ifstream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ifstream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OpenDatafile" "', argument " "1"" of type '" "std::ifstream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "1"" of type '" "std::ifstream &""'"); 
  }
  arg1 = reinterpret_cast< std::ifstream * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OpenDatafile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OpenDatafile" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = OpenBabel::OpenDatafile(*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OpenDatafile__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::ifstream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ifstream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OpenDatafile" "', argument " "1"" of type '" "std::ifstream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "1"" of type '" "std::ifstream &""'"); 
  }
  arg1 = reinterpret_cast< std::ifstream * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OpenDatafile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = OpenBabel::OpenDatafile(*arg1,(std::string const &)*arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OpenDatafile(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ifstream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OpenDatafile__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ifstream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OpenDatafile__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OpenDatafile'");
  return Qnil;
}


swig_class cDoubleType;

SWIGINTERN VALUE
_wrap_DoubleType_hi_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "hi" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "hi" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->hi = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleType_hi_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "hi" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  result = (unsigned int) ((arg1)->hi);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleType_lo_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lo" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "lo" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->lo = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleType_lo_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lo" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  result = (unsigned int) ((arg1)->lo);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DoubleType_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DoubleType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__DoubleType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DoubleType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::DoubleType *)new OpenBabel::DoubleType();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_DoubleType(OpenBabel::DoubleType *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_DoubleMultiply(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  OpenBabel::DoubleType *arg3 = (OpenBabel::DoubleType *) 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::DoubleMultiply" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::DoubleMultiply" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::DoubleMultiply" "', argument " "3"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::DoubleType * >(argp3);
  OpenBabel::DoubleMultiply(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleAdd(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::DoubleAdd" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::DoubleAdd" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  OpenBabel::DoubleAdd(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleModulus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::DoubleModulus" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::DoubleModulus" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (unsigned int)OpenBabel::DoubleModulus(arg1,arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBRandom;

SWIGINTERN VALUE
_wrap_new_OBRandom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  bool arg1 ;
  OpenBabel::OBRandom *result = 0 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_bool(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBRandom" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  result = (OpenBabel::OBRandom *)new OpenBabel::OBRandom(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRandom_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRandom_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRandom);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRandom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBRandom *)new OpenBabel::OBRandom();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBRandom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBRandom__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_bool(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_OBRandom__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBRandom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRandom_Seed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Seed" "', argument " "1"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Seed" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->Seed(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRandom_TimeSeed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimeSeed" "', argument " "1"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1);
  (arg1)->TimeSeed();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRandom_NextInt(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextInt" "', argument " "1"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1);
  result = (int)(arg1)->NextInt();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRandom_NextFloat(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextFloat" "', argument " "1"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1);
  result = (double)(arg1)->NextFloat();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRandom(OpenBabel::OBRandom *arg1) {
    delete arg1;
}

swig_class cOBStopwatch;

SWIGINTERN VALUE
_wrap_OBStopwatch_Start(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *arg1 = (OpenBabel::OBStopwatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBStopwatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Start" "', argument " "1"" of type '" "OpenBabel::OBStopwatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBStopwatch * >(argp1);
  (arg1)->Start();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBStopwatch_Lap(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *arg1 = (OpenBabel::OBStopwatch *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBStopwatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Lap" "', argument " "1"" of type '" "OpenBabel::OBStopwatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBStopwatch * >(argp1);
  result = (double)(arg1)->Lap();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBStopwatch_Elapsed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *arg1 = (OpenBabel::OBStopwatch *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBStopwatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Elapsed" "', argument " "1"" of type '" "OpenBabel::OBStopwatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBStopwatch * >(argp1);
  result = (double)(arg1)->Elapsed();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBStopwatch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBStopwatch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBStopwatch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBStopwatch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBStopwatch *)new OpenBabel::OBStopwatch();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBStopwatch(OpenBabel::OBStopwatch *arg1) {
    delete arg1;
}

swig_class cOBSqrtTbl;

SWIGINTERN VALUE
_wrap_new_OBSqrtTbl__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSqrtTbl *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSqrtTbl *)new OpenBabel::OBSqrtTbl();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSqrtTbl_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSqrtTbl_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSqrtTbl);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSqrtTbl__SWIG_1(int argc, VALUE *argv, VALUE self) {
  double arg1 ;
  double arg2 ;
  OpenBabel::OBSqrtTbl *result = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBSqrtTbl" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBSqrtTbl" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (OpenBabel::OBSqrtTbl *)new OpenBabel::OBSqrtTbl(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBSqrtTbl(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBSqrtTbl__SWIG_0(nargs, args, self);
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBSqrtTbl__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBSqrtTbl'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSqrtTbl(OpenBabel::OBSqrtTbl *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBSqrtTbl_Sqrt(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSqrtTbl *arg1 = (OpenBabel::OBSqrtTbl *) 0 ;
  double arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSqrtTbl, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sqrt" "', argument " "1"" of type '" "OpenBabel::OBSqrtTbl const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSqrtTbl * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Sqrt" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (double)((OpenBabel::OBSqrtTbl const *)arg1)->Sqrt(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSqrtTbl_Init(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSqrtTbl *arg1 = (OpenBabel::OBSqrtTbl *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSqrtTbl, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Init" "', argument " "1"" of type '" "OpenBabel::OBSqrtTbl *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSqrtTbl * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Init" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Init" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->Init(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


swig_class cVector3;

SWIGINTERN VALUE
_wrap_new_vector3__SWIG_0(int argc, VALUE *argv, VALUE self) {
  double arg1 ;
  double arg2 ;
  double arg3 ;
  OpenBabel::vector3 *result = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::vector3" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::vector3" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vector3__SWIG_1(int argc, VALUE *argv, VALUE self) {
  double arg1 ;
  double arg2 ;
  OpenBabel::vector3 *result = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::vector3" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vector3__SWIG_2(int argc, VALUE *argv, VALUE self) {
  double arg1 ;
  OpenBabel::vector3 *result = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vector3__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::vector3 *)new OpenBabel::vector3();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vector3_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__vector3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vector3__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (OpenBabel::vector3 *)new OpenBabel::vector3((OpenBabel::vector3 const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vector3(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vector3__SWIG_3(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_vector3__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vector3__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_vector3__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_vector3__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vector3'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_Set__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Set" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Set" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (arg1)->Set(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_Set__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Set" "', argument " "2"" of type '" "double const *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  (arg1)->Set((double const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_vector3_Set(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_vector3_Set__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_vector3_Set__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'vector3_Set'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_SetX(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetX" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetX(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_SetY(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetY" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetY(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_SetZ(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetZ" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetZ" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetZ(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_Get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Get" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Get" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  (arg1)->Get(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_AsArray(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AsArray" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (double *)((OpenBabel::vector3 const *)arg1)->AsArray();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_randomUnitVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::OBRandom *arg2 = (OpenBabel::OBRandom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "randomUnitVector" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "randomUnitVector" "', argument " "2"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRandom * >(argp2);
  (arg1)->randomUnitVector(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_randomUnitVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "randomUnitVector" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  (arg1)->randomUnitVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_vector3_randomUnitVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_vector3_randomUnitVector__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBRandom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_vector3_randomUnitVector__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'vector3_randomUnitVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_normalize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "normalize" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (arg1)->normalize();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_CanBeNormalized(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CanBeNormalized" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (bool)((OpenBabel::vector3 const *)arg1)->CanBeNormalized();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_length_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "length_2" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (double)((OpenBabel::vector3 const *)arg1)->length_2();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "length" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (double)((OpenBabel::vector3 const *)arg1)->length();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_x__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double const &_result_ref = ((OpenBabel::vector3 const *)arg1)->x();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_From_double(static_cast< double >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_y__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double const &_result_ref = ((OpenBabel::vector3 const *)arg1)->y();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_From_double(static_cast< double >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_z__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double const &_result_ref = ((OpenBabel::vector3 const *)arg1)->z();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_From_double(static_cast< double >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_x__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double &_result_ref = (arg1)->x();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_vector3_x(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_vector3_x__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_vector3_x__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'vector3_x'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_y__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double &_result_ref = (arg1)->y();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_vector3_y(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_vector3_y__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_vector3_y__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'vector3_y'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_z__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double &_result_ref = (arg1)->z();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_vector3_z(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_vector3_z__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_vector3_z__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'vector3_z'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3___eq__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ==" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "operator ==" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "operator ==" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (int)((OpenBabel::vector3 const *)arg1)->operator ==((OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_IsApprox(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsApprox" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsApprox" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IsApprox" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IsApprox" "', argument " "3"" of type '" "double""'");
  } 
  temp3 = static_cast< double >(val3);
  arg3 = &temp3;
  result = (bool)((OpenBabel::vector3 const *)arg1)->IsApprox((OpenBabel::vector3 const &)*arg2,(double const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_distSq(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "distSq" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "distSq" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "distSq" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)((OpenBabel::vector3 const *)arg1)->distSq((OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector3_createOrthoVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "createOrthoVector" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "createOrthoVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "createOrthoVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (bool)((OpenBabel::vector3 const *)arg1)->createOrthoVector(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_vector3(OpenBabel::vector3 *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap___lshift__(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator <<" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator <<" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator <<" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator <<" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  {
    std::ostream &_result_ref = OpenBabel::operator <<(*arg1,(OpenBabel::vector3 const &)*arg2);
    result = (std::ostream *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___add__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator +" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator +" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator +" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator +" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator +((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator -" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator -" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator -" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator -" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator -((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator -" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator -" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = OpenBabel::operator -((OpenBabel::vector3 const &)*arg1);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___sub__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap___sub____SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___sub____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded '__sub__'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
  double *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  double temp1 ;
  double val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "double""'");
  } 
  temp1 = static_cast< double >(val1);
  arg1 = &temp1;
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator *((double const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  double *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  double temp2 ;
  double val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "double""'");
  } 
  temp2 = static_cast< double >(val2);
  arg2 = &temp2;
  result = OpenBabel::operator *((OpenBabel::vector3 const &)*arg1,(double const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___div__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  double *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  double temp2 ;
  double val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator /" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator /" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::operator /" "', argument " "2"" of type '" "double""'");
  } 
  temp2 = static_cast< double >(val2);
  arg2 = &temp2;
  result = OpenBabel::operator /((OpenBabel::vector3 const &)*arg1,(double const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___mul____SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::matrix3x3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__matrix3x3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "OpenBabel::matrix3x3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "OpenBabel::matrix3x3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::matrix3x3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator *((OpenBabel::matrix3x3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___mul__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap___mul____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__matrix3x3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___mul____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___mul____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded '__mul__'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_dot(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::dot" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::dot" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::dot" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::dot" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)OpenBabel::dot((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cross(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::cross" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::cross" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::cross" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::cross" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::cross((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::vectorAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::vectorAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::vectorAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::vectorAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)OpenBabel::vectorAngle((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CalcTorsionAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "3"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "3"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "4"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "4"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (double)OpenBabel::CalcTorsionAngle((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2,(OpenBabel::vector3 const &)*arg3,(OpenBabel::vector3 const &)*arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Point2Plane(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 arg1 ;
  OpenBabel::vector3 arg2 ;
  OpenBabel::vector3 arg3 ;
  OpenBabel::vector3 arg4 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::Point2Plane" "', argument " "1"" of type '" "OpenBabel::vector3""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2Plane" "', argument " "1"" of type '" "OpenBabel::vector3""'");
    } else {
      arg1 = *(reinterpret_cast< OpenBabel::vector3 * >(argp1));
    }
  }
  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::Point2Plane" "', argument " "2"" of type '" "OpenBabel::vector3""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2Plane" "', argument " "2"" of type '" "OpenBabel::vector3""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::Point2Plane" "', argument " "3"" of type '" "OpenBabel::vector3""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2Plane" "', argument " "3"" of type '" "OpenBabel::vector3""'");
    } else {
      arg3 = *(reinterpret_cast< OpenBabel::vector3 * >(argp3));
    }
  }
  {
    res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::Point2Plane" "', argument " "4"" of type '" "OpenBabel::vector3""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2Plane" "', argument " "4"" of type '" "OpenBabel::vector3""'");
    } else {
      arg4 = *(reinterpret_cast< OpenBabel::vector3 * >(argp4));
    }
  }
  result = (double)OpenBabel::Point2Plane(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Point2PlaneAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 arg1 ;
  OpenBabel::vector3 arg2 ;
  OpenBabel::vector3 arg3 ;
  OpenBabel::vector3 arg4 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg1 = *(reinterpret_cast< OpenBabel::vector3 * >(argp1));
    }
  }
  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "3"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "3"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg3 = *(reinterpret_cast< OpenBabel::vector3 * >(argp3));
    }
  }
  {
    res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "4"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "4"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg4 = *(reinterpret_cast< OpenBabel::vector3 * >(argp4));
    }
  }
  result = (double)OpenBabel::Point2PlaneAngle(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
VZero_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VZero), SWIGTYPE_p_OpenBabel__vector3,  0 );
  return _val;
}


SWIGINTERN VALUE
VX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VX), SWIGTYPE_p_OpenBabel__vector3,  0 );
  return _val;
}


SWIGINTERN VALUE
VY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VY), SWIGTYPE_p_OpenBabel__vector3,  0 );
  return _val;
}


SWIGINTERN VALUE
VZ_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VZ), SWIGTYPE_p_OpenBabel__vector3,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_Trim(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::Trim" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Trim" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  {
    std::string &_result_ref = OpenBabel::Trim(*arg1);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBGenericData;

SWIGINTERN VALUE
_wrap_new_OBGenericData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  unsigned int arg2 ;
  OpenBabel::DataOrigin arg3 ;
  OpenBabel::OBGenericData *result = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBGenericData" "', argument " "1"" of type '" "std::string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBGenericData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBGenericData" "', argument " "3"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg3 = static_cast< OpenBabel::DataOrigin >(val3);
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBGenericData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBGenericData" "', argument " "1"" of type '" "std::string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBGenericData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBGenericData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBGenericData *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBGenericData" "', argument " "1"" of type '" "std::string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBGenericData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBGenericData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBGenericData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBGenericData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBGenericData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBGenericData__SWIG_3(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBGenericData__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBGenericData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_OBGenericData__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBGenericData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBGenericData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBGenericData(OpenBabel::OBGenericData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBGenericData_SetAttribute(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAttribute" "', argument " "1"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->SetAttribute((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_SetOrigin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOrigin" "', argument " "1"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetOrigin" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  (arg1)->SetOrigin(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_GetAttribute(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAttribute" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBGenericData const *)arg1)->GetAttribute();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_GetDataType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDataType" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  result = (unsigned int)((OpenBabel::OBGenericData const *)arg1)->GetDataType();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_GetValue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValue" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBGenericData const *)arg1)->GetValue();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_GetOrigin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  OpenBabel::DataOrigin result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOrigin" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  result = (OpenBabel::DataOrigin)((OpenBabel::OBGenericData const *)arg1)->GetOrigin();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBCommentData;

SWIGINTERN VALUE
_wrap_new_OBCommentData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBCommentData *)new OpenBabel::OBCommentData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBCommentData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBCommentData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBCommentData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBCommentData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = 0 ;
  OpenBabel::OBCommentData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBCommentData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBCommentData" "', argument " "1"" of type '" "OpenBabel::OBCommentData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBCommentData" "', argument " "1"" of type '" "OpenBabel::OBCommentData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  result = (OpenBabel::OBCommentData *)new OpenBabel::OBCommentData((OpenBabel::OBCommentData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBCommentData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBCommentData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBCommentData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBCommentData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBCommentData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBCommentData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBCommentData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_SetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBCommentData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->SetData((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_SetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBCommentData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetData((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBCommentData_SetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBCommentData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBCommentData_SetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBCommentData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBCommentData_SetData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBCommentData_SetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_GetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBCommentData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBCommentData const *)arg1)->GetData();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_GetValue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValue" "', argument " "1"" of type '" "OpenBabel::OBCommentData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBCommentData const *)arg1)->GetValue();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBCommentData(OpenBabel::OBCommentData *arg1) {
    delete arg1;
}

swig_class cOBExternalBond;

SWIGINTERN VALUE
_wrap_new_OBExternalBond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBExternalBond *)new OpenBabel::OBExternalBond();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBExternalBond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  int arg3 ;
  OpenBabel::OBExternalBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBExternalBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBExternalBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBExternalBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (OpenBabel::OBExternalBond *)new OpenBabel::OBExternalBond(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBExternalBond_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBExternalBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBExternalBond);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBExternalBond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = 0 ;
  OpenBabel::OBExternalBond *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBExternalBond,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBExternalBond" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBExternalBond" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (OpenBabel::OBExternalBond *)new OpenBabel::OBExternalBond((OpenBabel::OBExternalBond const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBExternalBond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBExternalBond__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBExternalBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBExternalBond__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_OBExternalBond__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBExternalBond'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBExternalBond(OpenBabel::OBExternalBond *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBExternalBond_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (int)((OpenBabel::OBExternalBond const *)arg1)->GetIdx();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_GetAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtom" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBExternalBond const *)arg1)->GetAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_GetBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (OpenBabel::OBBond *)((OpenBabel::OBExternalBond const *)arg1)->GetBond();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBExternalBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_SetAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtom" "', argument " "1"" of type '" "OpenBabel::OBExternalBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->SetAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_SetBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBond" "', argument " "1"" of type '" "OpenBabel::OBExternalBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (arg1)->SetBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBExternalBondData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBExternalBondData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBExternalBondData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBExternalBondData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBExternalBondData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBExternalBondData *)new OpenBabel::OBExternalBondData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBondData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *arg1 = (OpenBabel::OBExternalBondData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBondData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBExternalBondData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBondData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBExternalBondData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBondData_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *arg1 = (OpenBabel::OBExternalBondData *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBondData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBExternalBondData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBondData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetData" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetData" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->SetData(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBondData_GetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *arg1 = (OpenBabel::OBExternalBondData *) 0 ;
  std::vector<OpenBabel::OBExternalBond > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBondData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBExternalBondData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBondData * >(argp1);
  result = (std::vector<OpenBabel::OBExternalBond > *)(arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBExternalBond_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBExternalBondData(OpenBabel::OBExternalBondData *arg1) {
    delete arg1;
}

swig_class cOBPairData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBPairData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBPairData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBPairData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBPairData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBPairData *)new OpenBabel::OBPairData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBPairData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBPairData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBPairData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBPairData_SetValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetValue" "', argument " "1"" of type '" "OpenBabel::OBPairData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetValue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetValue((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBPairData_SetValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetValue" "', argument " "1"" of type '" "OpenBabel::OBPairData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetValue" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetValue" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->SetValue((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBPairData_SetValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBPairData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBPairData_SetValue__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBPairData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBPairData_SetValue__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBPairData_SetValue'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBPairData_GetValue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValue" "', argument " "1"" of type '" "OpenBabel::OBPairData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBPairData const *)arg1)->GetValue();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBPairData(OpenBabel::OBPairData *arg1) {
    delete arg1;
}

swig_class cOBSetData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSetData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSetData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSetData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSetData *)new OpenBabel::OBSetData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBSetData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBSetData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_AddData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->AddData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBSetData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > const &_result_ref = ((OpenBabel::OBSetData const *)arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSetData_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSetData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBSetData_GetData__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSetData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSetData_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSetData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSetData_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSetData_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_GetBegin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBegin" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  result = (arg1)->GetBegin();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBGenericData * >::iterator(static_cast< const std::vector<OpenBabel::OBGenericData * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_GetEnd(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnd" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  result = (arg1)->GetEnd();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBGenericData * >::iterator(static_cast< const std::vector<OpenBabel::OBGenericData * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_DeleteData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSetData(OpenBabel::OBSetData *arg1) {
    delete arg1;
}

swig_class cOBVirtualBond;

SWIGINTERN VALUE
_wrap_new_OBVirtualBond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBVirtualBond *)new OpenBabel::OBVirtualBond();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBVirtualBond const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBVirtualBond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  OpenBabel::OBVirtualBond *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBVirtualBond" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBVirtualBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBVirtualBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBVirtualBond" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (OpenBabel::OBVirtualBond *)new OpenBabel::OBVirtualBond(arg1,arg2,arg3,arg4);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBVirtualBond_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBVirtualBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBVirtualBond);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBVirtualBond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  OpenBabel::OBVirtualBond *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBVirtualBond" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBVirtualBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBVirtualBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (OpenBabel::OBVirtualBond *)new OpenBabel::OBVirtualBond(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBVirtualBond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBVirtualBond__SWIG_0(nargs, args, self);
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_OBVirtualBond__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_OBVirtualBond__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBVirtualBond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_GetBgn(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBgn" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  result = (int)(arg1)->GetBgn();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_GetEnd(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnd" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  result = (int)(arg1)->GetEnd();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_GetOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOrder" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  result = (int)(arg1)->GetOrder();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_GetStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetStereo" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  result = (int)(arg1)->GetStereo();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBVirtualBond(OpenBabel::OBVirtualBond *arg1) {
    delete arg1;
}

swig_class cOBRingData;

SWIGINTERN VALUE
_wrap_new_OBRingData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBRingData *)new OpenBabel::OBRingData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRingData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRingData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRingData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRingData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = 0 ;
  OpenBabel::OBRingData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBRingData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRingData" "', argument " "1"" of type '" "OpenBabel::OBRingData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRingData" "', argument " "1"" of type '" "OpenBabel::OBRingData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  result = (OpenBabel::OBRingData *)new OpenBabel::OBRingData((OpenBabel::OBRingData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBRingData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBRingData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBRingData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBRingData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBRingData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBRingData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBRingData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRingData(OpenBabel::OBRingData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBRingData_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector<OpenBabel::OBRing * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBRing * > * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_PushBack(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  OpenBabel::OBRing *arg2 = (OpenBabel::OBRing *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PushBack" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PushBack" "', argument " "2"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2);
  (arg1)->PushBack(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_GetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector<OpenBabel::OBRing * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  {
    std::vector<OpenBabel::OBRing * > &_result_ref = (arg1)->GetData();
    result = (std::vector<OpenBabel::OBRing * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_BeginRings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBRing * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginRings" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  result = (arg1)->BeginRings();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBRing * >::iterator(static_cast< const std::vector<OpenBabel::OBRing * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_EndRings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBRing * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndRings" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  result = (arg1)->EndRings();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBRing * >::iterator(static_cast< const std::vector<OpenBabel::OBRing * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_BeginRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector<OpenBabel::OBRing * >::iterator *arg2 = 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginRing" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginRing" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginRing" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBRing * >::iterator * >(argp2);
  result = (OpenBabel::OBRing *)(arg1)->BeginRing(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_NextRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector<OpenBabel::OBRing * >::iterator *arg2 = 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextRing" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextRing" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextRing" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBRing * >::iterator * >(argp2);
  result = (OpenBabel::OBRing *)(arg1)->NextRing(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBUnitCell;

SWIGINTERN VALUE
_wrap_new_OBUnitCell__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBUnitCell *)new OpenBabel::OBUnitCell();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBUnitCell_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBUnitCell_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBUnitCell);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBUnitCell__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = 0 ;
  OpenBabel::OBUnitCell *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBUnitCell,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBUnitCell" "', argument " "1"" of type '" "OpenBabel::OBUnitCell const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBUnitCell" "', argument " "1"" of type '" "OpenBabel::OBUnitCell const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (OpenBabel::OBUnitCell *)new OpenBabel::OBUnitCell((OpenBabel::OBUnitCell const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBUnitCell(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBUnitCell__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBUnitCell__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBUnitCell'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBUnitCell const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBUnitCell const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBUnitCell(OpenBabel::OBUnitCell *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBUnitCell_SetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetData" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetData" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetData" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SetData" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SetData" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  ecode7 = SWIG_AsVal_double(argv[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SetData" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = static_cast< double >(val7);
  (arg1)->SetData(arg2,arg3,arg4,arg5,arg6,arg7);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_SetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::vector3 arg2 ;
  OpenBabel::vector3 arg3 ;
  OpenBabel::vector3 arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetData" "', argument " "3"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "3"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg3 = *(reinterpret_cast< OpenBabel::vector3 * >(argp3));
    }
  }
  {
    res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SetData" "', argument " "4"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "4"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg4 = *(reinterpret_cast< OpenBabel::vector3 * >(argp4));
    }
  }
  (arg1)->SetData(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBUnitCell_SetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[8];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 8) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_OBUnitCell_SetData__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_double(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_double(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_double(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_OBUnitCell_SetData__SWIG_0(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBUnitCell_SetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_SetOffset(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::vector3 arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOffset" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOffset" "', argument " "2"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetOffset" "', argument " "2"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2));
    }
  }
  (arg1)->SetOffset(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_SetSpaceGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetSpaceGroup" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetSpaceGroup(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_SetSpaceGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpaceGroup" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetSpaceGroup(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBUnitCell_SetSpaceGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBUnitCell_SetSpaceGroup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBUnitCell_SetSpaceGroup__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBUnitCell_SetSpaceGroup'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_SetLatticeType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::OBUnitCell::LatticeType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLatticeType" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetLatticeType" "', argument " "2"" of type '" "OpenBabel::OBUnitCell::LatticeType""'");
  } 
  arg2 = static_cast< OpenBabel::OBUnitCell::LatticeType >(val2);
  (arg1)->SetLatticeType(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetA(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetA" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetA();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetB(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetB" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetB();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetC(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetC" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetC();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetAlpha(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAlpha" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetAlpha();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetBeta(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeta" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetBeta();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetGamma(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGamma" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetGamma();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetOffset(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOffset" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetOffset();
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetSpaceGroup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetSpaceGroup();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetLatticeType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  int arg2 ;
  OpenBabel::OBUnitCell::LatticeType result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLatticeType" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetLatticeType" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBUnitCell::LatticeType)(arg1)->GetLatticeType(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetLatticeType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::OBUnitCell::LatticeType result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLatticeType" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (OpenBabel::OBUnitCell::LatticeType)(arg1)->GetLatticeType();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBUnitCell_GetLatticeType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBUnitCell_GetLatticeType__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBUnitCell_GetLatticeType__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBUnitCell_GetLatticeType'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetCellVectors(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  std::vector<OpenBabel::vector3 > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCellVectors" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetCellVectors();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::vector3* x = new OpenBabel::vector3(((std::vector<OpenBabel::vector3 > &)result)[i]);
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__vector3, 1));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetCellMatrix(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::matrix3x3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCellMatrix" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetCellMatrix();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetOrthoMatrix(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::matrix3x3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOrthoMatrix" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetOrthoMatrix();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetFractionalMatrix(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::matrix3x3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFractionalMatrix" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetFractionalMatrix();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetSpaceGroupNumber(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  std::string arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpaceGroupNumber" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "GetSpaceGroupNumber" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->GetSpaceGroupNumber(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_GetCellVolume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCellVolume" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetCellVolume();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBConformerData;

SWIGINTERN VALUE
_wrap_new_OBConformerData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBConformerData *)new OpenBabel::OBConformerData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBConformerData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBConformerData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBConformerData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBConformerData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = 0 ;
  OpenBabel::OBConformerData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBConformerData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConformerData" "', argument " "1"" of type '" "OpenBabel::OBConformerData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBConformerData" "', argument " "1"" of type '" "OpenBabel::OBConformerData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (OpenBabel::OBConformerData *)new OpenBabel::OBConformerData((OpenBabel::OBConformerData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBConformerData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBConformerData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConformerData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBConformerData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBConformerData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBConformerData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBConformerData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBConformerData(OpenBabel::OBConformerData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBConformerData_SetDimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<unsigned short > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDimension" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_short_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetDimension" "', argument " "2"" of type '" "std::vector<unsigned short >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetDimension" "', argument " "2"" of type '" "std::vector<unsigned short >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<unsigned short > * >(argp2));
    }
  }
  (arg1)->SetDimension(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_SetEnergies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<double > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnergies" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg2 = std::vector<double >(size);
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (SWIG_FLOAT_P(o))
        ((std::vector<double > &)arg2)[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      void *ptr;
      SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTdouble_t, 1);
      arg2 = *((std::vector<double > *) ptr);
    }
  }
  (arg1)->SetEnergies(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_SetForces(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetForces" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetForces" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetForces" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<std::vector<OpenBabel::vector3 > > * >(argp2));
    }
  }
  (arg1)->SetForces(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_SetVelocities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVelocities" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVelocities" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVelocities" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<std::vector<OpenBabel::vector3 > > * >(argp2));
    }
  }
  (arg1)->SetVelocities(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_SetDisplacements(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDisplacements" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetDisplacements" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetDisplacements" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<std::vector<OpenBabel::vector3 > > * >(argp2));
    }
  }
  (arg1)->SetDisplacements(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<std::string > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::vector<std::string >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::vector<std::string >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<std::string > * >(argp2));
    }
  }
  (arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_GetDimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<unsigned short > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDimension" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetDimension();
  vresult = SWIG_NewPointerObj((new std::vector<unsigned short >(static_cast< const std::vector<unsigned short >& >(result))), SWIGTYPE_p_std__vectorTunsigned_short_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_GetEnergies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<double > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnergies" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetEnergies();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,rb_float_new(((std::vector<double > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_GetForces(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetForces" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetForces();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<OpenBabel::vector3 > >(static_cast< const std::vector<std::vector<OpenBabel::vector3 > >& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_GetVelocities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVelocities" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetVelocities();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<OpenBabel::vector3 > >(static_cast< const std::vector<std::vector<OpenBabel::vector3 > >& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_GetDisplacements(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDisplacements" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetDisplacements();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<OpenBabel::vector3 > >(static_cast< const std::vector<std::vector<OpenBabel::vector3 > >& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_GetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<std::string > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetData();
  vresult = SWIG_NewPointerObj((new std::vector<std::string >(static_cast< const std::vector<std::string >& >(result))), SWIGTYPE_p_std__vectorTstd__string_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBSymmetryData;

SWIGINTERN VALUE
_wrap_new_OBSymmetryData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSymmetryData *)new OpenBabel::OBSymmetryData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSymmetryData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSymmetryData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSymmetryData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSymmetryData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = 0 ;
  OpenBabel::OBSymmetryData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBSymmetryData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBSymmetryData" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBSymmetryData" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  result = (OpenBabel::OBSymmetryData *)new OpenBabel::OBSymmetryData((OpenBabel::OBSymmetryData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBSymmetryData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBSymmetryData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSymmetryData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBSymmetryData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBSymmetryData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBSymmetryData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSymmetryData(OpenBabel::OBSymmetryData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBSymmetryData_SetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetData" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetData(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_SetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSymmetryData_SetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSymmetryData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSymmetryData_SetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSymmetryData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBSymmetryData_SetData__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSymmetryData_SetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_SetPointGroup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPointGroup" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetPointGroup" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetPointGroup(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_SetSpaceGroup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetSpaceGroup" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetSpaceGroup(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_GetPointGroup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPointGroup" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  result = (arg1)->GetPointGroup();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_GetSpaceGroup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  result = (arg1)->GetSpaceGroup();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBTorsion;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBTorsion_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBTorsion_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBTorsion);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBTorsion__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = 0 ;
  OpenBabel::OBTorsion *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBTorsion,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBTorsion" "', argument " "1"" of type '" "OpenBabel::OBTorsion const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBTorsion" "', argument " "1"" of type '" "OpenBabel::OBTorsion const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (OpenBabel::OBTorsion *)new OpenBabel::OBTorsion((OpenBabel::OBTorsion const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBTorsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBTorsion__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBTorsion'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBTorsion(OpenBabel::OBTorsion *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBTorsion_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_Empty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Empty" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (bool)(arg1)->Empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_AddTorsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg5 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddTorsion" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddTorsion" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AddTorsion" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "AddTorsion" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "AddTorsion" "', argument " "5"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::OBAtom * >(argp5);
  result = (bool)(arg1)->AddTorsion(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_AddTorsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddTorsion" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddTorsion" "', argument " "2"" of type '" "OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddTorsion" "', argument " "2"" of type '" "OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > * >(argp2);
  result = (bool)(arg1)->AddTorsion(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBTorsion_AddTorsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBTorsion_AddTorsion__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_OBTorsion_AddTorsion__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBTorsion_AddTorsion'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_SetAngle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  double arg2 ;
  unsigned int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAngle" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAngle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetAngle" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)(arg1)->SetAngle(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_SetAngle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  double arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAngle" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAngle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (bool)(arg1)->SetAngle(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBTorsion_SetAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBTorsion_SetAngle__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBTorsion_SetAngle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBTorsion_SetAngle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->SetData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_GetAngle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  double *arg2 = 0 ;
  unsigned int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_double,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "double &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetAngle" "', argument " "2"" of type '" "double &""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)(arg1)->GetAngle(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_GetAngle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  double *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_double,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "double &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetAngle" "', argument " "2"" of type '" "double &""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  result = (bool)(arg1)->GetAngle(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBTorsion_GetAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBTorsion_GetAngle__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBTorsion_GetAngle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBTorsion_GetAngle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_GetBondIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBondIdx" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (unsigned int)(arg1)->GetBondIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_GetSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBTorsion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (unsigned int)((OpenBabel::OBTorsion const *)arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_GetBC(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  SwigValueWrapper<std::pair<OpenBabel::OBAtom *,OpenBabel::OBAtom * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBC" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (arg1)->GetBC();
  vresult = SWIG_NewPointerObj((new std::pair<OpenBabel::OBAtom *,OpenBabel::OBAtom * >(static_cast< const std::pair<OpenBabel::OBAtom *,OpenBabel::OBAtom * >& >(result))), SWIGTYPE_p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_GetADs(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetADs" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (arg1)->GetADs();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > >(static_cast< const std::vector<OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_IsProtonRotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsProtonRotor" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (bool)(arg1)->IsProtonRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBTorsionData;

SWIGINTERN VALUE
_wrap_OBTorsionData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBTorsionData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBTorsionData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBTorsionData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_GetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBTorsion > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBTorsionData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  result = ((OpenBabel::OBTorsionData const *)arg1)->GetData();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBTorsion >(static_cast< const std::vector<OpenBabel::OBTorsion >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBTorsion_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_GetSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBTorsionData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  result = (unsigned int)((OpenBabel::OBTorsionData const *)arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  OpenBabel::OBTorsion *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBTorsionData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBTorsion,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBTorsion &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBTorsion &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBTorsion * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_FillTorsionArray(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  std::vector<std::vector<unsigned int > > *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FillTorsionArray" "', argument " "1"" of type '" "OpenBabel::OBTorsionData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTunsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FillTorsionArray" "', argument " "2"" of type '" "std::vector<std::vector<unsigned int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FillTorsionArray" "', argument " "2"" of type '" "std::vector<std::vector<unsigned int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<unsigned int > > * >(argp2);
  result = (bool)(arg1)->FillTorsionArray(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBTorsionData(OpenBabel::OBTorsionData *arg1) {
    delete arg1;
}

swig_class cOBAngle;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBAngle_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBAngle_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAngle);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBAngle__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = 0 ;
  OpenBabel::OBAngle *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBAngle,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAngle" "', argument " "1"" of type '" "OpenBabel::OBAngle const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBAngle" "', argument " "1"" of type '" "OpenBabel::OBAngle const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  result = (OpenBabel::OBAngle *)new OpenBabel::OBAngle((OpenBabel::OBAngle const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngle, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAngle__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBAngle'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAngle(OpenBabel::OBAngle *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBAngle___eq__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  OpenBabel::OBAngle *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ==" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAngle,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "operator ==" "', argument " "2"" of type '" "OpenBabel::OBAngle const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "operator ==" "', argument " "2"" of type '" "OpenBabel::OBAngle const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAngle * >(argp2);
  result = (bool)(arg1)->operator ==((OpenBabel::OBAngle const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_GetAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAngle const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  result = (double)((OpenBabel::OBAngle const *)arg1)->GetAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_SetAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAngle" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAngle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetAngle(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_SetAtoms__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtoms" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtoms" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetAtoms" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SetAtoms" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  (arg1)->SetAtoms(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_SetAtoms__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtoms" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtoms" "', argument " "2"" of type '" "OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetAtoms" "', argument " "2"" of type '" "OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > * >(argp2);
  (arg1)->SetAtoms(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAngle_SetAtoms(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngle, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAngle_SetAtoms__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngle, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_OBAngle_SetAtoms__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAngle_SetAtoms'");
  return Qnil;
}


swig_class cOBAngleData;

SWIGINTERN VALUE
_wrap_OBAngleData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBAngleData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBAngleData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAngleData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_FillAngleArray__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  int **arg2 = (int **) 0 ;
  unsigned int *arg3 = 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FillAngleArray" "', argument " "1"" of type '" "OpenBabel::OBAngleData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FillAngleArray" "', argument " "2"" of type '" "int **""'"); 
  }
  arg2 = reinterpret_cast< int ** >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_unsigned_int,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FillAngleArray" "', argument " "3"" of type '" "unsigned int &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FillAngleArray" "', argument " "3"" of type '" "unsigned int &""'"); 
  }
  arg3 = reinterpret_cast< unsigned int * >(argp3);
  result = (unsigned int)(arg1)->FillAngleArray(arg2,*arg3);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_FillAngleArray__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  std::vector<std::vector<unsigned int > > *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FillAngleArray" "', argument " "1"" of type '" "OpenBabel::OBAngleData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTunsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FillAngleArray" "', argument " "2"" of type '" "std::vector<std::vector<unsigned int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FillAngleArray" "', argument " "2"" of type '" "std::vector<std::vector<unsigned int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<unsigned int > > * >(argp2);
  result = (bool)(arg1)->FillAngleArray(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAngleData_FillAngleArray(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngleData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTstd__vectorTunsigned_int_t_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAngleData_FillAngleArray__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngleData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_p_int, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_unsigned_int, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBAngleData_FillAngleArray__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAngleData_FillAngleArray'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  OpenBabel::OBAngle *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBAngleData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAngle,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBAngle &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBAngle &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAngle * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_GetSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBAngleData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  result = (unsigned int)((OpenBabel::OBAngleData const *)arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAngleData(OpenBabel::OBAngleData *arg1) {
    delete arg1;
}

swig_class cOBChiralData;

SWIGINTERN VALUE
_wrap_new_OBChiralData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBChiralData *)new OpenBabel::OBChiralData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBChiralData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBChiralData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBChiralData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBChiralData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = 0 ;
  OpenBabel::OBChiralData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBChiralData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBChiralData" "', argument " "1"" of type '" "OpenBabel::OBChiralData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBChiralData" "', argument " "1"" of type '" "OpenBabel::OBChiralData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  result = (OpenBabel::OBChiralData *)new OpenBabel::OBChiralData((OpenBabel::OBChiralData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBChiralData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBChiralData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBChiralData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBChiralData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBChiralData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBChiralData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBChiralData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBChiralData(OpenBabel::OBChiralData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBChiralData_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBChiralData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_GetAtom4Refs(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  OpenBabel::atomreftype arg2 ;
  std::vector<unsigned int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtom4Refs" "', argument " "1"" of type '" "OpenBabel::OBChiralData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAtom4Refs" "', argument " "2"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg2 = static_cast< OpenBabel::atomreftype >(val2);
  result = ((OpenBabel::OBChiralData const *)arg1)->GetAtom4Refs(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<unsigned int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_GetAtomRef(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  int arg2 ;
  OpenBabel::atomreftype arg3 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomRef" "', argument " "1"" of type '" "OpenBabel::OBChiralData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAtomRef" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAtomRef" "', argument " "3"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg3 = static_cast< OpenBabel::atomreftype >(val3);
  result = (unsigned int)(arg1)->GetAtomRef(arg2,arg3);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_SetAtom4Refs(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  std::vector<unsigned int > arg2 ;
  OpenBabel::atomreftype arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtom4Refs" "', argument " "1"" of type '" "OpenBabel::OBChiralData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg2 = std::vector<unsigned int >(size);
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        ((std::vector<unsigned int > &)arg2)[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      void *ptr;
      SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
      arg2 = *((std::vector<unsigned int > *) ptr);
    }
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetAtom4Refs" "', argument " "3"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg3 = static_cast< OpenBabel::atomreftype >(val3);
  result = (bool)(arg1)->SetAtom4Refs(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_AddAtomRef(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  unsigned int arg2 ;
  OpenBabel::atomreftype arg3 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddAtomRef" "', argument " "1"" of type '" "OpenBabel::OBChiralData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddAtomRef" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddAtomRef" "', argument " "3"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg3 = static_cast< OpenBabel::atomreftype >(val3);
  result = (int)(arg1)->AddAtomRef(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_GetSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  OpenBabel::atomreftype arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBChiralData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetSize" "', argument " "2"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg2 = static_cast< OpenBabel::atomreftype >(val2);
  result = (unsigned int)((OpenBabel::OBChiralData const *)arg1)->GetSize(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBSerialNums;

SWIGINTERN VALUE
_wrap_new_OBSerialNums__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSerialNums *)new OpenBabel::OBSerialNums();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSerialNums_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSerialNums_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSerialNums);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSerialNums__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = 0 ;
  OpenBabel::OBSerialNums *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBSerialNums,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBSerialNums" "', argument " "1"" of type '" "OpenBabel::OBSerialNums const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBSerialNums" "', argument " "1"" of type '" "OpenBabel::OBSerialNums const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  result = (OpenBabel::OBSerialNums *)new OpenBabel::OBSerialNums((OpenBabel::OBSerialNums const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBSerialNums(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBSerialNums__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSerialNums, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBSerialNums__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBSerialNums'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSerialNums_Clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = (OpenBabel::OBSerialNums *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSerialNums, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBSerialNums const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBSerialNums const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSerialNums_GetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = (OpenBabel::OBSerialNums *) 0 ;
  std::map<int,OpenBabel::OBAtom * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSerialNums, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBSerialNums *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  {
    std::map<int,OpenBabel::OBAtom * > &_result_ref = (arg1)->GetData();
    result = (std::map<int,OpenBabel::OBAtom * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapTint_OpenBabel__OBAtom_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSerialNums_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = (OpenBabel::OBSerialNums *) 0 ;
  std::map<int,OpenBabel::OBAtom * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSerialNums, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBSerialNums *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapTint_OpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::map<int,OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::map<int,OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< std::map<int,OpenBabel::OBAtom * > * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSerialNums(OpenBabel::OBSerialNums *arg1) {
    delete arg1;
}

swig_class cOBVibrationData;

SWIGINTERN VALUE
_wrap_new_OBVibrationData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBVibrationData *)new OpenBabel::OBVibrationData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBVibrationData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBVibrationData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBVibrationData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBVibrationData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = 0 ;
  OpenBabel::OBVibrationData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBVibrationData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBVibrationData" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBVibrationData" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = (OpenBabel::OBVibrationData *)new OpenBabel::OBVibrationData((OpenBabel::OBVibrationData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBVibrationData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBVibrationData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBVibrationData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBVibrationData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBVibrationData'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBVibrationData(OpenBabel::OBVibrationData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBVibrationData_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  std::vector<std::vector<OpenBabel::vector3 > > *arg2 = 0 ;
  std::vector<double > *arg3 = 0 ;
  std::vector<double > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::vector<double > temp3 ;
  std::vector<double > temp4 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBVibrationData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > > const &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<OpenBabel::vector3 > > * >(argp2);
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp3 = std::vector<double >(size);
      arg3 = &temp3;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (SWIG_FLOAT_P(o))
        temp3[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  {
    if (rb_obj_is_kind_of(argv[2],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[2]);
      temp4 = std::vector<double >(size);
      arg4 = &temp4;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[2])[i];
        if (SWIG_FLOAT_P(o))
        temp4[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  (arg1)->SetData((std::vector<std::vector<OpenBabel::vector3 > > const &)*arg2,(std::vector<double > const &)*arg3,(std::vector<double > const &)*arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVibrationData_GetLx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLx" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = ((OpenBabel::OBVibrationData const *)arg1)->GetLx();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<OpenBabel::vector3 > >(static_cast< const std::vector<std::vector<OpenBabel::vector3 > >& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVibrationData_GetFrequencies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  std::vector<double > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFrequencies" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = ((OpenBabel::OBVibrationData const *)arg1)->GetFrequencies();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,rb_float_new(((std::vector<double > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVibrationData_GetIntensities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  std::vector<double > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIntensities" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = ((OpenBabel::OBVibrationData const *)arg1)->GetIntensities();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,rb_float_new(((std::vector<double > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVibrationData_GetNumberOfFrequencies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNumberOfFrequencies" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = (unsigned int)((OpenBabel::OBVibrationData const *)arg1)->GetNumberOfFrequencies();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBBase;

SWIGINTERN void
free_OpenBabel_OBBase(OpenBabel::OBBase *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBBase_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  result = (bool)(arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_ClassDescription(int argc, VALUE *argv, VALUE self) {
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (char *)OpenBabel::OBBase::ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_HasData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_HasData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_HasData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBase_HasData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBBase_HasData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_HasData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_HasData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBase_HasData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_DeleteData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_DeleteData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_DeleteData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBase_DeleteData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_DeleteData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_DeleteData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBBase_DeleteData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBase_DeleteData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_DataSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBBase const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  result = (unsigned int)((OpenBabel::OBBase const *)arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_GetData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_GetData__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBase_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBase_GetData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBBase_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBBase_GetData__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_GetData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBase_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_BeginData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  result = (arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_EndData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  result = (arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBBase_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBBase_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBBase);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBBase(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBBase *)new OpenBabel::OBBase();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


swig_class cPluginiterFingerprint;

SWIGINTERN VALUE
_wrap_pluginiterFingerprint_Register(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBFingerprint *arg2 = (OpenBabel::OBFingerprint *) 0 ;
  std::string arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Register" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Register" "', argument " "2"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Register" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Register" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->Register(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_FindType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindType" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBFingerprint *)(arg1)->FindType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_FindDefaultType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindDefaultType" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (OpenBabel::OBFingerprint *)((OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *)arg1)->FindDefaultType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_ID(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ID" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = ((OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *)arg1)->ID();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_ToStart(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ToStart" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  (arg1)->ToStart();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    OpenBabel::PluginIter<OpenBabel::OBFingerprint > &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (bool)((OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (OpenBabel::OBFingerprint *)((OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pluginiterFingerprint_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pluginiterFingerprint_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pluginiterFingerprint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *)new OpenBabel::PluginIter<OpenBabel::OBFingerprint >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_PluginIter_Sl_OpenBabel_OBFingerprint_Sg_(OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_pluginiterFingerprint_Iter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Iter" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    OpenBabel::PluginIter<OpenBabel::OBFingerprint > &_result_ref = (*arg1)->Iter();
    result = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_SetBit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBit" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBit" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetBit" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetBit" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (*arg1)->SetBit(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_Fold(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Fold" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Fold" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Fold" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Fold" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (*arg1)->Fold(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_GetFingerprint__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetFingerprint" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GetFingerprint" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)(*arg1)->GetFingerprint(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_GetFingerprint__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetFingerprint" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  result = (bool)(*arg1)->GetFingerprint(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterFingerprint_GetFingerprint(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_pluginiterFingerprint_GetFingerprint__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterFingerprint_GetFingerprint__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterFingerprint_GetFingerprint'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_Description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Description" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (*arg1)->Description();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_Flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Flags" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (unsigned int)(*arg1)->Flags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_Tanimoto__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<unsigned int > temp2 ;
  std::vector<unsigned int > temp3 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tanimoto" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp3 = std::vector<unsigned int >(size);
      arg3 = &temp3;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (FIXNUM_P(o))
        temp3[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (double)(*arg1)->Tanimoto((std::vector<unsigned int > const &)*arg2,(std::vector<unsigned int > const &)*arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_Tanimoto__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int *arg3 = (unsigned int *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<unsigned int > temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tanimoto" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Tanimoto" "', argument " "3"" of type '" "unsigned int const *""'"); 
  }
  arg3 = reinterpret_cast< unsigned int * >(argp3);
  result = (double)(*arg1)->Tanimoto((std::vector<unsigned int > const &)*arg2,(unsigned int const *)arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterFingerprint_Tanimoto(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        /* native sequence? */
        if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
          unsigned int size = RARRAY_LEN(argv[1]);
          if (size == 0) {
            /* an empty sequence can be of any type */
            _v = 1;
          } else {
            /* check the first element only */
            VALUE o = RARRAY_PTR(argv[1])[0];
            if (FIXNUM_P(o))
            _v = 1;
            else
            _v = 0;
          }
        } else {
          /* wrapped vector? */
          std::vector<unsigned int >* v;
          if (SWIG_ConvertPtr(argv[1],(void **) &v, 
              SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
          _v = 1;
          else
          _v = 0;
        }
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_unsigned_int, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_pluginiterFingerprint_Tanimoto__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        /* native sequence? */
        if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
          unsigned int size = RARRAY_LEN(argv[1]);
          if (size == 0) {
            /* an empty sequence can be of any type */
            _v = 1;
          } else {
            /* check the first element only */
            VALUE o = RARRAY_PTR(argv[1])[0];
            if (FIXNUM_P(o))
            _v = 1;
            else
            _v = 0;
          }
        } else {
          /* wrapped vector? */
          std::vector<unsigned int >* v;
          if (SWIG_ConvertPtr(argv[1],(void **) &v, 
              SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
          _v = 1;
          else
          _v = 0;
        }
      }
      if (_v) {
        {
          /* native sequence? */
          if (rb_obj_is_kind_of(argv[2],rb_cArray)) {
            unsigned int size = RARRAY_LEN(argv[2]);
            if (size == 0) {
              /* an empty sequence can be of any type */
              _v = 1;
            } else {
              /* check the first element only */
              VALUE o = RARRAY_PTR(argv[2])[0];
              if (FIXNUM_P(o))
              _v = 1;
              else
              _v = 0;
            }
          } else {
            /* wrapped vector? */
            std::vector<unsigned int >* v;
            if (SWIG_ConvertPtr(argv[2],(void **) &v, 
                SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
            _v = 1;
            else
            _v = 0;
          }
        }
        if (_v) {
          return _wrap_pluginiterFingerprint_Tanimoto__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterFingerprint_Tanimoto'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_Getbitsperint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Getbitsperint" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (unsigned int)(*arg1)->Getbitsperint();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_FindFingerprint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindFingerprint" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindFingerprint" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindFingerprint" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBFingerprint *)(*arg1)->FindFingerprint((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


swig_class cPluginiterForceField;

SWIGINTERN VALUE
_wrap_pluginiterForceField_Register(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBForceField *arg2 = (OpenBabel::OBForceField *) 0 ;
  std::string arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Register" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Register" "', argument " "2"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBForceField * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Register" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Register" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->Register(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_FindType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindType" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBForceField *)(arg1)->FindType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_FindDefaultType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindDefaultType" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (OpenBabel::OBForceField *)((OpenBabel::PluginIter<OpenBabel::OBForceField > const *)arg1)->FindDefaultType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ID(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ID" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = ((OpenBabel::PluginIter<OpenBabel::OBForceField > const *)arg1)->ID();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ToStart(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ToStart" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (arg1)->ToStart();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::PluginIter<OpenBabel::OBForceField > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    OpenBabel::PluginIter<OpenBabel::OBForceField > &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (bool)((OpenBabel::PluginIter<OpenBabel::OBForceField > const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (OpenBabel::OBForceField *)((OpenBabel::PluginIter<OpenBabel::OBForceField > const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pluginiterForceField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pluginiterForceField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pluginiterForceField(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::PluginIter<OpenBabel::OBForceField > *)new OpenBabel::PluginIter<OpenBabel::OBForceField >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_PluginIter_Sl_OpenBabel_OBForceField_Sg_(OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_pluginiterForceField_Iter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::PluginIter<OpenBabel::OBForceField > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Iter" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    OpenBabel::PluginIter<OpenBabel::OBForceField > &_result_ref = (*arg1)->Iter();
    result = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_FindForceField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindForceField" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindForceField" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindForceField" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBForceField *)(*arg1)->FindForceField((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_FindForceField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindForceField" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindForceField" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBForceField *)(*arg1)->FindForceField((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_FindForceField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_pluginiterForceField_FindForceField__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_pluginiterForceField_FindForceField__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_FindForceField'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_GetUnit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetUnit" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (*arg1)->GetUnit();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_Setup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Setup" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Setup" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Setup" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(*arg1)->Setup(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_UpdateCoordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UpdateCoordinates" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UpdateCoordinates" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UpdateCoordinates" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(*arg1)->UpdateCoordinates(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_UpdateConformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UpdateConformers" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UpdateConformers" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UpdateConformers" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(*arg1)->UpdateConformers(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_OBFFLog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OBFFLog" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OBFFLog" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (*arg1)->OBFFLog(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_OBFFLog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OBFFLog" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OBFFLog" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->OBFFLog((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_OBFFLog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_pluginiterForceField_OBFFLog__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_pluginiterForceField_OBFFLog__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_OBFFLog'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_Energy__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Energy" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Energy" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->Energy(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_Energy__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Energy" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->Energy();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_Energy(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_Energy__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_Energy__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_Energy'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_Bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Bond" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Bond" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_Bond(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_Bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Bond" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_Bond();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_E_Bond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_E_Bond__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_E_Bond__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_E_Bond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_Angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Angle" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Angle" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_Angle(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_Angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Angle" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_Angle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_E_Angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_E_Angle__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_E_Angle__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_E_Angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_StrBnd__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_StrBnd" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_StrBnd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_StrBnd(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_StrBnd__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_StrBnd" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_StrBnd();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_E_StrBnd(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_E_StrBnd__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_E_StrBnd__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_E_StrBnd'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_Torsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Torsion" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Torsion" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_Torsion(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_Torsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Torsion" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_Torsion();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_E_Torsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_E_Torsion__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_E_Torsion__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_E_Torsion'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_OOP__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_OOP" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_OOP" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_OOP(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_OOP__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_OOP" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_OOP();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_E_OOP(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_E_OOP__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_E_OOP__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_E_OOP'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_VDW__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_VDW" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_VDW" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_VDW(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_VDW__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_VDW" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_VDW();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_E_VDW(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_E_VDW__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_E_VDW__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_E_VDW'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_Electrostatic__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Electrostatic" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Electrostatic" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_Electrostatic(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_E_Electrostatic__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Electrostatic" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_Electrostatic();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_E_Electrostatic(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_E_Electrostatic__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_E_Electrostatic__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_E_Electrostatic'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SetLogFile(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLogFile" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLogFile" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  result = (bool)(*arg1)->SetLogFile(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SetLogLevel(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLogLevel" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetLogLevel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetLogLevel(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_GetLogLevel(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLogLevel" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (int)(*arg1)->GetLogLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SystematicRotorSearch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SystematicRotorSearch" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (*arg1)->SystematicRotorSearch();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_LineSearch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LineSearch" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LineSearch" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LineSearch" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LineSearch" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (*arg1)->LineSearch(arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SteepestDescent__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescent" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SteepestDescent" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (*arg1)->SteepestDescent(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SteepestDescent__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescent" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->SteepestDescent(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SteepestDescent__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SteepestDescent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_SteepestDescent(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_SteepestDescent__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_pluginiterForceField_SteepestDescent__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterForceField_SteepestDescent__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_SteepestDescent'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SteepestDescentInitialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescentInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SteepestDescentInitialize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (*arg1)->SteepestDescentInitialize(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SteepestDescentInitialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescentInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->SteepestDescentInitialize(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SteepestDescentInitialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SteepestDescentInitialize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SteepestDescentInitialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (*arg1)->SteepestDescentInitialize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_SteepestDescentInitialize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_SteepestDescentInitialize__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_SteepestDescentInitialize__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_pluginiterForceField_SteepestDescentInitialize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterForceField_SteepestDescentInitialize__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_SteepestDescentInitialize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_SteepestDescentTakeNSteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentTakeNSteps" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentTakeNSteps" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SteepestDescentTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ConjugateGradients__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradients" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ConjugateGradients" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (*arg1)->ConjugateGradients(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ConjugateGradients__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradients" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->ConjugateGradients(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ConjugateGradients__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->ConjugateGradients(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_ConjugateGradients(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_ConjugateGradients__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_pluginiterForceField_ConjugateGradients__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterForceField_ConjugateGradients__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_ConjugateGradients'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ConjugateGradientsInitialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradientsInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ConjugateGradientsInitialize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (*arg1)->ConjugateGradientsInitialize(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ConjugateGradientsInitialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradientsInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->ConjugateGradientsInitialize(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ConjugateGradientsInitialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->ConjugateGradientsInitialize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ConjugateGradientsInitialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (*arg1)->ConjugateGradientsInitialize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_ConjugateGradientsInitialize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_ConjugateGradientsInitialize__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_ConjugateGradientsInitialize__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_pluginiterForceField_ConjugateGradientsInitialize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterForceField_ConjugateGradientsInitialize__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_ConjugateGradientsInitialize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ConjugateGradientsTakeNSteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsTakeNSteps" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsTakeNSteps" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->ConjugateGradientsTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_Validate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Validate" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (bool)(*arg1)->Validate();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ValidateGradients(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ValidateGradients" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (bool)(*arg1)->ValidateGradients();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_ValidateGradientError(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ValidateGradientError" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ValidateGradientError" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ValidateGradientError" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ValidateGradientError" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ValidateGradientError" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (*arg1)->ValidateGradientError(*arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_VectorLengthDerivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorLengthDerivative" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorLengthDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorLengthDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VectorLengthDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorLengthDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (double)(*arg1)->VectorLengthDerivative(*arg2,*arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_VectorAngleDerivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorAngleDerivative" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorAngleDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorAngleDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VectorAngleDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorAngleDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "VectorAngleDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorAngleDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (double)(*arg1)->VectorAngleDerivative(*arg2,*arg3,*arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_VectorTorsionDerivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  OpenBabel::vector3 *arg5 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorTorsionDerivative" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorTorsionDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorTorsionDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VectorTorsionDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorTorsionDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "VectorTorsionDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorTorsionDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "VectorTorsionDerivative" "', argument " "5"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorTorsionDerivative" "', argument " "5"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::vector3 * >(argp5);
  result = (double)(*arg1)->VectorTorsionDerivative(*arg2,*arg3,*arg4,*arg5);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_kludge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kludge" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (*arg1)->kludge();
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBError;

SWIGINTERN VALUE
_wrap_new_OBError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  OpenBabel::obMessageLevel arg6 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "OpenBabel::OBError" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "OpenBabel::OBError" "', argument " "6"" of type '" "OpenBabel::obMessageLevel""'");
  } 
  arg6 = static_cast< OpenBabel::obMessageLevel >(val6);
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "OpenBabel::OBError" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_5(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBError_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBError_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBError__SWIG_6(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs;
  if (argc > 6) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBError__SWIG_6(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBError__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_OBError__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_OBError__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_OBError__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_OBError__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_OBError__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBError'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_message(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "message" "', argument " "1"" of type '" "OpenBabel::OBError const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = ((OpenBabel::OBError const *)arg1)->message();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_GetMethod(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMethod" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetMethod();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_GetError(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetError" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetError();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_GetExplanation(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExplanation" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetExplanation();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_GetPossibleCause(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPossibleCause" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetPossibleCause();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_GetSuggestedRemedy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSuggestedRemedy" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetSuggestedRemedy();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_GetLevel(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  OpenBabel::obMessageLevel result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLevel" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (OpenBabel::obMessageLevel)(arg1)->GetLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBError(OpenBabel::OBError *arg1) {
    delete arg1;
}

swig_class cOBMessageHandler;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMessageHandler_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMessageHandler_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMessageHandler);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMessageHandler(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMessageHandler *)new OpenBabel::OBMessageHandler();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMessageHandler(OpenBabel::OBMessageHandler *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMessageHandler_ThrowError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  OpenBabel::OBError arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThrowError" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBError,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThrowError" "', argument " "2"" of type '" "OpenBabel::OBError""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "2"" of type '" "OpenBabel::OBError""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::OBError * >(argp2));
    }
  }
  (arg1)->ThrowError(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_ThrowError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  OpenBabel::obMessageLevel arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThrowError" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThrowError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ThrowError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ThrowError" "', argument " "4"" of type '" "OpenBabel::obMessageLevel""'");
  } 
  arg4 = static_cast< OpenBabel::obMessageLevel >(val4);
  (arg1)->ThrowError((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_ThrowError__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThrowError" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThrowError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ThrowError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->ThrowError((std::string const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMessageHandler_ThrowError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMessageHandler, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBError, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMessageHandler_ThrowError__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMessageHandler, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMessageHandler_ThrowError__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMessageHandler, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMessageHandler_ThrowError__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMessageHandler_ThrowError'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetMessagesOfLevel(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  OpenBabel::obMessageLevel arg2 ;
  std::vector<std::string > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMessagesOfLevel" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetMessagesOfLevel" "', argument " "2"" of type '" "OpenBabel::obMessageLevel""'");
  } 
  arg2 = static_cast< OpenBabel::obMessageLevel >(val2);
  result = (arg1)->GetMessagesOfLevel(arg2);
  vresult = SWIG_NewPointerObj((new std::vector<std::string >(static_cast< const std::vector<std::string >& >(result))), SWIGTYPE_p_std__vectorTstd__string_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_StartLogging(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StartLogging" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  (arg1)->StartLogging();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_StopLogging(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StopLogging" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  (arg1)->StopLogging();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_SetMaxLogEntries(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetMaxLogEntries" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetMaxLogEntries" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetMaxLogEntries(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetMaxLogEntries(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMaxLogEntries" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetMaxLogEntries();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_ClearLog(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearLog" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  (arg1)->ClearLog();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_SetOutputLevel(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  OpenBabel::obMessageLevel arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutputLevel" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetOutputLevel" "', argument " "2"" of type '" "OpenBabel::obMessageLevel""'");
  } 
  arg2 = static_cast< OpenBabel::obMessageLevel >(val2);
  (arg1)->SetOutputLevel(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetOutputLevel(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  OpenBabel::obMessageLevel result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutputLevel" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (OpenBabel::obMessageLevel)(arg1)->GetOutputLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_SetOutputStream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutputStream" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOutputStream" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  (arg1)->SetOutputStream(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetOutputStream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutputStream" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (std::ostream *)(arg1)->GetOutputStream();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_StartErrorWrap(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StartErrorWrap" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (bool)(arg1)->StartErrorWrap();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_StopErrorWrap(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StopErrorWrap" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (bool)(arg1)->StopErrorWrap();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetErrorMessageCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetErrorMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetErrorMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetWarningMessageCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetWarningMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetWarningMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetInfoMessageCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInfoMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetInfoMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetAuditMessageCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAuditMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetAuditMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetDebugMessageCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDebugMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetDebugMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_GetMessageSummary(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMessageSummary" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (arg1)->GetMessageSummary();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
obErrorLog_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::obErrorLog), SWIGTYPE_p_OpenBabel__OBMessageHandler,  0 );
  return _val;
}


SWIGINTERN VALUE
obErrorLog_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBMessageHandler,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::obErrorLog""' of type '""OpenBabel::OBMessageHandler""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::obErrorLog""' of type '""OpenBabel::OBMessageHandler""'");
    } else {
      OpenBabel::obErrorLog = *(reinterpret_cast< OpenBabel::OBMessageHandler * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


swig_class cObLogBuf;

SWIGINTERN void
free_OpenBabel_obLogBuf(OpenBabel::obLogBuf *arg1) {
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_obLogBuf_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_obLogBuf_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__obLogBuf);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_obLogBuf(int argc, VALUE *argv, VALUE self) {
  OpenBabel::obLogBuf *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::obLogBuf *)new OpenBabel::obLogBuf();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


swig_class cOBFormat;

SWIGINTERN VALUE
_wrap_OBFormat_ReadMolecule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBConversion *arg3 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadMolecule" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadMolecule" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ReadMolecule" "', argument " "3"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBConversion * >(argp3);
  result = (bool)(arg1)->ReadMolecule(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_ReadChemObject(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadChemObject" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadChemObject" "', argument " "2"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2);
  result = (bool)(arg1)->ReadChemObject(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_WriteMolecule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBConversion *arg3 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteMolecule" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteMolecule" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "WriteMolecule" "', argument " "3"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBConversion * >(argp3);
  result = (bool)(arg1)->WriteMolecule(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_WriteChemObject(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteChemObject" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteChemObject" "', argument " "2"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2);
  result = (bool)(arg1)->WriteChemObject(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_Description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Description" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (char *)(arg1)->Description();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_TargetClassDescription(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TargetClassDescription" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (char *)(arg1)->TargetClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_GetType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  std::type_info *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  {
    std::type_info const &_result_ref = (arg1)->GetType();
    result = (std::type_info *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__type_info, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_SpecificationURL(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpecificationURL" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (char *)(arg1)->SpecificationURL();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_GetMIMEType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMIMEType" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (char *)(arg1)->GetMIMEType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_Flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Flags" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (unsigned int)(arg1)->Flags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_SkipObjects(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  int arg2 ;
  OpenBabel::OBConversion *arg3 = (OpenBabel::OBConversion *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SkipObjects" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SkipObjects" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SkipObjects" "', argument " "3"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBConversion * >(argp3);
  result = (int)(arg1)->SkipObjects(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_MakeNewInstance(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MakeNewInstance" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (OpenBabel::OBFormat *)(arg1)->MakeNewInstance();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBFormat(OpenBabel::OBFormat *arg1) {
    delete arg1;
}

swig_class cCharPtrLess;

SWIGINTERN VALUE
_wrap_CharPtrLess___call__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::CharPtrLess *arg1 = (OpenBabel::CharPtrLess *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__CharPtrLess, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ()" "', argument " "1"" of type '" "OpenBabel::CharPtrLess const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::CharPtrLess * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "operator ()" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "operator ()" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)((OpenBabel::CharPtrLess const *)arg1)->operator ()((char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CharPtrLess_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CharPtrLess_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__CharPtrLess);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CharPtrLess(int argc, VALUE *argv, VALUE self) {
  OpenBabel::CharPtrLess *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::CharPtrLess *)new OpenBabel::CharPtrLess();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_CharPtrLess(OpenBabel::CharPtrLess *arg1) {
    delete arg1;
}

swig_class cOBConversion;

SWIGINTERN VALUE
_wrap_new_OBConversion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = (std::istream *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  OpenBabel::OBConversion *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion" "', argument " "1"" of type '" "std::istream *""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBConversion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = (std::istream *) 0 ;
  OpenBabel::OBConversion *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion" "', argument " "1"" of type '" "std::istream *""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBConversion__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBConversion_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBConversion_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBConversion);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBConversion__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = 0 ;
  OpenBabel::OBConversion *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBConversion,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion" "', argument " "1"" of type '" "OpenBabel::OBConversion const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBConversion" "', argument " "1"" of type '" "OpenBabel::OBConversion const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion((OpenBabel::OBConversion const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBConversion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBConversion__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBConversion__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBConversion__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__ostream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_OBConversion__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBConversion'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBConversion(OpenBabel::OBConversion *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBConversion_RegisterFormat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  char *arg3 = (char *) 0 ;
  int result;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (int)OpenBabel::OBConversion::RegisterFormat((char const *)arg1,arg2,(char const *)arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_RegisterFormat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  int result;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  result = (int)OpenBabel::OBConversion::RegisterFormat((char const *)arg1,arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_RegisterFormat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_RegisterFormat__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_RegisterFormat__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_RegisterFormat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_FindFormat(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::FindFormat" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::FindFormat((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_FormatFromExt(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::FormatFromExt" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::FormatFromExt((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_FormatFromMIME(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::FormatFromMIME" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::FormatFromMIME((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetNextFormat(int argc, VALUE *argv, VALUE self) {
  OpenBabel::Formatpos *arg1 = 0 ;
  char **arg2 = 0 ;
  OpenBabel::OBFormat **arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__FMapType__iterator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "1"" of type '" "OpenBabel::Formatpos &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "1"" of type '" "OpenBabel::Formatpos &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::Formatpos * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "2"" of type '" "char const *&""'");
  }
  arg2 = &buf2;
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_p_OpenBabel__OBFormat,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "3"" of type '" "OpenBabel::OBFormat *&""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "3"" of type '" "OpenBabel::OBFormat *&""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBFormat ** >(argp3);
  result = (bool)OpenBabel::OBConversion::GetNextFormat(*arg1,(char const *&)*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_Description(int argc, VALUE *argv, VALUE self) {
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (char *)OpenBabel::OBConversion::Description();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetInStream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::istream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInStream" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (std::istream *)((OpenBabel::OBConversion const *)arg1)->GetInStream();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__istream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetOutStream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutStream" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (std::ostream *)((OpenBabel::OBConversion const *)arg1)->GetOutStream();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetInStream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::istream *arg2 = (std::istream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInStream" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInStream" "', argument " "2"" of type '" "std::istream *""'"); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  (arg1)->SetInStream(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetOutStream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutStream" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOutStream" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  (arg1)->SetOutStream(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetInAndOutFormats__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInAndOutFormats" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInAndOutFormats" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetInAndOutFormats" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)(arg1)->SetInAndOutFormats((char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetInAndOutFormats__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBFormat *arg3 = (OpenBabel::OBFormat *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInAndOutFormats" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInAndOutFormats" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetInAndOutFormats" "', argument " "3"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBFormat * >(argp3);
  result = (bool)(arg1)->SetInAndOutFormats(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_SetInAndOutFormats(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_SetInAndOutFormats__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_SetInAndOutFormats__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_SetInAndOutFormats'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetInFormat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInFormat" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->SetInFormat((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetInFormat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInFormat" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  result = (bool)(arg1)->SetInFormat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_SetInFormat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_SetInFormat__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_SetInFormat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_SetInFormat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetOutFormat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOutFormat" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->SetOutFormat((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetOutFormat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOutFormat" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  result = (bool)(arg1)->SetOutFormat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_SetOutFormat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_SetOutFormat__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_SetOutFormat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_SetOutFormat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetInFormat(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBFormat *)((OpenBabel::OBConversion const *)arg1)->GetInFormat();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetOutFormat(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBFormat *)((OpenBabel::OBConversion const *)arg1)->GetOutFormat();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetInFilename(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInFilename" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = ((OpenBabel::OBConversion const *)arg1)->GetInFilename();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetInPos(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::streampos result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInPos" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = ((OpenBabel::OBConversion const *)arg1)->GetInPos();
  vresult = SWIG_NewPointerObj((new std::streampos(static_cast< const std::streampos& >(result))), SWIGTYPE_p_std__streampos, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetInLen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  size_t result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInLen" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = ((OpenBabel::OBConversion const *)arg1)->GetInLen();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetTitle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTitle" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (char *)((OpenBabel::OBConversion const *)arg1)->GetTitle();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetAuxConv(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBConversion *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAuxConv" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBConversion *)((OpenBabel::OBConversion const *)arg1)->GetAuxConv();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetAuxConv(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAuxConv" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAuxConv" "', argument " "2"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2);
  (arg1)->SetAuxConv(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_IsOption__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IsOption" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  result = (char *)(arg1)->IsOption((char const *)arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_IsOption__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->IsOption((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_IsOption(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_IsOption__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBConversion_IsOption__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_IsOption'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetOptions(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBConversion::Option_type arg2 ;
  std::map<std::string,std::string > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOptions" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetOptions" "', argument " "2"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg2 = static_cast< OpenBabel::OBConversion::Option_type >(val2);
  result = (std::map<std::string,std::string > *)(arg1)->GetOptions(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_AddOption__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddOption" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "AddOption" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  (arg1)->AddOption((char const *)arg2,arg3,(char const *)arg4);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_AddOption__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddOption" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  (arg1)->AddOption((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_AddOption(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBConversion_AddOption__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_OBConversion_AddOption__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_AddOption'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_RemoveOption(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoveOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoveOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RemoveOption" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  result = (bool)(arg1)->RemoveOption((char const *)arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetOptions(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOptions" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOptions" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetOptions" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  (arg1)->SetOptions((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_RegisterOptionParam__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  int arg3 ;
  OpenBabel::OBConversion::Option_type arg4 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "4"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg4 = static_cast< OpenBabel::OBConversion::Option_type >(val4);
  OpenBabel::OBConversion::RegisterOptionParam(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_RegisterOptionParam__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  int arg3 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  OpenBabel::OBConversion::RegisterOptionParam(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_RegisterOptionParam__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  OpenBabel::OBConversion::RegisterOptionParam(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_RegisterOptionParam(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_RegisterOptionParam__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBConversion_RegisterOptionParam__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBConversion_RegisterOptionParam__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_RegisterOptionParam'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetOptionParams(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBConversion::Option_type arg2 ;
  int result;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBConversion::GetOptionParams" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBConversion::GetOptionParams" "', argument " "2"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg2 = static_cast< OpenBabel::OBConversion::Option_type >(val2);
  result = (int)OpenBabel::OBConversion::GetOptionParams(arg1,arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetSupportedInputFormat(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::vector<std::string > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSupportedInputFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (arg1)->GetSupportedInputFormat();
  vresult = SWIG_NewPointerObj((new std::vector<std::string >(static_cast< const std::vector<std::string >& >(result))), SWIGTYPE_p_std__vectorTstd__string_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetSupportedOutputFormat(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::vector<std::string > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSupportedOutputFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (arg1)->GetSupportedOutputFormat();
  vresult = SWIG_NewPointerObj((new std::vector<std::string >(static_cast< const std::vector<std::string >& >(result))), SWIGTYPE_p_std__vectorTstd__string_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_Convert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::istream *arg2 = (std::istream *) 0 ;
  std::ostream *arg3 = (std::ostream *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Convert" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Convert" "', argument " "2"" of type '" "std::istream *""'"); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Convert" "', argument " "3"" of type '" "std::ostream *""'"); 
  }
  arg3 = reinterpret_cast< std::ostream * >(argp3);
  result = (int)(arg1)->Convert(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_Convert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Convert" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (int)(arg1)->Convert();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_Convert(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBConversion_Convert__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__istream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__ostream, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_Convert__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_Convert'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_FullConvert(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::vector<std::string > *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::vector<std::string > *arg4 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FullConvert" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FullConvert" "', argument " "2"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FullConvert" "', argument " "2"" of type '" "std::vector<std::string > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::string > * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FullConvert" "', argument " "3"" of type '" "std::string &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FullConvert" "', argument " "3"" of type '" "std::string &""'"); 
  }
  arg3 = reinterpret_cast< std::string * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "FullConvert" "', argument " "4"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FullConvert" "', argument " "4"" of type '" "std::vector<std::string > &""'"); 
  }
  arg4 = reinterpret_cast< std::vector<std::string > * >(argp4);
  result = (int)(arg1)->FullConvert(*arg2,*arg3,*arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_AddChemObject(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddChemObject" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddChemObject" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (bool)(arg1)->AddChemObject(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetChemObject(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChemObject" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBBase *)(arg1)->GetChemObject();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_IsLast(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsLast" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (bool)(arg1)->IsLast();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_IsFirstInput(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsFirstInput" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (bool)(arg1)->IsFirstInput();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetOutputIndex(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutputIndex" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (int)((OpenBabel::OBConversion const *)arg1)->GetOutputIndex();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetOutputIndex(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutputIndex" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetOutputIndex" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetOutputIndex(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetMoreFilesToCome(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetMoreFilesToCome" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  (arg1)->SetMoreFilesToCome();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetOneObjectOnly__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOneObjectOnly" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetOneObjectOnly" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetOneObjectOnly(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetOneObjectOnly__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOneObjectOnly" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  (arg1)->SetOneObjectOnly();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_SetOneObjectOnly(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBConversion_SetOneObjectOnly__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBConversion_SetOneObjectOnly__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_SetOneObjectOnly'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_SetLast(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLast" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetLast" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetLast(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_GetDefaultFormat(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::GetDefaultFormat();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_Write__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::ostream *arg3 = (std::ostream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Write" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Write" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Write" "', argument " "3"" of type '" "std::ostream *""'"); 
  }
  arg3 = reinterpret_cast< std::ostream * >(argp3);
  result = (bool)(arg1)->Write(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_Write__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Write" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Write" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (bool)(arg1)->Write(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_Write(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_Write__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__ostream, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_Write__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_Write'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_WriteString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  bool arg3 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteString" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteString" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "WriteString" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  result = (arg1)->WriteString(arg2,arg3);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_WriteString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteString" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteString" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (arg1)->WriteString(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_WriteString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_WriteString__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBConversion_WriteString__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_WriteString'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_WriteFile(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteFile" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteFile" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "WriteFile" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)(arg1)->WriteFile(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_CloseOutFile(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CloseOutFile" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  (arg1)->CloseOutFile();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_Read__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::istream *arg3 = (std::istream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Read" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Read" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Read" "', argument " "3"" of type '" "std::istream *""'"); 
  }
  arg3 = reinterpret_cast< std::istream * >(argp3);
  result = (bool)(arg1)->Read(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_Read__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Read" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Read" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (bool)(arg1)->Read(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_Read(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_Read__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__istream, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_Read__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_Read'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_ReadString(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadString" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadString" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ReadString" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)(arg1)->ReadString(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_ReadFile(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadFile" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadFile" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ReadFile" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)(arg1)->ReadFile(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBResidue;

SWIGINTERN VALUE
_wrap_new_OBResidue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBResidue *)new OpenBabel::OBResidue();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBResidue_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBResidue_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidue);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBResidue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidue" "', argument " "1"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBResidue" "', argument " "1"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (OpenBabel::OBResidue *)new OpenBabel::OBResidue((OpenBabel::OBResidue const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBResidue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBResidue__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidue__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBResidue'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBResidue(OpenBabel::OBResidue *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBResidue_AddAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->AddAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_InsertAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->InsertAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_RemoveAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoveAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoveAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->RemoveAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (bool)(arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_SetName(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetName" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->SetName((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_SetNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNum" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetNum" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_SetChain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChain" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetChain" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->SetChain(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_SetChainNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChainNum" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetChainNum" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetChainNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_SetAtomID(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomID" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtomID" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetAtomID" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetAtomID" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->SetAtomID(arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_SetHetAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHetAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetHetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetHetAtom" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->SetHetAtom(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_SetSerialNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSerialNum" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetSerialNum" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetSerialNum" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (arg1)->SetSerialNum(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetName(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetName" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = ((OpenBabel::OBResidue const *)arg1)->GetName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNum" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetNumAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNumAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetNumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetChain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  char result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChain" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (char)((OpenBabel::OBResidue const *)arg1)->GetChain();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetChainNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChainNum" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetChainNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetResKey(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResKey" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetResKey();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = ((OpenBabel::OBResidue const *)arg1)->GetAtoms();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBAtom * >(static_cast< const std::vector<OpenBabel::OBAtom * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetBonds__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  bool arg2 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBonds" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetBonds" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = ((OpenBabel::OBResidue const *)arg1)->GetBonds(arg2);
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBBond * >(static_cast< const std::vector<OpenBabel::OBBond * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetBonds__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBonds" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = ((OpenBabel::OBResidue const *)arg1)->GetBonds();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBBond * >(static_cast< const std::vector<OpenBabel::OBBond * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidue_GetBonds(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidue_GetBonds__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidue_GetBonds__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidue_GetBonds'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetAtomID(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomID" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomID" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = ((OpenBabel::OBResidue const *)arg1)->GetAtomID(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetSerialNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSerialNum" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetSerialNum" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetSerialNum(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetAminoAcidProperty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAminoAcidProperty" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAminoAcidProperty" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->GetAminoAcidProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetAtomProperty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomProperty" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomProperty" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAtomProperty" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->GetAtomProperty(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_GetResidueProperty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidueProperty" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetResidueProperty" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->GetResidueProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_IsHetAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHetAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsHetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->IsHetAtom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_IsResidueType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsResidueType" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsResidueType" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->IsResidueType(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_BeginAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (arg1)->BeginAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_EndAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (arg1)->EndAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_BeginAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::vector<OpenBabel::OBAtom * >::iterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->BeginAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_NextAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::vector<OpenBabel::OBAtom * >::iterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->NextAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
Residue_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(OpenBabel::Residue), SWIGTYPE_p_a_4__char,  0 );
  return _val;
}


SWIGINTERN VALUE
Residue_set(VALUE self, VALUE _val) {
  {
    char (*inp)[4] = 0;
    int res = SWIG_ConvertPtr(_val, SWIG_as_voidptrptr(&inp), SWIGTYPE_p_a_4__char,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::Residue""' of type '""char [100][4]""'");
    } else if (inp) {
      size_t ii = 0;
      for (; ii < (size_t)100; ++ii) {
        if (inp[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)4; ++jj) OpenBabel::Residue[ii][jj] = inp[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::Residue""' of type '""char [100][4]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::Residue""' of type '""char [100][4]""'");
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
ElemDesc_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(OpenBabel::ElemDesc), SWIGTYPE_p_a_4__char,  0 );
  return _val;
}


SWIGINTERN VALUE
ElemDesc_set(VALUE self, VALUE _val) {
  {
    char (*inp)[4] = 0;
    int res = SWIG_ConvertPtr(_val, SWIG_as_voidptrptr(&inp), SWIGTYPE_p_a_4__char,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ElemDesc""' of type '""char [1024][4]""'");
    } else if (inp) {
      size_t ii = 0;
      for (; ii < (size_t)1024; ++ii) {
        if (inp[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)4; ++jj) OpenBabel::ElemDesc[ii][jj] = inp[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::ElemDesc""' of type '""char [1024][4]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::ElemDesc""' of type '""char [1024][4]""'");
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
ResNo_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(OpenBabel::ResNo));
  return _val;
}


SWIGINTERN VALUE
ResNo_set(VALUE self, VALUE _val) {
  {
    unsigned int val;
    int res = SWIG_AsVal_unsigned_SS_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ResNo""' of type '""unsigned int""'");
    }
    OpenBabel::ResNo = static_cast< unsigned int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
ElemNo_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(OpenBabel::ElemNo));
  return _val;
}


SWIGINTERN VALUE
ElemNo_set(VALUE self, VALUE _val) {
  {
    unsigned int val;
    int res = SWIG_AsVal_unsigned_SS_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ElemNo""' of type '""unsigned int""'");
    }
    OpenBabel::ElemNo = static_cast< unsigned int >(val);
  }
  return _val;
fail:
  return Qnil;
}


swig_class cOBInternalCoord;

SWIGINTERN VALUE
_wrap_OBInternalCoord__a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_a" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_a" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->_a = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_a" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->_a);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_b" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_b" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->_b = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_b" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->_b);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_c" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_c" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->_c = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_c" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->_c);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__dst_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_dst" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "_dst" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->_dst = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__dst_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_dst" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (double) ((arg1)->_dst);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__ang_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_ang" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "_ang" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->_ang = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__ang_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_ang" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (double) ((arg1)->_ang);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__tor_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_tor" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "_tor" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->_tor = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__tor_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_tor" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (double) ((arg1)->_tor);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBInternalCoord" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBInternalCoord" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "OpenBabel::OBInternalCoord" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "OpenBabel::OBInternalCoord" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3,arg4,arg5,arg6);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double arg4 ;
  double arg5 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBInternalCoord" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBInternalCoord" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "OpenBabel::OBInternalCoord" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3,arg4,arg5);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double arg4 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBInternalCoord" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBInternalCoord" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3,arg4);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBInternalCoord" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_5(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBInternalCoord_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBInternalCoord_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBInternalCoord);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_6(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBInternalCoord(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs;
  if (argc > 6) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBInternalCoord__SWIG_6(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBInternalCoord__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_OBInternalCoord__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_OBInternalCoord__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_OBInternalCoord__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_double(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_OBInternalCoord__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_double(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_double(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_OBInternalCoord__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBInternalCoord'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBInternalCoord(OpenBabel::OBInternalCoord *arg1) {
    delete arg1;
}

swig_class cOBAtom;

SWIGINTERN VALUE
_wrap_OBAtom_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool) ((arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBAtom_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBAtom_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAtom);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBAtom *)new OpenBabel::OBAtom();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAtom(OpenBabel::OBAtom *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBAtom_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IncrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_DecrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_SetType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtom_SetType__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtom_SetType__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_SetType'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_SetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_SetVector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtom_SetVector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBAtom_SetVector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_SetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_UnsetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetAntiClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_UnsetStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_ClearCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (int)((OpenBabel::OBAtom const *)arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned short)((OpenBabel::OBAtom const *)arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (int)((OpenBabel::OBAtom const *)arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetAtomicMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)((OpenBabel::OBAtom const *)arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetExactMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)((OpenBabel::OBAtom const *)arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetCoordinateIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetCIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetHvyValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetHeteroValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (char *)(arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetX(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetY(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetZ(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetCoordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double *)(arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = ((OpenBabel::OBAtom const *)arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_GetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_GetVector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_GetVector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_GetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBResidue *)(arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBMol *)(arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetNewBondVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetNextAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_BeginBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_EndBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_BeginBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_NextBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_BeginNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_NextNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetDistance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetDistance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_GetDistance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtom_GetDistance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtom_GetDistance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_GetDistance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetAngle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_GetAngle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_GetAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBAtom_GetAngle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBAtom_GetAngle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_GetAngle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_NewResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_AddResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_DeleteResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_AddBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_InsertBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_DeleteBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_ClearBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HtoMethyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SetHybAndGeom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_ForceNoH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasNoHForced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_CountFreeOxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_ImplicitHydrogenCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_ExplicitHydrogenCount__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_ExplicitHydrogenCount__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_ExplicitHydrogenCount(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_ExplicitHydrogenCount__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtom_ExplicitHydrogenCount__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_ExplicitHydrogenCount'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_MemberOfRingCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_MemberOfRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_CountRingBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_SmallestBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_AverageBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_BOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_KBOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsCarbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsSulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsPhosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)((OpenBabel::OBAtom const *)arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)((OpenBabel::OBAtom const *)arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsInRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((OpenBabel::OBAtom const *)arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsHeteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsNotCorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsConnected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsOneThree(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsOneFour(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsCarboxylOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsPhosphateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsSulfateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsNitroOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsAmideNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsNonPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsAromaticNOxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsAxial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsAntiClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasChiralitySpecified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasChiralVolume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsHbondAcceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsHbondDonor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_IsHbondDonorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasAlphaBetaUnsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasAlphaBetaUnsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_HasAlphaBetaUnsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_HasAlphaBetaUnsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtom_HasAlphaBetaUnsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_HasAlphaBetaUnsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasBondOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_CountBondsOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasNonSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasDoubleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_HasAromaticBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_MatchesSMARTS(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


swig_class cOBBond;

SWIGINTERN VALUE
_wrap_OBBond_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool) ((arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBBond_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBBond);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBBond *)new OpenBabel::OBBond();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBBond(OpenBabel::OBBond *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBBond_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetBO(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBO" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBO" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetBO(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetBondOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBondOrder" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetBondOrder(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetBegin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBegin" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBegin" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->SetBegin(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetEnd(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnd" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetEnd" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->SetEnd(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetLength(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLength" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLength" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetLength" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->SetLength(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_Set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  int arg5 ;
  int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Set" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Set" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Set" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Set" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  (arg1)->Set(arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetKSingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKSingle" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetKSingle();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetKDouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKDouble" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetKDouble();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetKTriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKTriple" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetKTriple();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetHash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHash" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetWedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetWedge" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetUp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetUp" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetDown(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDown" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_SetClosure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClosure" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetClosure();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_UnsetHash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetHash" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_UnsetWedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetWedge" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_UnsetUp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetUp" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_UnsetDown(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetDown" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_UnsetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_UnsetKekule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetKekule" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetKekule();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetBO(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBO" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetBO();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetBondOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetBondOrder();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetFlags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFlags" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetFlags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetBeginAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetBeginAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetEndAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetEndAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetBeginAtom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetBeginAtom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBBond const *)arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBond_GetBeginAtom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBond_GetBeginAtom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBond_GetBeginAtom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBond_GetBeginAtom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetEndAtom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetEndAtom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBBond const *)arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBond_GetEndAtom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBond_GetEndAtom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBond_GetEndAtom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBond_GetEndAtom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->GetNbrAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBMol *)(arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetEquibLength(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEquibLength" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (double)(arg1)->GetEquibLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetLength(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLength" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (double)(arg1)->GetLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_GetNbrAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtomIdx" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)(arg1)->GetNbrAtomIdx(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)((OpenBabel::OBBond const *)arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)((OpenBabel::OBBond const *)arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsRotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsRotor" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsAmide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmide" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsPrimaryAmide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPrimaryAmide" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsPrimaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsSecondaryAmide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSecondaryAmide" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsSecondaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsEster(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsEster" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsEster();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsCarbonyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbonyl" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsCarbonyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsSingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSingle" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsDouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDouble" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsTriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsTriple" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsKSingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKSingle" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsKSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsKDouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKDouble" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsKDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsKTriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKTriple" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsKTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsClosure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClosure" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsClosure();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsUp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsUp" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsUp();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsDown(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDown" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsDown();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsWedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsWedge" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsWedge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsHash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHash" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsHash();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_IsDoubleBondGeometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDoubleBondGeometry" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsDoubleBondGeometry();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMol;

SWIGINTERN VALUE
_wrap_new_OBMol__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMol *)new OpenBabel::OBMol();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMol_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMol_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMol);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMol__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMol" "', argument " "1"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMol" "', argument " "1"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMol *)new OpenBabel::OBMol((OpenBabel::OBMol const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMol(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMol__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMol__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMol'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMol(OpenBabel::OBMol *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMol_ReserveAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReserveAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ReserveAtoms" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->ReserveAtoms(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_CreateAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->CreateAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_CreateBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBBond *)(arg1)->CreateBond();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_CreateResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBResidue *)(arg1)->CreateResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DestroyAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DestroyAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DestroyAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->DestroyAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DestroyBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DestroyBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DestroyBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (arg1)->DestroyBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DestroyResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DestroyResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DestroyResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (arg1)->DestroyResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAtom,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->AddAtom(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_InsertAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAtom,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->InsertAtom(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddBond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "AddBond" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "AddBond" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "AddBond" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  result = (bool)(arg1)->AddBond(arg2,arg3,arg4,arg5,arg6);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddBond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "AddBond" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "AddBond" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  result = (bool)(arg1)->AddBond(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddBond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "AddBond" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)(arg1)->AddBond(arg2,arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddBond__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBond,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->AddBond(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_AddBond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 7) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_AddBond__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMol_AddBond__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_OBMol_AddBond__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_OBMol_AddBond__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_AddBond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  result = (bool)(arg1)->AddResidue(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NewAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->NewAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NewBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBBond *)(arg1)->NewBond();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NewResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBResidue *)(arg1)->NewResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DeleteAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->DeleteAtom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DeleteBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DeleteResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  result = (bool)(arg1)->DeleteResidue(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_BeginModify(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginModify" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->BeginModify();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_EndModify__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndModify" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EndModify" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->EndModify(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_EndModify__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndModify" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->EndModify();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_EndModify(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_EndModify__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_EndModify__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_EndModify'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetMod(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMod" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (int)(arg1)->GetMod();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_IncrementMod(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementMod" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->IncrementMod();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DecrementMod(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementMod" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->DecrementMod();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetFlags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFlags" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (int)(arg1)->GetFlags();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetTitle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTitle" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (char *)((OpenBabel::OBMol const *)arg1)->GetTitle();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NumAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)((OpenBabel::OBMol const *)arg1)->NumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NumBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumBonds" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)((OpenBabel::OBMol const *)arg1)->NumBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NumHvyAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumHvyAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)(arg1)->NumHvyAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NumResidues(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumResidues" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)((OpenBabel::OBMol const *)arg1)->NumResidues();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NumRotors(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumRotors" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)(arg1)->NumRotors();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAtom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBAtom *)(arg1)->GetAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetFirstAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFirstAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->GetFirstAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetBond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBBond *)(arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetBond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (OpenBabel::OBBond *)(arg1)->GetBond(arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetBond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetBond" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (OpenBabel::OBBond *)(arg1)->GetBond(arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_GetBond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_GetBond__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMol_GetBond__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMol_GetBond__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_GetBond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetResidue" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBResidue *)(arg1)->GetResidue(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetInternalCoord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBInternalCoord * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->GetInternalCoord();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBInternalCoord * >(static_cast< const std::vector<OpenBabel::OBInternalCoord * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetTorsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTorsion" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetTorsion" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetTorsion" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GetTorsion" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "GetTorsion" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  result = (double)(arg1)->GetTorsion(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetTorsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg5 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTorsion" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetTorsion" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetTorsion" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GetTorsion" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "GetTorsion" "', argument " "5"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::OBAtom * >(argp5);
  result = (double)(arg1)->GetTorsion(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_GetTorsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_OBMol_GetTorsion__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_OBMol_GetTorsion__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_GetTorsion'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GetAngle" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  result = (double)(arg1)->GetAngle(arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetFormula(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->GetFormula();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetSpacedFormula__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpacedFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetSpacedFormula" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetSpacedFormula" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (arg1)->GetSpacedFormula(arg2,(char const *)arg3);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetSpacedFormula__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpacedFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetSpacedFormula" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->GetSpacedFormula(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetSpacedFormula__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpacedFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->GetSpacedFormula();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_GetSpacedFormula(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_GetSpacedFormula__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_GetSpacedFormula__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMol_GetSpacedFormula__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_GetSpacedFormula'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetEnergy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnergy" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (double)((OpenBabel::OBMol const *)arg1)->GetEnergy();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetMolWt(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMolWt" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (double)(arg1)->GetMolWt();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetExactMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (double)(arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetTotalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTotalCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (int)(arg1)->GetTotalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetTotalSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTotalSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)(arg1)->GetTotalSpinMultiplicity();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetDimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDimension" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned short)((OpenBabel::OBMol const *)arg1)->GetDimension();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetCoordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinates" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (double *)(arg1)->GetCoordinates();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetSSSR(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBRing * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSSSR" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  {
    std::vector<OpenBabel::OBRing * > &_result_ref = (arg1)->GetSSSR();
    result = (std::vector<OpenBabel::OBRing * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AutomaticFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AutomaticFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AutomaticFormalCharge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AutomaticPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AutomaticPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AutomaticPartialCharge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetTitle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTitle" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetTitle" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetTitle((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetTitle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTitle" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetTitle" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetTitle" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (arg1)->SetTitle(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_SetTitle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_SetTitle__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_SetTitle__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_SetTitle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetFormula(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetFormula" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetFormula(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetEnergy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnergy" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetEnergy" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetEnergy(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetDimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDimension" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetDimension" "', argument " "2"" of type '" "unsigned short""'");
  } 
  arg2 = static_cast< unsigned short >(val2);
  (arg1)->SetDimension(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetTotalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTotalCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetTotalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetTotalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetTotalSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTotalSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetTotalSpinMultiplicity" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetTotalSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetInternalCoord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBInternalCoord * > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * > * >(argp2));
    }
  }
  (arg1)->SetInternalCoord(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetAutomaticFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAutomaticFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAutomaticFormalCharge" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetAutomaticFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetAutomaticPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAutomaticPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAutomaticPartialCharge" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetAutomaticPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetAromaticPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromaticPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetAromaticPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetSSSRPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSSSRPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetSSSRPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetRingAtomsAndBondsPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetRingAtomsAndBondsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetRingAtomsAndBondsPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetAtomTypesPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomTypesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetAtomTypesPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetChainsPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChainsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetChainsPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetChiralityPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiralityPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetChiralityPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetPartialChargesPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialChargesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetPartialChargesPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetHybridizationPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybridizationPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetHybridizationPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetImplicitValencePerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValencePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetImplicitValencePerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetKekulePerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKekulePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetKekulePerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetClosureBondsPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClosureBondsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetClosureBondsPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetHydrogensAdded(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHydrogensAdded" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetHydrogensAdded();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetCorrectedForPH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCorrectedForPH" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetCorrectedForPH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetAromaticCorrected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromaticCorrected" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetAromaticCorrected();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetSpinMultiplicityAssigned(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicityAssigned" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetSpinMultiplicityAssigned();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetFlags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFlags" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFlags" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetFlags(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_UnsetAromaticPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromaticPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->UnsetAromaticPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_UnsetPartialChargesPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetPartialChargesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->UnsetPartialChargesPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_UnsetImplicitValencePerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetImplicitValencePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->UnsetImplicitValencePerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_UnsetHydrogensAdded(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetHydrogensAdded" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->UnsetHydrogensAdded();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_UnsetFlag(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetFlag" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnsetFlag" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->UnsetFlag(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_ClassDescription(int argc, VALUE *argv, VALUE self) {
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (char *)OpenBabel::OBMol::ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_RenumberAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBAtom * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RenumberAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RenumberAtoms" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RenumberAtoms" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * > * >(argp2);
  (arg1)->RenumberAtoms(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_ToInertialFrame__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ToInertialFrame" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ToInertialFrame" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ToInertialFrame" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  (arg1)->ToInertialFrame(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_ToInertialFrame__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ToInertialFrame" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->ToInertialFrame();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_ToInertialFrame(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_ToInertialFrame__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_double, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMol_ToInertialFrame__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_ToInertialFrame'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Translate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (arg1)->Translate((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Translate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Translate" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->Translate((OpenBabel::vector3 const &)*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_Translate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_Translate__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMol_Translate__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_Translate'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Rotate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double (*arg2)[3] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rotate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_a_3__double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotate" "', argument " "2"" of type '" "double const [3][3]""'"); 
  } 
  arg2 = reinterpret_cast< double (*)[3] >(argp2);
  (arg1)->Rotate((double const (*)[3])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Rotate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rotate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotate" "', argument " "2"" of type '" "double const [9]""'"); 
  } 
  arg2 = reinterpret_cast< double * >(argp2);
  (arg1)->Rotate((double const (*))arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Rotate__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rotate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotate" "', argument " "2"" of type '" "double const [9]""'"); 
  } 
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Rotate" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->Rotate((double const (*))arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_Rotate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_a_3__double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_Rotate__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_Rotate__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMol_Rotate__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_Rotate'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Center__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Center" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->Center();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Kekulize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Kekulize" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Kekulize();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_PerceiveKekuleBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerceiveKekuleBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->PerceiveKekuleBonds();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NewPerceiveKekuleBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewPerceiveKekuleBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->NewPerceiveKekuleBonds();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DeleteHydrogens__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->DeleteHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DeleteHydrogens__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteHydrogens" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->DeleteHydrogens(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_DeleteHydrogens(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_DeleteHydrogens__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_DeleteHydrogens__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_DeleteHydrogens'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DeleteNonPolarHydrogens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteNonPolarHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->DeleteNonPolarHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DeleteHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteHydrogen" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->DeleteHydrogen(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddHydrogens__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  bool arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddHydrogens" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddHydrogens" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  result = (bool)(arg1)->AddHydrogens(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddHydrogens__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddHydrogens" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(arg1)->AddHydrogens(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddHydrogens__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AddHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddHydrogens__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddHydrogens" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->AddHydrogens(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_AddHydrogens(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_AddHydrogens__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_AddHydrogens__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_AddHydrogens__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMol_AddHydrogens__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_AddHydrogens'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddPolarHydrogens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddPolarHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AddPolarHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_StripSalts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StripSalts" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->StripSalts();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Separate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  std::vector<OpenBabel::OBMol > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Separate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Separate" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->Separate(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBMol* x = new OpenBabel::OBMol(((std::vector<OpenBabel::OBMol > &)result)[i]);
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBMol, 1));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Separate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBMol > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Separate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->Separate();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBMol* x = new OpenBabel::OBMol(((std::vector<OpenBabel::OBMol > &)result)[i]);
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBMol, 1));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_Separate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_Separate__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_Separate__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_Separate'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_ConvertDativeBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvertDativeBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->ConvertDativeBonds();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_CorrectForPH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectForPH" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->CorrectForPH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AssignSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AssignSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AssignSpinMultiplicity();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Center__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Center" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Center" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->Center(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_Center(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_Center__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_Center__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_Center'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetTorsion(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg5 = (OpenBabel::OBAtom *) 0 ;
  double arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTorsion" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetTorsion" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetTorsion" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SetTorsion" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SetTorsion" "', argument " "5"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::OBAtom * >(argp5);
  ecode6 = SWIG_AsVal_double(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SetTorsion" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  (arg1)->SetTorsion(arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_FindSSSR(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindSSSR" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindSSSR();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_FindRingAtomsAndBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindRingAtomsAndBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindRingAtomsAndBonds();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_FindChiralCenters(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindChiralCenters" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindChiralCenters();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_FindChildren__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<int > *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindChildren" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTint_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindChildren" "', argument " "2"" of type '" "std::vector<int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindChildren" "', argument " "2"" of type '" "std::vector<int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<int > * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "FindChildren" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "FindChildren" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->FindChildren(*arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_FindChildren__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBAtom * > *arg2 = 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindChildren" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindChildren" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindChildren" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * > * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindChildren" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "FindChildren" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  (arg1)->FindChildren(*arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_FindChildren(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTint_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMol_FindChildren__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_OBMol_FindChildren__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_FindChildren'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_FindLargestFragment(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBitVec *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindLargestFragment" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindLargestFragment" "', argument " "2"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindLargestFragment" "', argument " "2"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2);
  (arg1)->FindLargestFragment(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_ContigFragList(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<std::vector<int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ContigFragList" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ContigFragList" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ContigFragList" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<int > > * >(argp2);
  (arg1)->ContigFragList(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Align(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  OpenBabel::vector3 *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Align" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Align" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Align" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Align" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Align" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Align" "', argument " "5"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Align" "', argument " "5"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::vector3 * >(argp5);
  (arg1)->Align(arg2,arg3,*arg4,*arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_ConnectTheDots(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConnectTheDots" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->ConnectTheDots();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_PerceiveBondOrders(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerceiveBondOrders" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->PerceiveBondOrders();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_FindAngles(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindAngles" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindAngles();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_FindTorsions(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindTorsions" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindTorsions();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetGTDVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<int > *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGTDVector" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTint_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetGTDVector" "', argument " "2"" of type '" "std::vector<int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetGTDVector" "', argument " "2"" of type '" "std::vector<int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<int > * >(argp2);
  result = (bool)(arg1)->GetGTDVector(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetGIVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGIVector" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetGIVector" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetGIVector" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  (arg1)->GetGIVector(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetGIDVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGIDVector" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetGIDVector" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetGIDVector" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  (arg1)->GetGIDVector(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Has2D(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Has2D" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Has2D();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Has3D(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Has3D" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Has3D();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasNonZeroCoords(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonZeroCoords" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasNonZeroCoords();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasAromaticPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasAromaticPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasSSSRPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSSSRPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasSSSRPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasRingAtomsAndBondsPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasRingAtomsAndBondsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasRingAtomsAndBondsPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasAtomTypesPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAtomTypesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasAtomTypesPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasChiralityPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralityPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasChiralityPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasPartialChargesPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasPartialChargesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasPartialChargesPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasHybridizationPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasHybridizationPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasHybridizationPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasImplicitValencePerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasImplicitValencePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasImplicitValencePerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasKekulePerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasKekulePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasKekulePerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasClosureBondsPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasClosureBondsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasClosureBondsPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasChainsPerceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChainsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasChainsPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasHydrogensAdded(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasHydrogensAdded" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasHydrogensAdded();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasAromaticCorrected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticCorrected" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasAromaticCorrected();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_IsCorrectedForPH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCorrectedForPH" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->IsCorrectedForPH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_HasSpinMultiplicityAssigned(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSpinMultiplicityAssigned" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasSpinMultiplicityAssigned();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_IsChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_Empty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Empty" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NumConformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumConformers" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (int)(arg1)->NumConformers();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetConformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<double * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetConformers" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTdouble_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetConformers" "', argument " "2"" of type '" "std::vector<double * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetConformers" "', argument " "2"" of type '" "std::vector<double * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<double * > * >(argp2);
  (arg1)->SetConformers(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_AddConformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddConformer" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  (arg1)->AddConformer(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_SetConformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetConformer" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetConformer(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_CopyConformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CopyConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CopyConformer" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CopyConformer" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->CopyConformer(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_DeleteConformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteConformer" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->DeleteConformer(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetConformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetConformer" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double *)(arg1)->GetConformer(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_BeginConformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<double * >::iterator *arg2 = 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTdouble_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginConformer" "', argument " "2"" of type '" "std::vector<double * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginConformer" "', argument " "2"" of type '" "std::vector<double * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<double * >::iterator * >(argp2);
  result = (double *)(arg1)->BeginConformer(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NextConformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<double * >::iterator *arg2 = 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTdouble_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextConformer" "', argument " "2"" of type '" "std::vector<double * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextConformer" "', argument " "2"" of type '" "std::vector<double * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<double * >::iterator * >(argp2);
  result = (double *)(arg1)->NextConformer(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_GetConformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<double * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetConformers" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  {
    std::vector<double * > &_result_ref = (arg1)->GetConformers();
    result = (std::vector<double * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTdouble_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_BeginAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->BeginAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_EndAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->EndAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_BeginBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_EndBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_BeginResidues(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBResidue * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginResidues" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->BeginResidues();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueIterator(static_cast< const OpenBabel::OBResidueIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_EndResidues(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBResidue * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndResidues" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->EndResidues();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueIterator(static_cast< const OpenBabel::OBResidueIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_BeginAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtomIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginAtom" "', argument " "2"" of type '" "OpenBabel::OBAtomIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginAtom" "', argument " "2"" of type '" "OpenBabel::OBAtomIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtomIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->BeginAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NextAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtomIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextAtom" "', argument " "2"" of type '" "OpenBabel::OBAtomIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextAtom" "', argument " "2"" of type '" "OpenBabel::OBAtomIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtomIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->NextAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_BeginBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NextBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_BeginResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidueIterator *arg2 = 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginResidue" "', argument " "2"" of type '" "OpenBabel::OBResidueIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginResidue" "', argument " "2"" of type '" "OpenBabel::OBResidueIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidueIterator * >(argp2);
  result = (OpenBabel::OBResidue *)(arg1)->BeginResidue(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NextResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidueIterator *arg2 = 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextResidue" "', argument " "2"" of type '" "OpenBabel::OBResidueIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextResidue" "', argument " "2"" of type '" "OpenBabel::OBResidueIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidueIterator * >(argp2);
  result = (OpenBabel::OBResidue *)(arg1)->NextResidue(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_BeginInternalCoord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBInternalCoord * >::iterator *arg2 = 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * >::iterator * >(argp2);
  result = (OpenBabel::OBInternalCoord *)(arg1)->BeginInternalCoord(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_NextInternalCoord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBInternalCoord * >::iterator *arg2 = 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * >::iterator * >(argp2);
  result = (OpenBabel::OBInternalCoord *)(arg1)->NextInternalCoord(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::tokenize" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)OpenBabel::tokenize(*arg1,(char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)OpenBabel::tokenize(*arg1,(char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::tokenize" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::tokenize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)OpenBabel::tokenize(*arg1,*arg2,(char const *)arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::tokenize" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)OpenBabel::tokenize(*arg1,*arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  result = (bool)OpenBabel::tokenize(*arg1,*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_tokenize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_tokenize__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_tokenize__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_tokenize__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_tokenize__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_tokenize__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'tokenize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThrowError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::ThrowError" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  OpenBabel::ThrowError(arg1);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThrowError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::ThrowError" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::ThrowError" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  OpenBabel::ThrowError(*arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ThrowError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__string, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ThrowError__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ThrowError__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'ThrowError'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CartesianToInternal(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBInternalCoord * > *arg1 = 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::CartesianToInternal" "', argument " "1"" of type '" "std::vector<OpenBabel::OBInternalCoord * > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CartesianToInternal" "', argument " "1"" of type '" "std::vector<OpenBabel::OBInternalCoord * > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::CartesianToInternal" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CartesianToInternal" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  OpenBabel::CartesianToInternal(*arg1,*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InternalToCartesian(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBInternalCoord * > *arg1 = 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::InternalToCartesian" "', argument " "1"" of type '" "std::vector<OpenBabel::OBInternalCoord * > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::InternalToCartesian" "', argument " "1"" of type '" "std::vector<OpenBabel::OBInternalCoord * > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::InternalToCartesian" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::InternalToCartesian" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  OpenBabel::InternalToCartesian(*arg1,*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_NewExtension(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::NewExtension" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::NewExtension" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::NewExtension" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = OpenBabel::NewExtension(*arg1,arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
etab_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::etab), SWIGTYPE_p_OpenBabel__OBElementTable,  0 );
  return _val;
}


SWIGINTERN VALUE
etab_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBElementTable,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::etab""' of type '""OpenBabel::OBElementTable""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::etab""' of type '""OpenBabel::OBElementTable""'");
    } else {
      OpenBabel::etab = *(reinterpret_cast< OpenBabel::OBElementTable * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
ttab_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::ttab), SWIGTYPE_p_OpenBabel__OBTypeTable,  0 );
  return _val;
}


SWIGINTERN VALUE
ttab_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBTypeTable,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ttab""' of type '""OpenBabel::OBTypeTable""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::ttab""' of type '""OpenBabel::OBTypeTable""'");
    } else {
      OpenBabel::ttab = *(reinterpret_cast< OpenBabel::OBTypeTable * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
isotab_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::isotab), SWIGTYPE_p_OpenBabel__OBIsotopeTable,  0 );
  return _val;
}


SWIGINTERN VALUE
isotab_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBIsotopeTable,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::isotab""' of type '""OpenBabel::OBIsotopeTable""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::isotab""' of type '""OpenBabel::OBIsotopeTable""'");
    } else {
      OpenBabel::isotab = *(reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
aromtyper_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::aromtyper), SWIGTYPE_p_OpenBabel__OBAromaticTyper,  0 );
  return _val;
}


SWIGINTERN VALUE
aromtyper_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBAromaticTyper,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::aromtyper""' of type '""OpenBabel::OBAromaticTyper""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::aromtyper""' of type '""OpenBabel::OBAromaticTyper""'");
    } else {
      OpenBabel::aromtyper = *(reinterpret_cast< OpenBabel::OBAromaticTyper * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
atomtyper_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::atomtyper), SWIGTYPE_p_OpenBabel__OBAtomTyper,  0 );
  return _val;
}


SWIGINTERN VALUE
atomtyper_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBAtomTyper,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::atomtyper""' of type '""OpenBabel::OBAtomTyper""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::atomtyper""' of type '""OpenBabel::OBAtomTyper""'");
    } else {
      OpenBabel::atomtyper = *(reinterpret_cast< OpenBabel::OBAtomTyper * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
chainsparser_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::chainsparser), SWIGTYPE_p_OpenBabel__OBChainsParser,  0 );
  return _val;
}


SWIGINTERN VALUE
chainsparser_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBChainsParser,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::chainsparser""' of type '""OpenBabel::OBChainsParser""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::chainsparser""' of type '""OpenBabel::OBChainsParser""'");
    } else {
      OpenBabel::chainsparser = *(reinterpret_cast< OpenBabel::OBChainsParser * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
resdat_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::resdat), SWIGTYPE_p_OpenBabel__OBResidueData,  0 );
  return _val;
}


SWIGINTERN VALUE
resdat_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBResidueData,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::resdat""' of type '""OpenBabel::OBResidueData""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::resdat""' of type '""OpenBabel::OBResidueData""'");
    } else {
      OpenBabel::resdat = *(reinterpret_cast< OpenBabel::OBResidueData * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_get_rmat(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::get_rmat" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = reinterpret_cast< double * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::get_rmat" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::get_rmat" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::get_rmat" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  OpenBabel::get_rmat(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ob_make_rmat(int argc, VALUE *argv, VALUE self) {
  double (*arg1)[3] ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_3__double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::ob_make_rmat" "', argument " "1"" of type '" "double [3][3]""'"); 
  } 
  arg1 = reinterpret_cast< double (*)[3] >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::ob_make_rmat" "', argument " "2"" of type '" "double [9]""'"); 
  } 
  arg2 = reinterpret_cast< double * >(argp2);
  OpenBabel::ob_make_rmat((double (*)[3])arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_qtrfit(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  double (*arg4)[3] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::qtrfit" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = reinterpret_cast< double * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::qtrfit" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::qtrfit" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_a_3__double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::qtrfit" "', argument " "4"" of type '" "double [3][3]""'"); 
  } 
  arg4 = reinterpret_cast< double (*)[3] >(argp4);
  OpenBabel::qtrfit(arg1,arg2,arg3,(double (*)[3])arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_superimpose(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::superimpose" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = reinterpret_cast< double * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::superimpose" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::superimpose" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)OpenBabel::superimpose(arg1,arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBRing;

SWIGINTERN VALUE
_wrap_OBRing__path_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  std::vector<int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_path" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  if (arg1) (arg1)->_path = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing__path_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  std::vector<int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_path" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  {
    std::vector<int > const &_result_ref =  ((arg1)->_path);
    result = (std::vector<int > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing__pathset_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBBitVec *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_pathset" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_pathset" "', argument " "2"" of type '" "OpenBabel::OBBitVec const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_pathset" "', argument " "2"" of type '" "OpenBabel::OBBitVec const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2);
  if (arg1) (arg1)->_pathset = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing__pathset_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBBitVec *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_pathset" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  {
    OpenBabel::OBBitVec const &_result_ref =  ((arg1)->_pathset);
    result = (OpenBabel::OBBitVec *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBitVec, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBRing__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBRing__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = 0 ;
  int arg2 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTint_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "std::vector<int > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "std::vector<int > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBRing" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing(*arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBRing__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = 0 ;
  OpenBabel::OBBitVec arg2 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTint_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "std::vector<int > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "std::vector<int > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBRing" "', argument " "2"" of type '" "OpenBabel::OBBitVec""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRing" "', argument " "2"" of type '" "OpenBabel::OBBitVec""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::OBBitVec * >(argp2));
    }
  }
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing(*arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRing_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRing_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRing);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRing__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBRing,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing((OpenBabel::OBRing const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBRing(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBRing__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBRing, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBRing__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBitVec, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_OBRing__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBRing__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBRing'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_Size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Size" "', argument " "1"" of type '" "OpenBabel::OBRing const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (int)((OpenBabel::OBRing const *)arg1)->Size();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_PathSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSize" "', argument " "1"" of type '" "OpenBabel::OBRing const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (int)((OpenBabel::OBRing const *)arg1)->PathSize();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (bool)(arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_IsMember__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsMember" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsMember" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_IsMember__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsMember" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsMember" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBRing_IsMember(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBRing, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBRing_IsMember__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBRing, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBRing_IsMember__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBRing_IsMember'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRing" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->IsInRing(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (OpenBabel::OBMol *)(arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_findCenterAndNormal(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "findCenterAndNormal" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "findCenterAndNormal" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "findCenterAndNormal" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "findCenterAndNormal" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (bool)(arg1)->findCenterAndNormal(*arg2,*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRing(OpenBabel::OBRing *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_CompareRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBRing *arg2 = (OpenBabel::OBRing *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::CompareRingSize" "', argument " "1"" of type '" "OpenBabel::OBRing const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::CompareRingSize" "', argument " "2"" of type '" "OpenBabel::OBRing const *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2);
  result = (bool)OpenBabel::CompareRingSize((OpenBabel::OBRing const *)arg1,(OpenBabel::OBRing const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBRingSearch;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRingSearch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRingSearch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRingSearch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRingSearch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBRingSearch *)new OpenBabel::OBRingSearch();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRingSearch(OpenBabel::OBRingSearch *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBRingSearch_SortRings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SortRings" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  (arg1)->SortRings();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_RemoveRedundant(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoveRedundant" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RemoveRedundant" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->RemoveRedundant(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_AddRingFromClosure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddRingFromClosure" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddRingFromClosure" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddRingFromClosure" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AddRingFromClosure" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (arg1)->AddRingFromClosure(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_SaveUniqueRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  std::deque<int > *arg2 = 0 ;
  std::deque<int > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SaveUniqueRing" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__dequeTint_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SaveUniqueRing" "', argument " "2"" of type '" "std::deque<int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SaveUniqueRing" "', argument " "2"" of type '" "std::deque<int > &""'"); 
  }
  arg2 = reinterpret_cast< std::deque<int > * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__dequeTint_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SaveUniqueRing" "', argument " "3"" of type '" "std::deque<int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SaveUniqueRing" "', argument " "3"" of type '" "std::deque<int > &""'"); 
  }
  arg3 = reinterpret_cast< std::deque<int > * >(argp3);
  result = (bool)(arg1)->SaveUniqueRing(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_WriteRings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteRings" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  (arg1)->WriteRings();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_BeginRings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBRing * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginRings" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  result = (arg1)->BeginRings();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBRing * >::iterator(static_cast< const std::vector<OpenBabel::OBRing * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_EndRings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBRing * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndRings" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  result = (arg1)->EndRings();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBRing * >::iterator(static_cast< const std::vector<OpenBabel::OBRing * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBRTree;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRTree_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRTree_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRTree);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRTree(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBRTree *arg2 = (OpenBabel::OBRTree *) 0 ;
  OpenBabel::OBRTree *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRTree" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBRTree, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBRTree" "', argument " "2"" of type '" "OpenBabel::OBRTree *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRTree * >(argp2);
  result = (OpenBabel::OBRTree *)new OpenBabel::OBRTree(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRTree(OpenBabel::OBRTree *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBRTree_GetAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRTree *arg1 = (OpenBabel::OBRTree *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBRTree *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRTree * >(argp1);
  result = (int)(arg1)->GetAtomIdx();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRTree_PathToRoot(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRTree *arg1 = (OpenBabel::OBRTree *) 0 ;
  std::vector<OpenBabel::OBAtom * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathToRoot" "', argument " "1"" of type '" "OpenBabel::OBRTree *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRTree * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathToRoot" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PathToRoot" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * > * >(argp2);
  (arg1)->PathToRoot(*arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBSmartsPattern;

SWIGINTERN VALUE
_wrap_new_OBSmartsPattern__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSmartsPattern *)new OpenBabel::OBSmartsPattern();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSmartsPattern(OpenBabel::OBSmartsPattern *arg1) {
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSmartsPattern_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSmartsPattern_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSmartsPattern);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSmartsPattern__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = 0 ;
  OpenBabel::OBSmartsPattern *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBSmartsPattern,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBSmartsPattern" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBSmartsPattern" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (OpenBabel::OBSmartsPattern *)new OpenBabel::OBSmartsPattern((OpenBabel::OBSmartsPattern const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBSmartsPattern(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBSmartsPattern__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBSmartsPattern__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBSmartsPattern'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_Init__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Init" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Init" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->Init((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_Init__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Init" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Init" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Init" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->Init((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSmartsPattern_Init(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSmartsPattern_Init__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSmartsPattern_Init__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSmartsPattern_Init'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_GetSMARTS__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSMARTS" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBSmartsPattern const *)arg1)->GetSMARTS();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_GetSMARTS__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSMARTS" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::string &_result_ref = (arg1)->GetSMARTS();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSmartsPattern_GetSMARTS(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBSmartsPattern_GetSMARTS__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBSmartsPattern_GetSMARTS__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSmartsPattern_GetSMARTS'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_Empty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Empty" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (bool)((OpenBabel::OBSmartsPattern const *)arg1)->Empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_IsValid(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsValid" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (bool)((OpenBabel::OBSmartsPattern const *)arg1)->IsValid();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_NumAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumAtoms" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (unsigned int)((OpenBabel::OBSmartsPattern const *)arg1)->NumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_NumBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumBonds" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (unsigned int)((OpenBabel::OBSmartsPattern const *)arg1)->NumBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_GetBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  int *arg2 = 0 ;
  int *arg3 = 0 ;
  int *arg4 = 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "int &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetBond" "', argument " "2"" of type '" "int &""'"); 
  }
  arg2 = reinterpret_cast< int * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetBond" "', argument " "3"" of type '" "int &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetBond" "', argument " "3"" of type '" "int &""'"); 
  }
  arg3 = reinterpret_cast< int * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GetBond" "', argument " "4"" of type '" "int &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetBond" "', argument " "4"" of type '" "int &""'"); 
  }
  arg4 = reinterpret_cast< int * >(argp4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "GetBond" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  (arg1)->GetBond(*arg2,*arg3,*arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_GetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->GetAtomicNum(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_GetCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCharge" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->GetCharge(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_GetVectorBinding(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVectorBinding" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetVectorBinding" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)((OpenBabel::OBSmartsPattern const *)arg1)->GetVectorBinding(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_Match__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Match" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Match" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Match" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Match" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  result = (bool)(arg1)->Match(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_Match__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Match" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Match" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Match" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(arg1)->Match(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSmartsPattern_Match(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSmartsPattern_Match__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBSmartsPattern_Match__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSmartsPattern_Match'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_RestrictedMatch__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  std::vector<std::pair<int,int > > *arg3 = 0 ;
  bool arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RestrictedMatch" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RestrictedMatch" "', argument " "3"" of type '" "std::vector<std::pair<int,int > > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "3"" of type '" "std::vector<std::pair<int,int > > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<std::pair<int,int > > * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RestrictedMatch" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_RestrictedMatch__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  std::vector<std::pair<int,int > > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RestrictedMatch" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RestrictedMatch" "', argument " "3"" of type '" "std::vector<std::pair<int,int > > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "3"" of type '" "std::vector<std::pair<int,int > > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<std::pair<int,int > > * >(argp3);
  result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_RestrictedMatch__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBitVec *arg3 = 0 ;
  bool arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RestrictedMatch" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RestrictedMatch" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RestrictedMatch" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_RestrictedMatch__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBitVec *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RestrictedMatch" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RestrictedMatch" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3);
  result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSmartsPattern_RestrictedMatch(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBSmartsPattern_RestrictedMatch__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBBitVec, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBSmartsPattern_RestrictedMatch__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBBitVec, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBSmartsPattern_RestrictedMatch__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBSmartsPattern_RestrictedMatch__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSmartsPattern_RestrictedMatch'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_NumMatches(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumMatches" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (unsigned int)((OpenBabel::OBSmartsPattern const *)arg1)->NumMatches();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_GetMapList(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::vector<std::vector<int > > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMapList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::vector<std::vector<int > > &_result_ref = (arg1)->GetMapList();
    result = (std::vector<std::vector<int > > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_BeginMList(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  SwigValueWrapper<std::vector<std::vector<int > >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginMList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (arg1)->BeginMList();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<int > >::iterator(static_cast< const std::vector<std::vector<int > >::iterator& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTint_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_EndMList(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  SwigValueWrapper<std::vector<std::vector<int > >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndMList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (arg1)->EndMList();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<int > >::iterator(static_cast< const std::vector<std::vector<int > >::iterator& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTint_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_GetUMapList(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::vector<std::vector<int > > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetUMapList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::vector<std::vector<int > > &_result_ref = (arg1)->GetUMapList();
    result = (std::vector<std::vector<int > > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_WriteMapList(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteMapList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteMapList" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "WriteMapList" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  (arg1)->WriteMapList(*arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBSSMatch;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSSMatch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSSMatch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSSMatch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSSMatch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = 0 ;
  OpenBabel::Pattern *arg2 = (OpenBabel::Pattern *) 0 ;
  OpenBabel::OBSSMatch *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBSSMatch" "', argument " "1"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBSSMatch" "', argument " "1"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__Pattern, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBSSMatch" "', argument " "2"" of type '" "OpenBabel::Pattern *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::Pattern * >(argp2);
  result = (OpenBabel::OBSSMatch *)new OpenBabel::OBSSMatch(*arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSSMatch(OpenBabel::OBSSMatch *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBSSMatch_Match__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSSMatch *arg1 = (OpenBabel::OBSSMatch *) 0 ;
  std::vector<std::vector<int > > *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSSMatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Match" "', argument " "1"" of type '" "OpenBabel::OBSSMatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSSMatch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Match" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Match" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<int > > * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Match" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->Match(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSSMatch_Match__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSSMatch *arg1 = (OpenBabel::OBSSMatch *) 0 ;
  std::vector<std::vector<int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSSMatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Match" "', argument " "1"" of type '" "OpenBabel::OBSSMatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSSMatch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Match" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Match" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<int > > * >(argp2);
  (arg1)->Match(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSSMatch_Match(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSSMatch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSSMatch_Match__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSSMatch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBSSMatch_Match__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSSMatch_Match'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SmartsLexReplace(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::vector<std::pair<std::string,std::string > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::SmartsLexReplace" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::SmartsLexReplace" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorTstd__pairTstd__string_std__string_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::SmartsLexReplace" "', argument " "2"" of type '" "std::vector<std::pair<std::string,std::string > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::SmartsLexReplace" "', argument " "2"" of type '" "std::vector<std::pair<std::string,std::string > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::pair<std::string,std::string > > * >(argp2);
  OpenBabel::SmartsLexReplace(*arg1,*arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBFingerprint;

SWIGINTERN VALUE
_wrap_OBFingerprint_Iter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    OpenBabel::PluginIter<OpenBabel::OBFingerprint > &_result_ref = OpenBabel::OBFingerprint::Iter();
    result = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_FindDefaultType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBFingerprint *)OpenBabel::OBFingerprint::FindDefaultType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_FindType(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBFingerprint::FindType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBFingerprint::FindType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBFingerprint *)OpenBabel::OBFingerprint::FindType((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBFingerprint(OpenBabel::OBFingerprint *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBFingerprint_SetBit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBit" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBit" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetBit" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetBit" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (arg1)->SetBit(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_Fold(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Fold" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Fold" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Fold" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Fold" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (arg1)->Fold(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_GetFingerprint__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetFingerprint" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GetFingerprint" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)(arg1)->GetFingerprint(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_GetFingerprint__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetFingerprint" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  result = (bool)(arg1)->GetFingerprint(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBFingerprint_GetFingerprint(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBFingerprint, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBFingerprint_GetFingerprint__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBFingerprint, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBFingerprint_GetFingerprint__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBFingerprint_GetFingerprint'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_Description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Description" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  result = (arg1)->Description();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_Flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Flags" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  result = (unsigned int)(arg1)->Flags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_Tanimoto__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  double result;
  std::vector<unsigned int > temp1 ;
  std::vector<unsigned int > temp2 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (double)OpenBabel::OBFingerprint::Tanimoto((std::vector<unsigned int > const &)*arg1,(std::vector<unsigned int > const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_Tanimoto__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  double result;
  std::vector<unsigned int > temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBFingerprint::Tanimoto" "', argument " "2"" of type '" "unsigned int const *""'"); 
  }
  arg2 = reinterpret_cast< unsigned int * >(argp2);
  result = (double)OpenBabel::OBFingerprint::Tanimoto((std::vector<unsigned int > const &)*arg1,(unsigned int const *)arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBFingerprint_Tanimoto(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (FIXNUM_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<unsigned int >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_unsigned_int, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBFingerprint_Tanimoto__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (FIXNUM_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<unsigned int >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      {
        /* native sequence? */
        if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
          unsigned int size = RARRAY_LEN(argv[1]);
          if (size == 0) {
            /* an empty sequence can be of any type */
            _v = 1;
          } else {
            /* check the first element only */
            VALUE o = RARRAY_PTR(argv[1])[0];
            if (FIXNUM_P(o))
            _v = 1;
            else
            _v = 0;
          }
        } else {
          /* wrapped vector? */
          std::vector<unsigned int >* v;
          if (SWIG_ConvertPtr(argv[1],(void **) &v, 
              SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
          _v = 1;
          else
          _v = 0;
        }
      }
      if (_v) {
        return _wrap_OBFingerprint_Tanimoto__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBFingerprint_Tanimoto'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_Getbitsperint(int argc, VALUE *argv, VALUE self) {
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (unsigned int)OpenBabel::OBFingerprint::Getbitsperint();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_FindFingerprint(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBFingerprint::FindFingerprint" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBFingerprint::FindFingerprint" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBFingerprint *)OpenBabel::OBFingerprint::FindFingerprint((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


swig_class cFptIndexHeader;

SWIGINTERN VALUE
_wrap_FptIndexHeader_headerlength_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "headerlength" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "headerlength" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->headerlength = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_headerlength_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "headerlength" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (unsigned int) ((arg1)->headerlength);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_nEntries_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "nEntries" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "nEntries" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->nEntries = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_nEntries_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "nEntries" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (unsigned int) ((arg1)->nEntries);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_words_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "words" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "words" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->words = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_words_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "words" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (unsigned int) ((arg1)->words);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_fpid_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[16] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fpid" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, 16);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fpid" "', argument " "2"" of type '" "char [16]""'");
  }
  arg2 = reinterpret_cast< char * >(temp2);
  if (arg2) memcpy(arg1->fpid,arg2,16*sizeof(char));
  else memset(arg1->fpid,0,16*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_fpid_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fpid" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (char *)(char *) ((arg1)->fpid);
  {
    size_t size = 16;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_datafilename_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[256] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "datafilename" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, 256);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "datafilename" "', argument " "2"" of type '" "char [256]""'");
  }
  arg2 = reinterpret_cast< char * >(temp2);
  if (arg2) memcpy(arg1->datafilename,arg2,256*sizeof(char));
  else memset(arg1->datafilename,0,256*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_datafilename_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "datafilename" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (char *)(char *) ((arg1)->datafilename);
  {
    size_t size = 256;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FptIndexHeader_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FptIndexHeader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FptIndexHeader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FptIndexHeader(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::FptIndexHeader *)new OpenBabel::FptIndexHeader();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_FptIndexHeader(OpenBabel::FptIndexHeader *arg1) {
    delete arg1;
}

swig_class cFptIndex;

SWIGINTERN VALUE
_wrap_FptIndex_header_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  OpenBabel::FptIndexHeader *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "header" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__FptIndexHeader,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "header" "', argument " "2"" of type '" "OpenBabel::FptIndexHeader const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "header" "', argument " "2"" of type '" "OpenBabel::FptIndexHeader const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp2);
  if (arg1) (arg1)->header = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_header_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  OpenBabel::FptIndexHeader *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "header" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    OpenBabel::FptIndexHeader const &_result_ref =  ((arg1)->header);
    result = (OpenBabel::FptIndexHeader *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_fptdata_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<unsigned int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fptdata" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  if (arg1) (arg1)->fptdata = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_fptdata_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::vector<unsigned int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fptdata" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    std::vector<unsigned int > const &_result_ref =  ((arg1)->fptdata);
    result = (std::vector<unsigned int > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_seekdata_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<unsigned int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "seekdata" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  if (arg1) (arg1)->seekdata = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_seekdata_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::vector<unsigned int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "seekdata" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    std::vector<unsigned int > const &_result_ref =  ((arg1)->seekdata);
    result = (std::vector<unsigned int > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_Read(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::istream *arg2 = (std::istream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Read" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Read" "', argument " "2"" of type '" "std::istream *""'"); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  result = (bool)(arg1)->Read(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_CheckFP(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CheckFP" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  result = (OpenBabel::OBFingerprint *)(arg1)->CheckFP();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FptIndex_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FptIndex_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FptIndex);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FptIndex(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::FptIndex *)new OpenBabel::FptIndex();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_FptIndex(OpenBabel::FptIndex *arg1) {
    delete arg1;
}

swig_class cFastSearch;

SWIGINTERN VALUE
_wrap_FastSearch_ReadIndexFile(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  std::string arg2 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadIndexFile" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ReadIndexFile" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (arg1)->ReadIndexFile(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_ReadIndex(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  std::istream *arg2 = (std::istream *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadIndex" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadIndex" "', argument " "2"" of type '" "std::istream *""'"); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  result = (arg1)->ReadIndex(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_FastSearch(OpenBabel::FastSearch *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FastSearch_Find(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  unsigned int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Find" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Find" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Find" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Find" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Find" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (bool)(arg1)->Find(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_FindMatch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  unsigned int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindMatch" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindMatch" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindMatch" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindMatch" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "FindMatch" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (bool)(arg1)->FindMatch(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_FindSimilar__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::multimap<double,unsigned int > *arg3 = 0 ;
  double arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindSimilar" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindSimilar" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::multimap<double,unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "FindSimilar" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  result = (bool)(arg1)->FindSimilar(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_FindSimilar__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::multimap<double,unsigned int > *arg3 = 0 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindSimilar" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindSimilar" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::multimap<double,unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "FindSimilar" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)(arg1)->FindSimilar(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_FindSimilar__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::multimap<double,unsigned int > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindSimilar" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindSimilar" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::multimap<double,unsigned int > * >(argp3);
  result = (bool)(arg1)->FindSimilar(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FastSearch_FindSimilar(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__FastSearch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_FastSearch_FindSimilar__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__FastSearch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FastSearch_FindSimilar__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__FastSearch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FastSearch_FindSimilar__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'FastSearch_FindSimilar'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_GetFingerprint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::FastSearch const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  result = (OpenBabel::OBFingerprint *)((OpenBabel::FastSearch const *)arg1)->GetFingerprint();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_GetIndexHeader(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::FptIndexHeader *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIndexHeader" "', argument " "1"" of type '" "OpenBabel::FastSearch const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  {
    OpenBabel::FptIndexHeader const &_result_ref = ((OpenBabel::FastSearch const *)arg1)->GetIndexHeader();
    result = (OpenBabel::FptIndexHeader *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FastSearch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FastSearch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FastSearch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FastSearch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::FastSearch *)new OpenBabel::FastSearch();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


swig_class cFastSearchIndexer;

SWIGINTERN VALUE
_wrap_new_FastSearchIndexer__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  std::string *arg3 = 0 ;
  int arg4 ;
  OpenBabel::FastSearchIndexer *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "3"" of type '" "std::string &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::FastSearchIndexer" "', argument " "3"" of type '" "std::string &""'"); 
  }
  arg3 = reinterpret_cast< std::string * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (OpenBabel::FastSearchIndexer *)new OpenBabel::FastSearchIndexer(*arg1,arg2,*arg3,arg4);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FastSearchIndexer__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  std::string *arg3 = 0 ;
  OpenBabel::FastSearchIndexer *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "3"" of type '" "std::string &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::FastSearchIndexer" "', argument " "3"" of type '" "std::string &""'"); 
  }
  arg3 = reinterpret_cast< std::string * >(argp3);
  result = (OpenBabel::FastSearchIndexer *)new OpenBabel::FastSearchIndexer(*arg1,arg2,*arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FastSearchIndexer_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FastSearchIndexer_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FastSearchIndexer);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FastSearchIndexer__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  OpenBabel::FastSearchIndexer *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  result = (OpenBabel::FastSearchIndexer *)new OpenBabel::FastSearchIndexer(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FastSearchIndexer(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__FptIndex, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__ostream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FastSearchIndexer__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__string, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__ostream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__string, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_FastSearchIndexer__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__string, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__ostream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__string, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_FastSearchIndexer__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_FastSearchIndexer'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_FastSearchIndexer(OpenBabel::FastSearchIndexer *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FastSearchIndexer_Add(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearchIndexer *arg1 = (OpenBabel::FastSearchIndexer *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::streampos arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearchIndexer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Add" "', argument " "1"" of type '" "OpenBabel::FastSearchIndexer *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearchIndexer * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Add" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__streampos,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Add" "', argument " "3"" of type '" "std::streampos""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Add" "', argument " "3"" of type '" "std::streampos""'");
    } else {
      arg3 = *(reinterpret_cast< std::streampos * >(argp3));
    }
  }
  result = (bool)(arg1)->Add(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBFFParameter;

SWIGINTERN VALUE
_wrap_OBFFParameter_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "a" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "a" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->a = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "a" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->a);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "b" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "b" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->b = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "b" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->b);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "c" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "c" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->c = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "c" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->c);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "d" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "d" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->d = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "d" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->d);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_a" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_a" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_a" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->_a = *arg2;
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_a" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->_a);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_b" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_b" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_b" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->_b = *arg2;
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_b" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->_b);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_c" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_c" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_c" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->_c = *arg2;
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_c" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->_c);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_d" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_d" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_d" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->_d = *arg2;
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_d" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->_d);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar1_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar1" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar1" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar1 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar1_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar1" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar1);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar2_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar2" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar2" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar2 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar2_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar2" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar3_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar3" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar3" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar3 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar3_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar3" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar4_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar4" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar4" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar4 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar4_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar4" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar4);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar5_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar5" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar5" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar5 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar5_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar5" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar5);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar1_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar1" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar1" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar1 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar1_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar1" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar1);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar2_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar2" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar2" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar2 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar2_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar2" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar3_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar3" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar3" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar3 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar3_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar3" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar4_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar4" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar4" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar4 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar4_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar4" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar5_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar5" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar5" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar5 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar5_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar5" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar5);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBFFParameter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBFFParameter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFParameter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBFFParameter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBFFParameter *)new OpenBabel::OBFFParameter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBFFParameter(OpenBabel::OBFFParameter *arg1) {
    delete arg1;
}

swig_class cOBFFCalculation;

SWIGINTERN VALUE
_wrap_OBFFCalculation_energy_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "energy" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "energy" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->energy = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_energy_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "energy" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (double) ((arg1)->energy);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_grada_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "grada" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "grada" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "grada" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  if (arg1) (arg1)->grada = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_grada_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "grada" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref =  ((arg1)->grada);
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradb_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradb" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gradb" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gradb" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  if (arg1) (arg1)->gradb = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradb_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradb" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref =  ((arg1)->gradb);
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradc_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradc" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gradc" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gradc" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  if (arg1) (arg1)->gradc = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradc_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradc" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref =  ((arg1)->gradc);
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradd_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradd" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gradd" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gradd" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  if (arg1) (arg1)->gradd = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradd_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradd" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref =  ((arg1)->gradd);
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "a" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "a" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->a = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "a" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->a);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "b" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "b" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->b = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "b" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->b);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "c" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "c" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->c = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "c" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->c);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "d" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "d" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->d = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "d" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->d);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBFFCalculation_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBFFCalculation_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFCalculation);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBFFCalculation(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBFFCalculation *)new OpenBabel::OBFFCalculation();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBFFCalculation(OpenBabel::OBFFCalculation *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBFFCalculation_Compute__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compute" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compute" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->Compute(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_Compute__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compute" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  (arg1)->Compute();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBFFCalculation_Compute(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBFFCalculation, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBFFCalculation_Compute__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBFFCalculation, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBFFCalculation_Compute__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBFFCalculation_Compute'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_GetEnergy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnergy" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (double)(arg1)->GetEnergy();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_GetGradient(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGradient" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetGradient" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (arg1)->GetGradient(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBForceField;

SWIGINTERN VALUE
_wrap_new_OBForceField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  bool arg2 ;
  OpenBabel::OBForceField *result = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBForceField" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBForceField" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (OpenBabel::OBForceField *)new OpenBabel::OBForceField(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBForceField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBForceField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBForceField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBForceField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBForceField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBForceField" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (OpenBabel::OBForceField *)new OpenBabel::OBForceField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBForceField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBForceField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBForceField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBForceField'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_Iter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    OpenBabel::PluginIter<OpenBabel::OBForceField > &_result_ref = OpenBabel::OBForceField::Iter();
    result = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_FindDefaultType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindDefaultType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_FindType(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBForceField *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::FindType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::FindType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindType((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBForceField(OpenBabel::OBForceField *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBForceField_FindForceField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBForceField *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::FindForceField" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::FindForceField" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindForceField((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_FindForceField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBForceField *result = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::FindForceField" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindForceField((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_FindForceField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_FindForceField__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_FindForceField__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_FindForceField'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_GetUnit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetUnit" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (arg1)->GetUnit();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_Setup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Setup" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Setup" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Setup" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(arg1)->Setup(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_UpdateCoordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UpdateCoordinates" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UpdateCoordinates" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UpdateCoordinates" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(arg1)->UpdateCoordinates(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_UpdateConformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UpdateConformers" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UpdateConformers" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UpdateConformers" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(arg1)->UpdateConformers(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_OBFFLog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OBFFLog" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OBFFLog" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->OBFFLog(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_OBFFLog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OBFFLog" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OBFFLog" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->OBFFLog((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_OBFFLog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBForceField_OBFFLog__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBForceField_OBFFLog__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_OBFFLog'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_Energy__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Energy" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Energy" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->Energy(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_Energy__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Energy" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->Energy();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_Energy(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_Energy__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_Energy__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_Energy'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_Bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Bond" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Bond" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_Bond(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_Bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Bond" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_Bond();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_E_Bond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_E_Bond__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_E_Bond__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_E_Bond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_Angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Angle" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Angle" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_Angle(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_Angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Angle" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_Angle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_E_Angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_E_Angle__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_E_Angle__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_E_Angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_StrBnd__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_StrBnd" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_StrBnd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_StrBnd(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_StrBnd__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_StrBnd" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_StrBnd();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_E_StrBnd(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_E_StrBnd__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_E_StrBnd__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_E_StrBnd'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_Torsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Torsion" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Torsion" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_Torsion(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_Torsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Torsion" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_Torsion();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_E_Torsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_E_Torsion__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_E_Torsion__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_E_Torsion'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_OOP__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_OOP" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_OOP" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_OOP(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_OOP__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_OOP" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_OOP();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_E_OOP(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_E_OOP__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_E_OOP__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_E_OOP'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_VDW__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_VDW" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_VDW" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_VDW(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_VDW__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_VDW" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_VDW();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_E_VDW(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_E_VDW__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_E_VDW__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_E_VDW'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_Electrostatic__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Electrostatic" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Electrostatic" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_Electrostatic(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_E_Electrostatic__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Electrostatic" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_Electrostatic();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_E_Electrostatic(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_E_Electrostatic__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_E_Electrostatic__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_E_Electrostatic'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SetLogFile(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLogFile" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLogFile" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  result = (bool)(arg1)->SetLogFile(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SetLogLevel(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLogLevel" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetLogLevel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->SetLogLevel(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_GetLogLevel(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLogLevel" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (int)(arg1)->GetLogLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SystematicRotorSearch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SystematicRotorSearch" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  (arg1)->SystematicRotorSearch();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_LineSearch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LineSearch" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LineSearch" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LineSearch" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LineSearch" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (arg1)->LineSearch(arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SteepestDescent__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescent" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SteepestDescent" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->SteepestDescent(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SteepestDescent__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescent" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->SteepestDescent(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SteepestDescent__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SteepestDescent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_SteepestDescent(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_SteepestDescent__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBForceField_SteepestDescent__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBForceField_SteepestDescent__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_SteepestDescent'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SteepestDescentInitialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescentInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SteepestDescentInitialize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->SteepestDescentInitialize(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SteepestDescentInitialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescentInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->SteepestDescentInitialize(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SteepestDescentInitialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SteepestDescentInitialize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SteepestDescentInitialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  (arg1)->SteepestDescentInitialize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_SteepestDescentInitialize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_SteepestDescentInitialize__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_SteepestDescentInitialize__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBForceField_SteepestDescentInitialize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBForceField_SteepestDescentInitialize__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_SteepestDescentInitialize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_SteepestDescentTakeNSteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentTakeNSteps" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentTakeNSteps" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->SteepestDescentTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ConjugateGradients__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradients" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ConjugateGradients" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->ConjugateGradients(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ConjugateGradients__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradients" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->ConjugateGradients(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ConjugateGradients__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->ConjugateGradients(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_ConjugateGradients(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_ConjugateGradients__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBForceField_ConjugateGradients__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBForceField_ConjugateGradients__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_ConjugateGradients'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ConjugateGradientsInitialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradientsInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ConjugateGradientsInitialize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->ConjugateGradientsInitialize(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ConjugateGradientsInitialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradientsInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->ConjugateGradientsInitialize(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ConjugateGradientsInitialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->ConjugateGradientsInitialize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ConjugateGradientsInitialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  (arg1)->ConjugateGradientsInitialize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_ConjugateGradientsInitialize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_ConjugateGradientsInitialize__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_ConjugateGradientsInitialize__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBForceField_ConjugateGradientsInitialize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBForceField_ConjugateGradientsInitialize__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_ConjugateGradientsInitialize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ConjugateGradientsTakeNSteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsTakeNSteps" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsTakeNSteps" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->ConjugateGradientsTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_Validate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Validate" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (bool)(arg1)->Validate();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ValidateGradients(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ValidateGradients" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (bool)(arg1)->ValidateGradients();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_ValidateGradientError(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ValidateGradientError" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ValidateGradientError" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ValidateGradientError" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ValidateGradientError" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ValidateGradientError" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (arg1)->ValidateGradientError(*arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_VectorLengthDerivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::VectorLengthDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorLengthDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBForceField::VectorLengthDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorLengthDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)OpenBabel::OBForceField::VectorLengthDerivative(*arg1,*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_VectorAngleDerivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (double)OpenBabel::OBForceField::VectorAngleDerivative(*arg1,*arg2,*arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_VectorTorsionDerivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (double)OpenBabel::OBForceField::VectorTorsionDerivative(*arg1,*arg2,*arg3,*arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_kludge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kludge" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  (arg1)->kludge();
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBMolAtomIter;

SWIGINTERN VALUE
_wrap_new_OBMolAtomIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolAtomIter *)new OpenBabel::OBMolAtomIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAtomIter *)new OpenBabel::OBMolAtomIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolAtomIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolAtomIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAtomIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolAtomIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = 0 ;
  OpenBabel::OBMolAtomIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAtomIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAtomIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBMolAtomIter *)new OpenBabel::OBMolAtomIter((OpenBabel::OBMolAtomIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolAtomIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolAtomIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolAtomIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolAtomIter(OpenBabel::OBMolAtomIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolAtomIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAtomIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBMolAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    OpenBabel::OBMolAtomIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolAtomIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolAtomIter(static_cast< const OpenBabel::OBMolAtomIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolAtomIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBMolAtomIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBMolAtomIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IncrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_DecrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_SetType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_SetType__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_SetType__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_SetType'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_SetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_SetVector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_SetVector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMolAtomIter_SetVector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_SetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_UnsetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetAntiClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_UnsetStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_ClearCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetAtomicMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetExactMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetCoordinateIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetCIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetHvyValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetHeteroValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetX(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetY(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetZ(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetCoordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_GetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_GetVector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_GetVector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_GetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetNewBondVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetNextAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_BeginBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_EndBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_BeginBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_NextBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_BeginNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_NextNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetDistance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetDistance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_GetDistance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_GetDistance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_GetDistance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_GetDistance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetAngle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetAngle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_GetAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMolAtomIter_GetAngle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMolAtomIter_GetAngle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_GetAngle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_NewResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_AddResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_DeleteResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_AddBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_InsertBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_DeleteBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_ClearBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HtoMethyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetHybAndGeom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_ForceNoH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasNoHForced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_CountFreeOxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_ImplicitHydrogenCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_ExplicitHydrogenCount__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_ExplicitHydrogenCount__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_ExplicitHydrogenCount(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_ExplicitHydrogenCount__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_ExplicitHydrogenCount__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_ExplicitHydrogenCount'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_MemberOfRingCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_MemberOfRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_CountRingBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SmallestBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_AverageBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_BOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_KBOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsCarbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsSulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsPhosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsInRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsHeteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsNotCorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsConnected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsOneThree(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsOneFour(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsCarboxylOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsPhosphateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsSulfateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsNitroOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsAmideNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsNonPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsAromaticNOxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsAxial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsAntiClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasChiralitySpecified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasChiralVolume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsHbondAcceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsHbondDonor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_IsHbondDonorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasAlphaBetaUnsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasAlphaBetaUnsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_HasAlphaBetaUnsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_HasAlphaBetaUnsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_HasAlphaBetaUnsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_HasAlphaBetaUnsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasBondOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_CountBondsOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasNonSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasDoubleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasAromaticBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_MatchesSMARTS(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_ClassDescription(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_HasData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_HasData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_HasData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_HasData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_HasData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_HasData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_DeleteData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_DeleteData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_DeleteData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_DeleteData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_DeleteData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_DeleteData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_DeleteData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_DeleteData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_DataSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_GetData__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_GetData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_GetData__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_GetData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_BeginData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_EndData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolAtomDFSIter;

SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter(*arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolAtomDFSIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = 0 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter((OpenBabel::OBMolAtomDFSIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolAtomDFSIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolAtomDFSIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomDFSIter__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomDFSIter__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBMolAtomDFSIter__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBMolAtomDFSIter__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolAtomDFSIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolAtomDFSIter(OpenBabel::OBMolAtomDFSIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAtomDFSIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    OpenBabel::OBMolAtomDFSIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolAtomDFSIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomDFSIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolAtomDFSIter(static_cast< const OpenBabel::OBMolAtomDFSIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBMolAtomDFSIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBMolAtomDFSIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_next(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "next" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->next();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IncrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_DecrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_SetType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_SetType__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_SetType__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_SetType'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_SetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_SetVector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_SetVector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMolAtomDFSIter_SetVector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_SetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_UnsetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetAntiClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_UnsetStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_ClearCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetAtomicMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetExactMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetCoordinateIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetCIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetHvyValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetHeteroValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetX(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetY(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetZ(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetCoordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_GetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_GetVector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_GetVector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_GetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetNewBondVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetNextAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_BeginBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_EndBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_BeginBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_NextBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_BeginNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_NextNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetDistance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetDistance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_GetDistance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_GetDistance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_GetDistance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_GetDistance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetAngle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetAngle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_GetAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMolAtomDFSIter_GetAngle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMolAtomDFSIter_GetAngle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_GetAngle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_NewResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_AddResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_DeleteResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_AddBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_InsertBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_DeleteBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_ClearBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HtoMethyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetHybAndGeom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_ForceNoH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasNoHForced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_CountFreeOxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_ImplicitHydrogenCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_ExplicitHydrogenCount__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_ExplicitHydrogenCount__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_ExplicitHydrogenCount(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_ExplicitHydrogenCount__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_ExplicitHydrogenCount__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_ExplicitHydrogenCount'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_MemberOfRingCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_MemberOfRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_CountRingBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SmallestBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_AverageBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_BOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_KBOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsCarbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsSulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsPhosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsInRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsHeteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsNotCorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsConnected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsOneThree(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsOneFour(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsCarboxylOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsPhosphateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsSulfateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsNitroOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsAmideNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsNonPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsAromaticNOxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsAxial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsAntiClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasChiralitySpecified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasChiralVolume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsHbondAcceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsHbondDonor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_IsHbondDonorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasAlphaBetaUnsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasAlphaBetaUnsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_HasAlphaBetaUnsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_HasAlphaBetaUnsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_HasAlphaBetaUnsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_HasAlphaBetaUnsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasBondOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_CountBondsOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasNonSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasDoubleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasAromaticBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_MatchesSMARTS(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_ClassDescription(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_HasData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_HasData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_HasData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_HasData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_HasData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_HasData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_DeleteData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_DeleteData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_DeleteData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_DeleteData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_DeleteData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_DeleteData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_DeleteData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_DeleteData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_DataSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_GetData__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_GetData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_GetData__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_GetData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_BeginData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_EndData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolAtomBFSIter;

SWIGINTERN VALUE
_wrap_new_OBMolAtomBFSIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolAtomBFSIter *)new OpenBabel::OBMolAtomBFSIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomBFSIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolAtomBFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomBFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAtomBFSIter *)new OpenBabel::OBMolAtomBFSIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolAtomBFSIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolAtomBFSIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = 0 ;
  OpenBabel::OBMolAtomBFSIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomBFSIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAtomBFSIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBMolAtomBFSIter *)new OpenBabel::OBMolAtomBFSIter((OpenBabel::OBMolAtomBFSIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolAtomBFSIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolAtomBFSIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomBFSIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomBFSIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolAtomBFSIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolAtomBFSIter(OpenBabel::OBMolAtomBFSIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAtomBFSIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBMolAtomBFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    OpenBabel::OBMolAtomBFSIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolAtomBFSIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomBFSIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolAtomBFSIter(static_cast< const OpenBabel::OBMolAtomBFSIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBMolAtomBFSIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBMolAtomBFSIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IncrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_DecrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_SetType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_SetType__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_SetType__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_SetType'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_SetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_SetVector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_SetVector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMolAtomBFSIter_SetVector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_SetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_UnsetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetAntiClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_UnsetStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_ClearCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetAtomicMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetExactMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetCoordinateIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetCIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetHvyValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetHeteroValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetX(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetY(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetZ(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetCoordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_GetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_GetVector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_GetVector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_GetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetNewBondVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetNextAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_BeginBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_EndBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_BeginBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_NextBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_BeginNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_NextNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetDistance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetDistance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_GetDistance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_GetDistance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_GetDistance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_GetDistance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetAngle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetAngle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_GetAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMolAtomBFSIter_GetAngle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMolAtomBFSIter_GetAngle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_GetAngle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_NewResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_AddResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_DeleteResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_AddBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_InsertBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_DeleteBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_ClearBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HtoMethyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetHybAndGeom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_ForceNoH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasNoHForced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_CountFreeOxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_ImplicitHydrogenCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_ExplicitHydrogenCount__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_ExplicitHydrogenCount__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_ExplicitHydrogenCount(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_ExplicitHydrogenCount__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_ExplicitHydrogenCount__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_ExplicitHydrogenCount'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_MemberOfRingCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_MemberOfRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_CountRingBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SmallestBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_AverageBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_BOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_KBOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsCarbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsSulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsPhosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsInRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsHeteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsNotCorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsConnected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsOneThree(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsOneFour(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsCarboxylOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsPhosphateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsSulfateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsNitroOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsAmideNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsNonPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsAromaticNOxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsAxial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsAntiClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasChiralitySpecified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasChiralVolume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsHbondAcceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsHbondDonor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_IsHbondDonorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasAlphaBetaUnsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasAlphaBetaUnsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_HasAlphaBetaUnsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_HasAlphaBetaUnsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_HasAlphaBetaUnsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_HasAlphaBetaUnsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasBondOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_CountBondsOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasNonSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasDoubleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasAromaticBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_MatchesSMARTS(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_ClassDescription(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_HasData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_HasData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_HasData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_HasData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_HasData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_HasData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_DeleteData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_DeleteData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_DeleteData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_DeleteData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_DeleteData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_DeleteData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_DeleteData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_DeleteData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_DataSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_GetData__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_GetData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_GetData__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_GetData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_BeginData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_EndData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolBondIter;

SWIGINTERN VALUE
_wrap_new_OBMolBondIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolBondIter *)new OpenBabel::OBMolBondIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolBondIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolBondIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolBondIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolBondIter *)new OpenBabel::OBMolBondIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolBondIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolBondIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolBondIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolBondIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = 0 ;
  OpenBabel::OBMolBondIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolBondIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolBondIter" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolBondIter" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBMolBondIter *)new OpenBabel::OBMolBondIter((OpenBabel::OBMolBondIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolBondIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolBondIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolBondIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolBondIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolBondIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolBondIter(OpenBabel::OBMolBondIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolBondIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)((OpenBabel::OBMolBondIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBMolBondIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    OpenBabel::OBMolBondIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolBondIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolBondIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolBondIter(static_cast< const OpenBabel::OBMolBondIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolBondIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBBond *)((OpenBabel::OBMolBondIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    OpenBabel::OBBond &_result_ref = ((OpenBabel::OBMolBondIter const *)arg1)->operator *();
    result = (OpenBabel::OBBond *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetBO(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBO" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBO" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetBO(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetBondOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBondOrder" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetBondOrder(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetBegin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBegin" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBegin" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->SetBegin(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetEnd(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnd" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetEnd" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->SetEnd(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetLength(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLength" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLength" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetLength" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->SetLength(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_Set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  int arg5 ;
  int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Set" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Set" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Set" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Set" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  (*arg1)->Set(arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetKSingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKSingle" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetKSingle();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetKDouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKDouble" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetKDouble();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetKTriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKTriple" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetKTriple();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetHash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHash" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetWedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetWedge" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetUp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetUp" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetDown(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDown" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetClosure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClosure" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetClosure();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_UnsetHash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetHash" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_UnsetWedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetWedge" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_UnsetUp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetUp" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_UnsetDown(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetDown" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_UnsetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_UnsetKekule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetKekule" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetKekule();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetBO(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBO" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBO();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetBondOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBondOrder();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetFlags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFlags" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetFlags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetBeginAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBeginAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetEndAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetEndAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetBeginAtom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetBeginAtom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_GetBeginAtom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_GetBeginAtom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_GetBeginAtom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_GetBeginAtom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetEndAtom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetEndAtom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_GetEndAtom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_GetEndAtom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_GetEndAtom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_GetEndAtom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNbrAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetEquibLength(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEquibLength" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (double)(*arg1)->GetEquibLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetLength(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLength" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (double)(*arg1)->GetLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetNbrAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtomIdx" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)(*arg1)->GetNbrAtomIdx(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsRotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsRotor" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsAmide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmide" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsPrimaryAmide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPrimaryAmide" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsPrimaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsSecondaryAmide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSecondaryAmide" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsSecondaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsEster(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsEster" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsEster();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsCarbonyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbonyl" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsCarbonyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsSingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSingle" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsDouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDouble" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsTriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsTriple" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsKSingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKSingle" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsKSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsKDouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKDouble" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsKDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsKTriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKTriple" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsKTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsClosure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClosure" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsClosure();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsUp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsUp" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsUp();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsDown(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDown" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsDown();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsWedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsWedge" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsWedge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsHash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHash" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsHash();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_IsDoubleBondGeometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDoubleBondGeometry" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsDoubleBondGeometry();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_ClassDescription(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_HasData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_HasData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_HasData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_HasData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_HasData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_HasData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_HasData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_HasData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_DeleteData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_DeleteData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_DeleteData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_DeleteData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_DeleteData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_DeleteData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_DeleteData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_DeleteData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_DataSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_GetData__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_GetData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_GetData__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_GetData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_BeginData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_EndData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBAtomAtomIter;

SWIGINTERN VALUE
_wrap_new_OBAtomAtomIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBAtomAtomIter *)new OpenBabel::OBAtomAtomIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBAtomAtomIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtomAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAtomAtomIter" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBAtomAtomIter *)new OpenBabel::OBAtomAtomIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBAtomAtomIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBAtomAtomIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAtomAtomIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBAtomAtomIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = 0 ;
  OpenBabel::OBAtomAtomIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBAtomAtomIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAtomAtomIter" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBAtomAtomIter" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBAtomAtomIter *)new OpenBabel::OBAtomAtomIter((OpenBabel::OBAtomAtomIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBAtomAtomIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBAtomAtomIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAtomAtomIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAtomAtomIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBAtomAtomIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAtomAtomIter(OpenBabel::OBAtomAtomIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBAtomAtomIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)((OpenBabel::OBAtomAtomIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtomAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    OpenBabel::OBAtomAtomIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBAtomAtomIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  OpenBabel::OBAtomAtomIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomAtomIter(static_cast< const OpenBabel::OBAtomAtomIter& >(result))), SWIGTYPE_p_OpenBabel__OBAtomAtomIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBAtomAtomIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBAtomAtomIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IncrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_DecrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_SetType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_SetType__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_SetType__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_SetType'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_SetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_SetVector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_SetVector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBAtomAtomIter_SetVector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_SetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_UnsetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetAntiClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_UnsetStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_ClearCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetAtomicMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetExactMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetCoordinateIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetCIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetHvyValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetHeteroValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetX(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetY(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetZ(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetCoordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_GetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_GetVector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_GetVector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_GetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetNewBondVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetNextAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_BeginBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_EndBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_BeginBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_NextBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_BeginNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_NextNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetDistance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetDistance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_GetDistance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_GetDistance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_GetDistance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_GetDistance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetAngle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetAngle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_GetAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBAtomAtomIter_GetAngle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBAtomAtomIter_GetAngle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_GetAngle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_NewResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_AddResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_DeleteResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_AddBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_InsertBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_DeleteBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_ClearBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HtoMethyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetHybAndGeom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_ForceNoH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasNoHForced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_CountFreeOxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_ImplicitHydrogenCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_ExplicitHydrogenCount__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_ExplicitHydrogenCount__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_ExplicitHydrogenCount(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_ExplicitHydrogenCount__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_ExplicitHydrogenCount__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_ExplicitHydrogenCount'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_MemberOfRingCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_MemberOfRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_CountRingBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SmallestBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_AverageBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_BOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_KBOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsCarbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsSulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsPhosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsInRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsHeteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsNotCorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsConnected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsOneThree(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsOneFour(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsCarboxylOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsPhosphateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsSulfateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsNitroOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsAmideNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsNonPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsAromaticNOxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsAxial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsAntiClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasChiralitySpecified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasChiralVolume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsHbondAcceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsHbondDonor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_IsHbondDonorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasAlphaBetaUnsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasAlphaBetaUnsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_HasAlphaBetaUnsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_HasAlphaBetaUnsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_HasAlphaBetaUnsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_HasAlphaBetaUnsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasBondOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_CountBondsOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasNonSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasDoubleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasAromaticBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_MatchesSMARTS(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_ClassDescription(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_HasData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_HasData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_HasData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_HasData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_HasData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_HasData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_DeleteData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_DeleteData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_DeleteData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_DeleteData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_DeleteData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_DeleteData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_DeleteData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_DeleteData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_DataSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_GetData__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_GetData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_GetData__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_GetData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_BeginData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_EndData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBAtomBondIter;

SWIGINTERN VALUE
_wrap_new_OBAtomBondIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBAtomBondIter *)new OpenBabel::OBAtomBondIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBAtomBondIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtomBondIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAtomBondIter" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBAtomBondIter *)new OpenBabel::OBAtomBondIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBAtomBondIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBAtomBondIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAtomBondIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBAtomBondIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = 0 ;
  OpenBabel::OBAtomBondIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBAtomBondIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAtomBondIter" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBAtomBondIter" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtomBondIter *)new OpenBabel::OBAtomBondIter((OpenBabel::OBAtomBondIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBAtomBondIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBAtomBondIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAtomBondIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAtomBondIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBAtomBondIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAtomBondIter(OpenBabel::OBAtomBondIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBAtomBondIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)((OpenBabel::OBAtomBondIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtomBondIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    OpenBabel::OBAtomBondIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBAtomBondIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  OpenBabel::OBAtomBondIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomBondIter(static_cast< const OpenBabel::OBAtomBondIter& >(result))), SWIGTYPE_p_OpenBabel__OBAtomBondIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBBond *)((OpenBabel::OBAtomBondIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    OpenBabel::OBBond &_result_ref = ((OpenBabel::OBAtomBondIter const *)arg1)->operator *();
    result = (OpenBabel::OBBond *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetBO(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBO" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBO" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetBO(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetBondOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBondOrder" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetBondOrder(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetBegin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBegin" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBegin" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->SetBegin(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetEnd(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnd" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetEnd" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->SetEnd(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetLength(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLength" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLength" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetLength" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->SetLength(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_Set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  int arg5 ;
  int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Set" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Set" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Set" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Set" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  (*arg1)->Set(arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetKSingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKSingle" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetKSingle();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetKDouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKDouble" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetKDouble();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetKTriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKTriple" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetKTriple();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetHash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHash" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetWedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetWedge" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetUp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetUp" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetDown(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDown" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetClosure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClosure" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetClosure();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_UnsetHash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetHash" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_UnsetWedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetWedge" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_UnsetUp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetUp" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_UnsetDown(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetDown" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_UnsetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_UnsetKekule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetKekule" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetKekule();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetBO(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBO" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBO();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetBondOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBondOrder();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetFlags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFlags" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetFlags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetBeginAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBeginAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetEndAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetEndAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetBeginAtom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetBeginAtom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_GetBeginAtom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_GetBeginAtom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_GetBeginAtom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_GetBeginAtom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetEndAtom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetEndAtom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_GetEndAtom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_GetEndAtom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_GetEndAtom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_GetEndAtom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNbrAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetEquibLength(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEquibLength" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (double)(*arg1)->GetEquibLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetLength(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLength" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (double)(*arg1)->GetLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetNbrAtomIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtomIdx" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)(*arg1)->GetNbrAtomIdx(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsRotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsRotor" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsAmide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmide" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsPrimaryAmide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPrimaryAmide" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsPrimaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsSecondaryAmide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSecondaryAmide" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsSecondaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsEster(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsEster" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsEster();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsCarbonyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbonyl" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsCarbonyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsSingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSingle" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsDouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDouble" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsTriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsTriple" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsKSingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKSingle" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsKSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsKDouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKDouble" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsKDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsKTriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKTriple" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsKTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsClosure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClosure" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsClosure();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsUp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsUp" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsUp();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsDown(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDown" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsDown();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsWedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsWedge" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsWedge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsHash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHash" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsHash();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_IsDoubleBondGeometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDoubleBondGeometry" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsDoubleBondGeometry();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_ClassDescription(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_HasData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_HasData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_HasData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_HasData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_HasData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_HasData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_HasData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_HasData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_DeleteData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_DeleteData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_DeleteData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_DeleteData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_DeleteData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_DeleteData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_DeleteData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_DeleteData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_DataSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_GetData__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_GetData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_GetData__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_GetData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_BeginData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_EndData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBResidueIter;

SWIGINTERN VALUE
_wrap_new_OBResidueIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBResidueIter *)new OpenBabel::OBResidueIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBResidueIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidueIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidueIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBResidueIter *)new OpenBabel::OBResidueIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBResidueIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBResidueIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidueIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBResidueIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = 0 ;
  OpenBabel::OBResidueIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBResidueIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidueIter" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBResidueIter" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (OpenBabel::OBResidueIter *)new OpenBabel::OBResidueIter((OpenBabel::OBResidueIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBResidueIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBResidueIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidueIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidueIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBResidueIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBResidueIter(OpenBabel::OBResidueIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBResidueIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (bool)((OpenBabel::OBResidueIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBResidueIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    OpenBabel::OBResidueIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBResidueIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  int arg2 ;
  OpenBabel::OBResidueIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueIter(static_cast< const OpenBabel::OBResidueIter& >(result))), SWIGTYPE_p_OpenBabel__OBResidueIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (OpenBabel::OBResidue *)((OpenBabel::OBResidueIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    OpenBabel::OBResidue &_result_ref = ((OpenBabel::OBResidueIter const *)arg1)->operator *();
    result = (OpenBabel::OBResidue *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_AddAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->AddAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_InsertAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->InsertAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_RemoveAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoveAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoveAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->RemoveAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_SetName(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetName" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (*arg1)->SetName((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_SetNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetNum" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_SetChain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChain" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetChain" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  (*arg1)->SetChain(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_SetChainNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChainNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetChainNum" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetChainNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_SetAtomID(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomID" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtomID" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetAtomID" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetAtomID" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (*arg1)->SetAtomID(arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_SetHetAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHetAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetHetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetHetAtom" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (*arg1)->SetHetAtom(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_SetSerialNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSerialNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetSerialNum" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetSerialNum" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (*arg1)->SetSerialNum(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetName(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetName" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->GetName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetNumAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNumAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetNumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetChain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChain" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (char)(*arg1)->GetChain();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetChainNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChainNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetChainNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetResKey(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResKey" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetResKey();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->GetAtoms();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBAtom * >(static_cast< const std::vector<OpenBabel::OBAtom * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetBonds__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  bool arg2 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetBonds" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (*arg1)->GetBonds(arg2);
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBBond * >(static_cast< const std::vector<OpenBabel::OBBond * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetBonds__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->GetBonds();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBBond * >(static_cast< const std::vector<OpenBabel::OBBond * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_GetBonds(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueIter_GetBonds__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_GetBonds__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_GetBonds'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetAtomID(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomID" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomID" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (*arg1)->GetAtomID(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetSerialNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSerialNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetSerialNum" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)(*arg1)->GetSerialNum(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetAminoAcidProperty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAminoAcidProperty" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAminoAcidProperty" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->GetAminoAcidProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetAtomProperty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomProperty" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomProperty" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAtomProperty" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)(*arg1)->GetAtomProperty(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetResidueProperty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidueProperty" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetResidueProperty" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->GetResidueProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_IsHetAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHetAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsHetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsHetAtom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_IsResidueType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsResidueType" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsResidueType" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsResidueType(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_BeginAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->BeginAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_EndAtoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->EndAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_BeginAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector<OpenBabel::OBAtom * >::iterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_NextAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector<OpenBabel::OBAtom * >::iterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_ClassDescription(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_HasData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_HasData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_HasData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_HasData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_HasData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_HasData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_HasData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_HasData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_DeleteData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_DeleteData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_DeleteData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_DeleteData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_DeleteData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_DeleteData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_DeleteData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_DeleteData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_DataSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_GetData__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueIter_GetData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_GetData__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_GetData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_BeginData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_EndData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBResidueAtomIter;

SWIGINTERN VALUE
_wrap_new_OBResidueAtomIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBResidueAtomIter *)new OpenBabel::OBResidueAtomIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBResidueAtomIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBResidueAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidueAtomIter" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (OpenBabel::OBResidueAtomIter *)new OpenBabel::OBResidueAtomIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBResidueAtomIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBResidueAtomIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidueAtomIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBResidueAtomIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = 0 ;
  OpenBabel::OBResidueAtomIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBResidueAtomIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidueAtomIter" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBResidueAtomIter" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBResidueAtomIter *)new OpenBabel::OBResidueAtomIter((OpenBabel::OBResidueAtomIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBResidueAtomIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBResidueAtomIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidueAtomIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidueAtomIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBResidueAtomIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBResidueAtomIter(OpenBabel::OBResidueAtomIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBResidueAtomIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)((OpenBabel::OBResidueAtomIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidueAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    OpenBabel::OBResidueAtomIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBResidueAtomIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  OpenBabel::OBResidueAtomIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueAtomIter(static_cast< const OpenBabel::OBResidueAtomIter& >(result))), SWIGTYPE_p_OpenBabel__OBResidueAtomIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBResidueAtomIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBResidueAtomIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_Clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IncrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_DecrementImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_SetType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_SetType__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_SetType__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_SetType'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_SetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_SetVector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_SetVector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBResidueAtomIter_SetVector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_SetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_UnsetAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetAntiClockwiseStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_UnsetStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_ClearCoordPtr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetFormalCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetAtomicNum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetIsotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetSpinMultiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetAtomicMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetExactMass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetCoordinateIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetCIdx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetHyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetImplicitValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetHvyValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetHeteroValence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetX(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetY(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetZ(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetCoordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_GetVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_GetVector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_GetVector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_GetVector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetPartialCharge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetNewBondVector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetNextAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_BeginBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_EndBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_BeginBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_NextBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_BeginNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_NextNbrAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetDistance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetDistance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_GetDistance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_GetDistance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_GetDistance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_GetDistance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetAngle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetAngle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_GetAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBResidueAtomIter_GetAngle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBResidueAtomIter_GetAngle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_GetAngle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_NewResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_AddResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_DeleteResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_AddBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_InsertBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_DeleteBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_ClearBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HtoMethyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetHybAndGeom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_ForceNoH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasNoHForced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_CountFreeOxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_ImplicitHydrogenCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_ExplicitHydrogenCount__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_ExplicitHydrogenCount__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_ExplicitHydrogenCount(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_ExplicitHydrogenCount__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_ExplicitHydrogenCount__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_ExplicitHydrogenCount'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_MemberOfRingCount(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_MemberOfRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_CountRingBonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SmallestBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_AverageBondAngle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_BOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_KBOSum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasResidue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsCarbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsSulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsPhosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsInRingSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsHeteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsNotCorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsConnected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsOneThree(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsOneFour(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsCarboxylOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsPhosphateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsSulfateOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsNitroOxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsAmideNitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsNonPolarHydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsAromaticNOxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsChiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsAxial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsAntiClockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsPositiveStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsNegativeStereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasChiralitySpecified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasChiralVolume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsHbondAcceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsHbondDonor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_IsHbondDonorH(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasAlphaBetaUnsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasAlphaBetaUnsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_HasAlphaBetaUnsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_HasAlphaBetaUnsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_HasAlphaBetaUnsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_HasAlphaBetaUnsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasBondOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_CountBondsOfOrder(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasNonSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasSingleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasDoubleBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasAromaticBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_MatchesSMARTS(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_DoTransformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_ClassDescription(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_HasData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_HasData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_HasData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_HasData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_HasData__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_HasData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_DeleteData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_DeleteData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_DeleteData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_DeleteData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_DeleteData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_DeleteData__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_DeleteData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_DeleteData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_SetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_DataSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_GetData__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_GetData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_GetData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_GetData__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_GetData__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_GetData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_GetData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_GetData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_BeginData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_EndData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolAngleIter;

SWIGINTERN VALUE
_wrap_new_OBMolAngleIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolAngleIter *)new OpenBabel::OBMolAngleIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAngleIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolAngleIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAngleIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAngleIter *)new OpenBabel::OBMolAngleIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolAngleIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolAngleIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAngleIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolAngleIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = 0 ;
  OpenBabel::OBMolAngleIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAngleIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAngleIter" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAngleIter" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  result = (OpenBabel::OBMolAngleIter *)new OpenBabel::OBMolAngleIter((OpenBabel::OBMolAngleIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolAngleIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolAngleIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAngleIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAngleIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolAngleIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolAngleIter(OpenBabel::OBMolAngleIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolAngleIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = (OpenBabel::OBMolAngleIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAngleIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAngleIter_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = (OpenBabel::OBMolAngleIter *) 0 ;
  OpenBabel::OBMolAngleIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  {
    OpenBabel::OBMolAngleIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolAngleIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAngleIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = (OpenBabel::OBMolAngleIter *) 0 ;
  std::vector<unsigned int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  result = ((OpenBabel::OBMolAngleIter const *)arg1)->operator *();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<unsigned int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolTorsionIter;

SWIGINTERN VALUE
_wrap_new_OBMolTorsionIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolTorsionIter *)new OpenBabel::OBMolTorsionIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolTorsionIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolTorsionIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolTorsionIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolTorsionIter *)new OpenBabel::OBMolTorsionIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolTorsionIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolTorsionIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolTorsionIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolTorsionIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = 0 ;
  OpenBabel::OBMolTorsionIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolTorsionIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolTorsionIter" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolTorsionIter" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = (OpenBabel::OBMolTorsionIter *)new OpenBabel::OBMolTorsionIter((OpenBabel::OBMolTorsionIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolTorsionIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolTorsionIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolTorsionIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolTorsionIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolTorsionIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolTorsionIter(OpenBabel::OBMolTorsionIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolTorsionIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = (OpenBabel::OBMolTorsionIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = (bool)((OpenBabel::OBMolTorsionIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolTorsionIter_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = (OpenBabel::OBMolTorsionIter *) 0 ;
  OpenBabel::OBMolTorsionIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  {
    OpenBabel::OBMolTorsionIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolTorsionIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolTorsionIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = (OpenBabel::OBMolTorsionIter *) 0 ;
  std::vector<unsigned int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = ((OpenBabel::OBMolTorsionIter const *)arg1)->operator *();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<unsigned int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolPairIter;

SWIGINTERN VALUE
_wrap_new_OBMolPairIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolPairIter *)new OpenBabel::OBMolPairIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolPairIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolPairIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolPairIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolPairIter *)new OpenBabel::OBMolPairIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolPairIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolPairIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolPairIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolPairIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = 0 ;
  OpenBabel::OBMolPairIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolPairIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolPairIter" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolPairIter" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  result = (OpenBabel::OBMolPairIter *)new OpenBabel::OBMolPairIter((OpenBabel::OBMolPairIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolPairIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolPairIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolPairIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolPairIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolPairIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolPairIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolPairIter(OpenBabel::OBMolPairIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolPairIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = (OpenBabel::OBMolPairIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  result = (bool)((OpenBabel::OBMolPairIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolPairIter_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = (OpenBabel::OBMolPairIter *) 0 ;
  OpenBabel::OBMolPairIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  {
    OpenBabel::OBMolPairIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolPairIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolPairIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = (OpenBabel::OBMolPairIter *) 0 ;
  std::vector<unsigned int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  result = ((OpenBabel::OBMolPairIter const *)arg1)->operator *();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<unsigned int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolRingIter;

SWIGINTERN VALUE
_wrap_new_OBMolRingIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolRingIter *)new OpenBabel::OBMolRingIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolRingIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolRingIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolRingIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolRingIter *)new OpenBabel::OBMolRingIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolRingIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolRingIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolRingIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolRingIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = 0 ;
  OpenBabel::OBMolRingIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolRingIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolRingIter" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolRingIter" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (OpenBabel::OBMolRingIter *)new OpenBabel::OBMolRingIter((OpenBabel::OBMolRingIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolRingIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolRingIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolRingIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolRingIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolRingIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolRingIter(OpenBabel::OBMolRingIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolRingIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (bool)((OpenBabel::OBMolRingIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBMolRingIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    OpenBabel::OBMolRingIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolRingIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolRingIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolRingIter(static_cast< const OpenBabel::OBMolRingIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolRingIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolRingIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolRingIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolRingIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolRingIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (OpenBabel::OBRing *)((OpenBabel::OBMolRingIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    OpenBabel::OBRing &_result_ref = ((OpenBabel::OBMolRingIter const *)arg1)->operator *();
    result = (OpenBabel::OBRing *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter__path_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  std::vector<int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_path" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  if (arg1) (*arg1)->_path = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter__path_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  std::vector<int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_path" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    std::vector<int > const &_result_ref =  ((*arg1)->_path);
    result = (std::vector<int > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter__pathset_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBBitVec *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_pathset" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_pathset" "', argument " "2"" of type '" "OpenBabel::OBBitVec const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_pathset" "', argument " "2"" of type '" "OpenBabel::OBBitVec const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2);
  if (arg1) (*arg1)->_pathset = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter__pathset_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBBitVec *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_pathset" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    OpenBabel::OBBitVec const &_result_ref =  ((*arg1)->_pathset);
    result = (OpenBabel::OBBitVec *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBitVec, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_Size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Size" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (int)(*arg1)->Size();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_PathSize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSize" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (int)(*arg1)->PathSize();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_IsAromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_IsMember__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsMember" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsMember" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_IsMember__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsMember" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsMember" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolRingIter_IsMember(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolRingIter_IsMember__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolRingIter_IsMember__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolRingIter_IsMember'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_IsInRing(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRing" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRing(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_SetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_GetParent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_findCenterAndNormal(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "findCenterAndNormal" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "findCenterAndNormal" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "findCenterAndNormal" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "findCenterAndNormal" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (bool)(*arg1)->findCenterAndNormal(*arg2,*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_OpenBabel__OBAtomTyperTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBAtomTyper *) x));
}
static void *_p_OpenBabel__OBAromaticTyperTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBAromaticTyper *) x));
}
static void *_p_OpenBabel__OBResidueDataTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBResidueData *) x));
}
static void *_p_OpenBabel__OBIsotopeTableTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBIsotopeTable *) x));
}
static void *_p_OpenBabel__OBTypeTableTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBTypeTable *) x));
}
static void *_p_OpenBabel__OBElementTableTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBElementTable *) x));
}
static void *_p_OpenBabel__OBMolTo_p_OpenBabel__OBBase(void *x) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBMol *) x));
}
static void *_p_OpenBabel__OBResidueTo_p_OpenBabel__OBBase(void *x) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBResidue *) x));
}
static void *_p_OpenBabel__OBBondTo_p_OpenBabel__OBBase(void *x) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBBond *) x));
}
static void *_p_OpenBabel__OBAtomTo_p_OpenBabel__OBBase(void *x) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBAtom *) x));
}
static void *_p_OpenBabel__OBVibrationDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBVibrationData *) x));
}
static void *_p_OpenBabel__OBTorsionDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBTorsionData *) x));
}
static void *_p_OpenBabel__OBPairDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBPairData *) x));
}
static void *_p_OpenBabel__OBAngleDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBAngleData *) x));
}
static void *_p_OpenBabel__OBChiralDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBChiralData *) x));
}
static void *_p_OpenBabel__OBRingDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBRingData *) x));
}
static void *_p_OpenBabel__OBSerialNumsTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBSerialNums *) x));
}
static void *_p_OpenBabel__OBExternalBondDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBExternalBondData *) x));
}
static void *_p_OpenBabel__OBSetDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBSetData *) x));
}
static void *_p_OpenBabel__OBSymmetryDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBSymmetryData *) x));
}
static void *_p_OpenBabel__OBCommentDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBCommentData *) x));
}
static void *_p_OpenBabel__OBVirtualBondTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBVirtualBond *) x));
}
static void *_p_OpenBabel__OBConformerDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBConformerData *) x));
}
static void *_p_OpenBabel__OBUnitCellTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBUnitCell *) x));
}
static void *_p_p_OpenBabel__OBVibrationDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBVibrationData **) x));
}
static void *_p_p_OpenBabel__OBTorsionDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBTorsionData **) x));
}
static void *_p_p_OpenBabel__OBPairDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBPairData **) x));
}
static void *_p_p_OpenBabel__OBAngleDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBAngleData **) x));
}
static void *_p_p_OpenBabel__OBChiralDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBChiralData **) x));
}
static void *_p_p_OpenBabel__OBRingDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBRingData **) x));
}
static void *_p_p_OpenBabel__OBSerialNumsTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBSerialNums **) x));
}
static void *_p_p_OpenBabel__OBExternalBondDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBExternalBondData **) x));
}
static void *_p_p_OpenBabel__OBSetDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBSetData **) x));
}
static void *_p_p_OpenBabel__OBSymmetryDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBSymmetryData **) x));
}
static void *_p_p_OpenBabel__OBCommentDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBCommentData **) x));
}
static void *_p_p_OpenBabel__OBVirtualBondTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBVirtualBond **) x));
}
static void *_p_p_OpenBabel__OBConformerDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBConformerData **) x));
}
static void *_p_p_OpenBabel__OBUnitCellTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBUnitCell **) x));
}
static swig_type_info _swigt__p_OpenBabel__CharPtrLess = {"_p_OpenBabel__CharPtrLess", "OpenBabel::CharPtrLess *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__DoubleType = {"_p_OpenBabel__DoubleType", "OpenBabel::DoubleType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FMapType__iterator = {"_p_OpenBabel__FMapType__iterator", "OpenBabel::FMapType::iterator *|OpenBabel::Formatpos *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FastSearch = {"_p_OpenBabel__FastSearch", "OpenBabel::FastSearch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FastSearchIndexer = {"_p_OpenBabel__FastSearchIndexer", "OpenBabel::FastSearchIndexer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FptIndex = {"_p_OpenBabel__FptIndex", "OpenBabel::FptIndex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FptIndexHeader = {"_p_OpenBabel__FptIndexHeader", "OpenBabel::FptIndexHeader *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAngle = {"_p_OpenBabel__OBAngle", "OpenBabel::OBAngle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAngleData = {"_p_OpenBabel__OBAngleData", "OpenBabel::OBAngleData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAromaticTyper = {"_p_OpenBabel__OBAromaticTyper", "OpenBabel::OBAromaticTyper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtom = {"_p_OpenBabel__OBAtom", "OpenBabel::OBAtom *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtomAtomIter = {"_p_OpenBabel__OBAtomAtomIter", "OpenBabel::OBAtomAtomIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtomBondIter = {"_p_OpenBabel__OBAtomBondIter", "OpenBabel::OBAtomBondIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtomTyper = {"_p_OpenBabel__OBAtomTyper", "OpenBabel::OBAtomTyper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBBase = {"_p_OpenBabel__OBBase", "OpenBabel::OBBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBBitVec = {"_p_OpenBabel__OBBitVec", "OpenBabel::OBBitVec *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBBond = {"_p_OpenBabel__OBBond", "OpenBabel::OBBond *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBChainsParser = {"_p_OpenBabel__OBChainsParser", "OpenBabel::OBChainsParser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBChiralData = {"_p_OpenBabel__OBChiralData", "OpenBabel::OBChiralData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBCommentData = {"_p_OpenBabel__OBCommentData", "OpenBabel::OBCommentData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBConformerData = {"_p_OpenBabel__OBConformerData", "OpenBabel::OBConformerData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBConversion = {"_p_OpenBabel__OBConversion", "OpenBabel::OBConversion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBElement = {"_p_OpenBabel__OBElement", "OpenBabel::OBElement *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBElementTable = {"_p_OpenBabel__OBElementTable", "OpenBabel::OBElementTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBError = {"_p_OpenBabel__OBError", "OpenBabel::OBError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBExternalBond = {"_p_OpenBabel__OBExternalBond", "OpenBabel::OBExternalBond *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBExternalBondData = {"_p_OpenBabel__OBExternalBondData", "OpenBabel::OBExternalBondData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFCalculation = {"_p_OpenBabel__OBFFCalculation", "OpenBabel::OBFFCalculation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFParameter = {"_p_OpenBabel__OBFFParameter", "OpenBabel::OBFFParameter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFingerprint = {"_p_OpenBabel__OBFingerprint", "OpenBabel::OBFingerprint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBForceField = {"_p_OpenBabel__OBForceField", "OpenBabel::OBForceField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFormat = {"_p_OpenBabel__OBFormat", "OpenBabel::OBFormat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBGenericData = {"_p_OpenBabel__OBGenericData", "OpenBabel::OBGenericData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBGlobalDataBase = {"_p_OpenBabel__OBGlobalDataBase", "OpenBabel::OBGlobalDataBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBInternalCoord = {"_p_OpenBabel__OBInternalCoord", "OpenBabel::OBInternalCoord *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBIsotopeTable = {"_p_OpenBabel__OBIsotopeTable", "OpenBabel::OBIsotopeTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMessageHandler = {"_p_OpenBabel__OBMessageHandler", "OpenBabel::OBMessageHandler *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMol = {"_p_OpenBabel__OBMol", "OpenBabel::OBMol *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAngleIter = {"_p_OpenBabel__OBMolAngleIter", "OpenBabel::OBMolAngleIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAtomBFSIter = {"_p_OpenBabel__OBMolAtomBFSIter", "OpenBabel::OBMolAtomBFSIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAtomDFSIter = {"_p_OpenBabel__OBMolAtomDFSIter", "OpenBabel::OBMolAtomDFSIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAtomIter = {"_p_OpenBabel__OBMolAtomIter", "OpenBabel::OBMolAtomIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolBondIter = {"_p_OpenBabel__OBMolBondIter", "OpenBabel::OBMolBondIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolPairIter = {"_p_OpenBabel__OBMolPairIter", "OpenBabel::OBMolPairIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolRingIter = {"_p_OpenBabel__OBMolRingIter", "OpenBabel::OBMolRingIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolTorsionIter = {"_p_OpenBabel__OBMolTorsionIter", "OpenBabel::OBMolTorsionIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPairData = {"_p_OpenBabel__OBPairData", "OpenBabel::OBPairData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPairTemplateTdouble_t = {"_p_OpenBabel__OBPairTemplateTdouble_t", "OpenBabel::OBPairTemplate<double > *|OpenBabel::OBPairFloatingPoint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPairTemplateTint_t = {"_p_OpenBabel__OBPairTemplateTint_t", "OpenBabel::OBPairTemplate<int > *|OpenBabel::OBPairInteger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRTree = {"_p_OpenBabel__OBRTree", "OpenBabel::OBRTree *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRandom = {"_p_OpenBabel__OBRandom", "OpenBabel::OBRandom *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidue = {"_p_OpenBabel__OBResidue", "OpenBabel::OBResidue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidueAtomIter = {"_p_OpenBabel__OBResidueAtomIter", "OpenBabel::OBResidueAtomIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidueData = {"_p_OpenBabel__OBResidueData", "OpenBabel::OBResidueData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidueIter = {"_p_OpenBabel__OBResidueIter", "OpenBabel::OBResidueIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRing = {"_p_OpenBabel__OBRing", "OpenBabel::OBRing *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRingData = {"_p_OpenBabel__OBRingData", "OpenBabel::OBRingData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRingSearch = {"_p_OpenBabel__OBRingSearch", "OpenBabel::OBRingSearch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSSMatch = {"_p_OpenBabel__OBSSMatch", "OpenBabel::OBSSMatch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSerialNums = {"_p_OpenBabel__OBSerialNums", "OpenBabel::OBSerialNums *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSetData = {"_p_OpenBabel__OBSetData", "OpenBabel::OBSetData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSmartsPattern = {"_p_OpenBabel__OBSmartsPattern", "OpenBabel::OBSmartsPattern *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSqrtTbl = {"_p_OpenBabel__OBSqrtTbl", "OpenBabel::OBSqrtTbl *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBStopwatch = {"_p_OpenBabel__OBStopwatch", "OpenBabel::OBStopwatch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSymmetryData = {"_p_OpenBabel__OBSymmetryData", "OpenBabel::OBSymmetryData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBTorsion = {"_p_OpenBabel__OBTorsion", "OpenBabel::OBTorsion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBTorsionData = {"_p_OpenBabel__OBTorsionData", "OpenBabel::OBTorsionData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBTypeTable = {"_p_OpenBabel__OBTypeTable", "OpenBabel::OBTypeTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBUnitCell = {"_p_OpenBabel__OBUnitCell", "OpenBabel::OBUnitCell *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBVibrationData = {"_p_OpenBabel__OBVibrationData", "OpenBabel::OBVibrationData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBVirtualBond = {"_p_OpenBabel__OBVirtualBond", "OpenBabel::OBVirtualBond *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__Pattern = {"_p_OpenBabel__Pattern", "OpenBabel::Pattern *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t = {"_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t", "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t = {"_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t", "OpenBabel::PluginIter<OpenBabel::OBForceField > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__Template = {"_p_OpenBabel__Template", "OpenBabel::Template *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__matrix3x3 = {"_p_OpenBabel__matrix3x3", "OpenBabel::matrix3x3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__obLogBuf = {"_p_OpenBabel__obLogBuf", "OpenBabel::obLogBuf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t = {"_p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t", "OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t = {"_p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t", "OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__vector3 = {"_p_OpenBabel__vector3", "OpenBabel::vector3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_3__double = {"_p_a_3__double", "double (*)[3]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__char = {"_p_a_4__char", "char (*)[4]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBFormat = {"_p_p_OpenBabel__OBFormat", "OpenBabel::OBFormat **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBGenericData = {"_p_p_OpenBabel__OBGenericData", "OpenBabel::OBGenericData **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBVibrationData = {"_p_p_OpenBabel__OBVibrationData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBTorsionData = {"_p_p_OpenBabel__OBTorsionData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBPairData = {"_p_p_OpenBabel__OBPairData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBAngleData = {"_p_p_OpenBabel__OBAngleData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBChiralData = {"_p_p_OpenBabel__OBChiralData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBRingData = {"_p_p_OpenBabel__OBRingData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBSerialNums = {"_p_p_OpenBabel__OBSerialNums", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBExternalBondData = {"_p_p_OpenBabel__OBExternalBondData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBSetData = {"_p_p_OpenBabel__OBSetData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBSymmetryData = {"_p_p_OpenBabel__OBSymmetryData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBCommentData = {"_p_p_OpenBabel__OBCommentData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBVirtualBond = {"_p_p_OpenBabel__OBVirtualBond", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBConformerData = {"_p_p_OpenBabel__OBConformerData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBUnitCell = {"_p_p_OpenBabel__OBUnitCell", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_double = {"_p_p_double", "double **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_int = {"_p_p_int", "int **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__dequeTint_t = {"_p_std__dequeTint_t", "std::deque<int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ifstream = {"_p_std__ifstream", "std::ifstream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__istream = {"_p_std__istream", "std::istream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t = {"_p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t", "std::map<char const *,OpenBabel::OBFormat *,OpenBabel::CharPtrLess > *|OpenBabel::FMapType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapTint_OpenBabel__OBAtom_p_t = {"_p_std__mapTint_OpenBabel__OBAtom_p_t", "std::map<int,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapTstd__string_std__string_t = {"_p_std__mapTstd__string_std__string_t", "std::map<std::string,std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__multimapTdouble_unsigned_int_t = {"_p_std__multimapTdouble_unsigned_int_t", "std::multimap<double,unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__out_of_range = {"_p_std__out_of_range", "std::out_of_range *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t = {"_p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t", "std::pair<OpenBabel::OBAtom *,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__streampos = {"_p_std__streampos", "std::streampos *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__type_info = {"_p_std__type_info", "std::type_info *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBAtom_p_t = {"_p_std__vectorTOpenBabel__OBAtom_p_t", "std::vector<OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBAtom_p_t__iterator = {"_p_std__vectorTOpenBabel__OBAtom_p_t__iterator", "std::vector<OpenBabel::OBAtom * >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBBond_p_t = {"_p_std__vectorTOpenBabel__OBBond_p_t", "std::vector<OpenBabel::OBBond * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBBond_p_t__iterator = {"_p_std__vectorTOpenBabel__OBBond_p_t__iterator", "std::vector<OpenBabel::OBBond * >::iterator *|OpenBabel::OBBondIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBBond_t = {"_p_std__vectorTOpenBabel__OBBond_t", "std::vector<OpenBabel::OBBond > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBExternalBond_t = {"_p_std__vectorTOpenBabel__OBExternalBond_t", "std::vector<OpenBabel::OBExternalBond > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBGenericData_p_t = {"_p_std__vectorTOpenBabel__OBGenericData_p_t", "std::vector<OpenBabel::OBGenericData * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator = {"_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator", "std::vector<OpenBabel::OBGenericData * >::iterator *|OpenBabel::OBDataIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t = {"_p_std__vectorTOpenBabel__OBInternalCoord_p_t", "std::vector<OpenBabel::OBInternalCoord * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator = {"_p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator", "std::vector<OpenBabel::OBInternalCoord * >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBMol_t = {"_p_std__vectorTOpenBabel__OBMol_t", "std::vector<OpenBabel::OBMol > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBResidue_p_t__iterator = {"_p_std__vectorTOpenBabel__OBResidue_p_t__iterator", "std::vector<OpenBabel::OBResidue * >::iterator *|OpenBabel::OBResidueIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBResidue_t = {"_p_std__vectorTOpenBabel__OBResidue_t", "std::vector<OpenBabel::OBResidue > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBRing_p_t = {"_p_std__vectorTOpenBabel__OBRing_p_t", "std::vector<OpenBabel::OBRing * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBRing_p_t__iterator = {"_p_std__vectorTOpenBabel__OBRing_p_t__iterator", "std::vector<OpenBabel::OBRing * >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBRing_t = {"_p_std__vectorTOpenBabel__OBRing_t", "std::vector<OpenBabel::OBRing > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBTorsion_t = {"_p_std__vectorTOpenBabel__OBTorsion_t", "std::vector<OpenBabel::OBTorsion > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t = {"_p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t", "std::vector<OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__vector3_t = {"_p_std__vectorTOpenBabel__vector3_t", "std::vector<OpenBabel::vector3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTdouble_p_t = {"_p_std__vectorTdouble_p_t", "std::vector<double * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTdouble_p_t__iterator = {"_p_std__vectorTdouble_p_t__iterator", "std::vector<double * >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTdouble_t = {"_p_std__vectorTdouble_t", "std::vector<double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTint_t = {"_p_std__vectorTint_t", "std::vector<int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__pairTint_int_t_t = {"_p_std__vectorTstd__pairTint_int_t_t", "std::vector<std::pair<int,int > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__pairTstd__string_std__string_t_t = {"_p_std__vectorTstd__pairTstd__string_std__string_t_t", "std::vector<std::pair<std::string,std::string > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__string_t = {"_p_std__vectorTstd__string_t", "std::vector<std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t = {"_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t", "std::vector<std::vector<OpenBabel::vector3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__vectorTint_t_t = {"_p_std__vectorTstd__vectorTint_t_t", "std::vector<std::vector<int > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__vectorTint_t_t__iterator = {"_p_std__vectorTstd__vectorTint_t_t__iterator", "std::vector<std::vector<int > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__vectorTunsigned_int_t_t = {"_p_std__vectorTstd__vectorTunsigned_int_t_t", "std::vector<std::vector<unsigned int > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTunsigned_int_t = {"_p_std__vectorTunsigned_int_t", "std::vector<unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTunsigned_short_t = {"_p_std__vectorTunsigned_short_t", "std::vector<unsigned short > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "unsigned int *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_OpenBabel__CharPtrLess,
  &_swigt__p_OpenBabel__DoubleType,
  &_swigt__p_OpenBabel__FMapType__iterator,
  &_swigt__p_OpenBabel__FastSearch,
  &_swigt__p_OpenBabel__FastSearchIndexer,
  &_swigt__p_OpenBabel__FptIndex,
  &_swigt__p_OpenBabel__FptIndexHeader,
  &_swigt__p_OpenBabel__OBAngle,
  &_swigt__p_OpenBabel__OBAngleData,
  &_swigt__p_OpenBabel__OBAromaticTyper,
  &_swigt__p_OpenBabel__OBAtom,
  &_swigt__p_OpenBabel__OBAtomAtomIter,
  &_swigt__p_OpenBabel__OBAtomBondIter,
  &_swigt__p_OpenBabel__OBAtomTyper,
  &_swigt__p_OpenBabel__OBBase,
  &_swigt__p_OpenBabel__OBBitVec,
  &_swigt__p_OpenBabel__OBBond,
  &_swigt__p_OpenBabel__OBChainsParser,
  &_swigt__p_OpenBabel__OBChiralData,
  &_swigt__p_OpenBabel__OBCommentData,
  &_swigt__p_OpenBabel__OBConformerData,
  &_swigt__p_OpenBabel__OBConversion,
  &_swigt__p_OpenBabel__OBElement,
  &_swigt__p_OpenBabel__OBElementTable,
  &_swigt__p_OpenBabel__OBError,
  &_swigt__p_OpenBabel__OBExternalBond,
  &_swigt__p_OpenBabel__OBExternalBondData,
  &_swigt__p_OpenBabel__OBFFCalculation,
  &_swigt__p_OpenBabel__OBFFParameter,
  &_swigt__p_OpenBabel__OBFingerprint,
  &_swigt__p_OpenBabel__OBForceField,
  &_swigt__p_OpenBabel__OBFormat,
  &_swigt__p_OpenBabel__OBGenericData,
  &_swigt__p_OpenBabel__OBGlobalDataBase,
  &_swigt__p_OpenBabel__OBInternalCoord,
  &_swigt__p_OpenBabel__OBIsotopeTable,
  &_swigt__p_OpenBabel__OBMessageHandler,
  &_swigt__p_OpenBabel__OBMol,
  &_swigt__p_OpenBabel__OBMolAngleIter,
  &_swigt__p_OpenBabel__OBMolAtomBFSIter,
  &_swigt__p_OpenBabel__OBMolAtomDFSIter,
  &_swigt__p_OpenBabel__OBMolAtomIter,
  &_swigt__p_OpenBabel__OBMolBondIter,
  &_swigt__p_OpenBabel__OBMolPairIter,
  &_swigt__p_OpenBabel__OBMolRingIter,
  &_swigt__p_OpenBabel__OBMolTorsionIter,
  &_swigt__p_OpenBabel__OBPairData,
  &_swigt__p_OpenBabel__OBPairTemplateTdouble_t,
  &_swigt__p_OpenBabel__OBPairTemplateTint_t,
  &_swigt__p_OpenBabel__OBRTree,
  &_swigt__p_OpenBabel__OBRandom,
  &_swigt__p_OpenBabel__OBResidue,
  &_swigt__p_OpenBabel__OBResidueAtomIter,
  &_swigt__p_OpenBabel__OBResidueData,
  &_swigt__p_OpenBabel__OBResidueIter,
  &_swigt__p_OpenBabel__OBRing,
  &_swigt__p_OpenBabel__OBRingData,
  &_swigt__p_OpenBabel__OBRingSearch,
  &_swigt__p_OpenBabel__OBSSMatch,
  &_swigt__p_OpenBabel__OBSerialNums,
  &_swigt__p_OpenBabel__OBSetData,
  &_swigt__p_OpenBabel__OBSmartsPattern,
  &_swigt__p_OpenBabel__OBSqrtTbl,
  &_swigt__p_OpenBabel__OBStopwatch,
  &_swigt__p_OpenBabel__OBSymmetryData,
  &_swigt__p_OpenBabel__OBTorsion,
  &_swigt__p_OpenBabel__OBTorsionData,
  &_swigt__p_OpenBabel__OBTypeTable,
  &_swigt__p_OpenBabel__OBUnitCell,
  &_swigt__p_OpenBabel__OBVibrationData,
  &_swigt__p_OpenBabel__OBVirtualBond,
  &_swigt__p_OpenBabel__Pattern,
  &_swigt__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t,
  &_swigt__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t,
  &_swigt__p_OpenBabel__Template,
  &_swigt__p_OpenBabel__matrix3x3,
  &_swigt__p_OpenBabel__obLogBuf,
  &_swigt__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  &_swigt__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  &_swigt__p_OpenBabel__vector3,
  &_swigt__p_a_3__double,
  &_swigt__p_a_4__char,
  &_swigt__p_char,
  &_swigt__p_double,
  &_swigt__p_int,
  &_swigt__p_p_OpenBabel__OBAngleData,
  &_swigt__p_p_OpenBabel__OBChiralData,
  &_swigt__p_p_OpenBabel__OBCommentData,
  &_swigt__p_p_OpenBabel__OBConformerData,
  &_swigt__p_p_OpenBabel__OBExternalBondData,
  &_swigt__p_p_OpenBabel__OBFormat,
  &_swigt__p_p_OpenBabel__OBGenericData,
  &_swigt__p_p_OpenBabel__OBPairData,
  &_swigt__p_p_OpenBabel__OBRingData,
  &_swigt__p_p_OpenBabel__OBSerialNums,
  &_swigt__p_p_OpenBabel__OBSetData,
  &_swigt__p_p_OpenBabel__OBSymmetryData,
  &_swigt__p_p_OpenBabel__OBTorsionData,
  &_swigt__p_p_OpenBabel__OBUnitCell,
  &_swigt__p_p_OpenBabel__OBVibrationData,
  &_swigt__p_p_OpenBabel__OBVirtualBond,
  &_swigt__p_p_double,
  &_swigt__p_p_int,
  &_swigt__p_std__dequeTint_t,
  &_swigt__p_std__ifstream,
  &_swigt__p_std__istream,
  &_swigt__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t,
  &_swigt__p_std__mapTint_OpenBabel__OBAtom_p_t,
  &_swigt__p_std__mapTstd__string_std__string_t,
  &_swigt__p_std__multimapTdouble_unsigned_int_t,
  &_swigt__p_std__ostream,
  &_swigt__p_std__out_of_range,
  &_swigt__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  &_swigt__p_std__streampos,
  &_swigt__p_std__string,
  &_swigt__p_std__type_info,
  &_swigt__p_std__vectorTOpenBabel__OBAtom_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBAtom_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBBond_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBBond_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBBond_t,
  &_swigt__p_std__vectorTOpenBabel__OBExternalBond_t,
  &_swigt__p_std__vectorTOpenBabel__OBGenericData_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBMol_t,
  &_swigt__p_std__vectorTOpenBabel__OBResidue_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBResidue_t,
  &_swigt__p_std__vectorTOpenBabel__OBRing_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBRing_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBRing_t,
  &_swigt__p_std__vectorTOpenBabel__OBTorsion_t,
  &_swigt__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t,
  &_swigt__p_std__vectorTOpenBabel__vector3_t,
  &_swigt__p_std__vectorTdouble_p_t,
  &_swigt__p_std__vectorTdouble_p_t__iterator,
  &_swigt__p_std__vectorTdouble_t,
  &_swigt__p_std__vectorTint_t,
  &_swigt__p_std__vectorTstd__pairTint_int_t_t,
  &_swigt__p_std__vectorTstd__pairTstd__string_std__string_t_t,
  &_swigt__p_std__vectorTstd__string_t,
  &_swigt__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,
  &_swigt__p_std__vectorTstd__vectorTint_t_t,
  &_swigt__p_std__vectorTstd__vectorTint_t_t__iterator,
  &_swigt__p_std__vectorTstd__vectorTunsigned_int_t_t,
  &_swigt__p_std__vectorTunsigned_int_t,
  &_swigt__p_std__vectorTunsigned_short_t,
  &_swigt__p_unsigned_int,
};

static swig_cast_info _swigc__p_OpenBabel__CharPtrLess[] = {  {&_swigt__p_OpenBabel__CharPtrLess, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__DoubleType[] = {  {&_swigt__p_OpenBabel__DoubleType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FMapType__iterator[] = {  {&_swigt__p_OpenBabel__FMapType__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FastSearch[] = {  {&_swigt__p_OpenBabel__FastSearch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FastSearchIndexer[] = {  {&_swigt__p_OpenBabel__FastSearchIndexer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FptIndex[] = {  {&_swigt__p_OpenBabel__FptIndex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FptIndexHeader[] = {  {&_swigt__p_OpenBabel__FptIndexHeader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAngle[] = {  {&_swigt__p_OpenBabel__OBAngle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAngleData[] = {  {&_swigt__p_OpenBabel__OBAngleData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAromaticTyper[] = {  {&_swigt__p_OpenBabel__OBAromaticTyper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtom[] = {  {&_swigt__p_OpenBabel__OBAtom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtomAtomIter[] = {  {&_swigt__p_OpenBabel__OBAtomAtomIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtomBondIter[] = {  {&_swigt__p_OpenBabel__OBAtomBondIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtomTyper[] = {  {&_swigt__p_OpenBabel__OBAtomTyper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBBase[] = {  {&_swigt__p_OpenBabel__OBMol, _p_OpenBabel__OBMolTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBResidue, _p_OpenBabel__OBResidueTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBBase, 0, 0, 0},  {&_swigt__p_OpenBabel__OBBond, _p_OpenBabel__OBBondTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBAtom, _p_OpenBabel__OBAtomTo_p_OpenBabel__OBBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBBitVec[] = {  {&_swigt__p_OpenBabel__OBBitVec, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBBond[] = {  {&_swigt__p_OpenBabel__OBBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBChainsParser[] = {  {&_swigt__p_OpenBabel__OBChainsParser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBChiralData[] = {  {&_swigt__p_OpenBabel__OBChiralData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBCommentData[] = {  {&_swigt__p_OpenBabel__OBCommentData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBConformerData[] = {  {&_swigt__p_OpenBabel__OBConformerData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBConversion[] = {  {&_swigt__p_OpenBabel__OBConversion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBElement[] = {  {&_swigt__p_OpenBabel__OBElement, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBElementTable[] = {  {&_swigt__p_OpenBabel__OBElementTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBError[] = {  {&_swigt__p_OpenBabel__OBError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBExternalBond[] = {  {&_swigt__p_OpenBabel__OBExternalBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBExternalBondData[] = {  {&_swigt__p_OpenBabel__OBExternalBondData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFCalculation[] = {  {&_swigt__p_OpenBabel__OBFFCalculation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFParameter[] = {  {&_swigt__p_OpenBabel__OBFFParameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFingerprint[] = {  {&_swigt__p_OpenBabel__OBFingerprint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBForceField[] = {  {&_swigt__p_OpenBabel__OBForceField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFormat[] = {  {&_swigt__p_OpenBabel__OBFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBGenericData[] = {  {&_swigt__p_OpenBabel__OBVibrationData, _p_OpenBabel__OBVibrationDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBTorsionData, _p_OpenBabel__OBTorsionDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBPairData, _p_OpenBabel__OBPairDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBAngleData, _p_OpenBabel__OBAngleDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBChiralData, _p_OpenBabel__OBChiralDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBRingData, _p_OpenBabel__OBRingDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSerialNums, _p_OpenBabel__OBSerialNumsTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBExternalBondData, _p_OpenBabel__OBExternalBondDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSetData, _p_OpenBabel__OBSetDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSymmetryData, _p_OpenBabel__OBSymmetryDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBCommentData, _p_OpenBabel__OBCommentDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBVirtualBond, _p_OpenBabel__OBVirtualBondTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBConformerData, _p_OpenBabel__OBConformerDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBGenericData, 0, 0, 0},  {&_swigt__p_OpenBabel__OBUnitCell, _p_OpenBabel__OBUnitCellTo_p_OpenBabel__OBGenericData, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBGlobalDataBase[] = {  {&_swigt__p_OpenBabel__OBAtomTyper, _p_OpenBabel__OBAtomTyperTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBAromaticTyper, _p_OpenBabel__OBAromaticTyperTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBGlobalDataBase, 0, 0, 0},  {&_swigt__p_OpenBabel__OBResidueData, _p_OpenBabel__OBResidueDataTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBIsotopeTable, _p_OpenBabel__OBIsotopeTableTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBTypeTable, _p_OpenBabel__OBTypeTableTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBElementTable, _p_OpenBabel__OBElementTableTo_p_OpenBabel__OBGlobalDataBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBInternalCoord[] = {  {&_swigt__p_OpenBabel__OBInternalCoord, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBIsotopeTable[] = {  {&_swigt__p_OpenBabel__OBIsotopeTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMessageHandler[] = {  {&_swigt__p_OpenBabel__OBMessageHandler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMol[] = {  {&_swigt__p_OpenBabel__OBMol, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAngleIter[] = {  {&_swigt__p_OpenBabel__OBMolAngleIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAtomBFSIter[] = {  {&_swigt__p_OpenBabel__OBMolAtomBFSIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAtomDFSIter[] = {  {&_swigt__p_OpenBabel__OBMolAtomDFSIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAtomIter[] = {  {&_swigt__p_OpenBabel__OBMolAtomIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolBondIter[] = {  {&_swigt__p_OpenBabel__OBMolBondIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolPairIter[] = {  {&_swigt__p_OpenBabel__OBMolPairIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolRingIter[] = {  {&_swigt__p_OpenBabel__OBMolRingIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolTorsionIter[] = {  {&_swigt__p_OpenBabel__OBMolTorsionIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPairData[] = {  {&_swigt__p_OpenBabel__OBPairData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPairTemplateTdouble_t[] = {  {&_swigt__p_OpenBabel__OBPairTemplateTdouble_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPairTemplateTint_t[] = {  {&_swigt__p_OpenBabel__OBPairTemplateTint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRTree[] = {  {&_swigt__p_OpenBabel__OBRTree, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRandom[] = {  {&_swigt__p_OpenBabel__OBRandom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidue[] = {  {&_swigt__p_OpenBabel__OBResidue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidueAtomIter[] = {  {&_swigt__p_OpenBabel__OBResidueAtomIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidueData[] = {  {&_swigt__p_OpenBabel__OBResidueData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidueIter[] = {  {&_swigt__p_OpenBabel__OBResidueIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRing[] = {  {&_swigt__p_OpenBabel__OBRing, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRingData[] = {  {&_swigt__p_OpenBabel__OBRingData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRingSearch[] = {  {&_swigt__p_OpenBabel__OBRingSearch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSSMatch[] = {  {&_swigt__p_OpenBabel__OBSSMatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSerialNums[] = {  {&_swigt__p_OpenBabel__OBSerialNums, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSetData[] = {  {&_swigt__p_OpenBabel__OBSetData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSmartsPattern[] = {  {&_swigt__p_OpenBabel__OBSmartsPattern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSqrtTbl[] = {  {&_swigt__p_OpenBabel__OBSqrtTbl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBStopwatch[] = {  {&_swigt__p_OpenBabel__OBStopwatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSymmetryData[] = {  {&_swigt__p_OpenBabel__OBSymmetryData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBTorsion[] = {  {&_swigt__p_OpenBabel__OBTorsion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBTorsionData[] = {  {&_swigt__p_OpenBabel__OBTorsionData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBTypeTable[] = {  {&_swigt__p_OpenBabel__OBTypeTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBUnitCell[] = {  {&_swigt__p_OpenBabel__OBUnitCell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBVibrationData[] = {  {&_swigt__p_OpenBabel__OBVibrationData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBVirtualBond[] = {  {&_swigt__p_OpenBabel__OBVirtualBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__Pattern[] = {  {&_swigt__p_OpenBabel__Pattern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t[] = {  {&_swigt__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t[] = {  {&_swigt__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__Template[] = {  {&_swigt__p_OpenBabel__Template, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__matrix3x3[] = {  {&_swigt__p_OpenBabel__matrix3x3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__obLogBuf[] = {  {&_swigt__p_OpenBabel__obLogBuf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__vector3[] = {  {&_swigt__p_OpenBabel__vector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_3__double[] = {  {&_swigt__p_a_3__double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__char[] = {  {&_swigt__p_a_4__char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBFormat[] = {  {&_swigt__p_p_OpenBabel__OBFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBVibrationData[] = {{&_swigt__p_p_OpenBabel__OBVibrationData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBTorsionData[] = {{&_swigt__p_p_OpenBabel__OBTorsionData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBPairData[] = {{&_swigt__p_p_OpenBabel__OBPairData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBAngleData[] = {{&_swigt__p_p_OpenBabel__OBAngleData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBChiralData[] = {{&_swigt__p_p_OpenBabel__OBChiralData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBRingData[] = {{&_swigt__p_p_OpenBabel__OBRingData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBSerialNums[] = {{&_swigt__p_p_OpenBabel__OBSerialNums, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBExternalBondData[] = {{&_swigt__p_p_OpenBabel__OBExternalBondData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBSetData[] = {{&_swigt__p_p_OpenBabel__OBSetData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBSymmetryData[] = {{&_swigt__p_p_OpenBabel__OBSymmetryData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBCommentData[] = {{&_swigt__p_p_OpenBabel__OBCommentData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBVirtualBond[] = {{&_swigt__p_p_OpenBabel__OBVirtualBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBConformerData[] = {{&_swigt__p_p_OpenBabel__OBConformerData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBUnitCell[] = {{&_swigt__p_p_OpenBabel__OBUnitCell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBGenericData[] = {  {&_swigt__p_p_OpenBabel__OBVibrationData, _p_p_OpenBabel__OBVibrationDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBTorsionData, _p_p_OpenBabel__OBTorsionDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBPairData, _p_p_OpenBabel__OBPairDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBAngleData, _p_p_OpenBabel__OBAngleDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBChiralData, _p_p_OpenBabel__OBChiralDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBRingData, _p_p_OpenBabel__OBRingDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBSerialNums, _p_p_OpenBabel__OBSerialNumsTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBExternalBondData, _p_p_OpenBabel__OBExternalBondDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBSetData, _p_p_OpenBabel__OBSetDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBSymmetryData, _p_p_OpenBabel__OBSymmetryDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBCommentData, _p_p_OpenBabel__OBCommentDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBVirtualBond, _p_p_OpenBabel__OBVirtualBondTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBConformerData, _p_p_OpenBabel__OBConformerDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBGenericData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBUnitCell, _p_p_OpenBabel__OBUnitCellTo_p_p_OpenBabel__OBGenericData, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_double[] = {  {&_swigt__p_p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_int[] = {  {&_swigt__p_p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__dequeTint_t[] = {  {&_swigt__p_std__dequeTint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ifstream[] = {  {&_swigt__p_std__ifstream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__istream[] = {  {&_swigt__p_std__istream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t[] = {  {&_swigt__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTint_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_std__mapTint_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTstd__string_std__string_t[] = {  {&_swigt__p_std__mapTstd__string_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__multimapTdouble_unsigned_int_t[] = {  {&_swigt__p_std__multimapTdouble_unsigned_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__out_of_range[] = {  {&_swigt__p_std__out_of_range, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__streampos[] = {  {&_swigt__p_std__streampos, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__type_info[] = {  {&_swigt__p_std__type_info, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBAtom_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBAtom_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBAtom_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBBond_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBBond_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBBond_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBBond_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBBond_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBBond_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBExternalBond_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBExternalBond_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBGenericData_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBGenericData_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBInternalCoord_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBMol_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBMol_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBResidue_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBResidue_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBResidue_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBResidue_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBRing_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBRing_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBRing_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBRing_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBRing_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBRing_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBTorsion_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBTorsion_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t[] = {  {&_swigt__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__vector3_t[] = {  {&_swigt__p_std__vectorTOpenBabel__vector3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTdouble_p_t[] = {  {&_swigt__p_std__vectorTdouble_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTdouble_p_t__iterator[] = {  {&_swigt__p_std__vectorTdouble_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTdouble_t[] = {  {&_swigt__p_std__vectorTdouble_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTint_t[] = {  {&_swigt__p_std__vectorTint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__pairTint_int_t_t[] = {  {&_swigt__p_std__vectorTstd__pairTint_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__pairTstd__string_std__string_t_t[] = {  {&_swigt__p_std__vectorTstd__pairTstd__string_std__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__string_t[] = {  {&_swigt__p_std__vectorTstd__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t[] = {  {&_swigt__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__vectorTint_t_t[] = {  {&_swigt__p_std__vectorTstd__vectorTint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__vectorTint_t_t__iterator[] = {  {&_swigt__p_std__vectorTstd__vectorTint_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__vectorTunsigned_int_t_t[] = {  {&_swigt__p_std__vectorTstd__vectorTunsigned_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTunsigned_int_t[] = {  {&_swigt__p_std__vectorTunsigned_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTunsigned_short_t[] = {  {&_swigt__p_std__vectorTunsigned_short_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_OpenBabel__CharPtrLess,
  _swigc__p_OpenBabel__DoubleType,
  _swigc__p_OpenBabel__FMapType__iterator,
  _swigc__p_OpenBabel__FastSearch,
  _swigc__p_OpenBabel__FastSearchIndexer,
  _swigc__p_OpenBabel__FptIndex,
  _swigc__p_OpenBabel__FptIndexHeader,
  _swigc__p_OpenBabel__OBAngle,
  _swigc__p_OpenBabel__OBAngleData,
  _swigc__p_OpenBabel__OBAromaticTyper,
  _swigc__p_OpenBabel__OBAtom,
  _swigc__p_OpenBabel__OBAtomAtomIter,
  _swigc__p_OpenBabel__OBAtomBondIter,
  _swigc__p_OpenBabel__OBAtomTyper,
  _swigc__p_OpenBabel__OBBase,
  _swigc__p_OpenBabel__OBBitVec,
  _swigc__p_OpenBabel__OBBond,
  _swigc__p_OpenBabel__OBChainsParser,
  _swigc__p_OpenBabel__OBChiralData,
  _swigc__p_OpenBabel__OBCommentData,
  _swigc__p_OpenBabel__OBConformerData,
  _swigc__p_OpenBabel__OBConversion,
  _swigc__p_OpenBabel__OBElement,
  _swigc__p_OpenBabel__OBElementTable,
  _swigc__p_OpenBabel__OBError,
  _swigc__p_OpenBabel__OBExternalBond,
  _swigc__p_OpenBabel__OBExternalBondData,
  _swigc__p_OpenBabel__OBFFCalculation,
  _swigc__p_OpenBabel__OBFFParameter,
  _swigc__p_OpenBabel__OBFingerprint,
  _swigc__p_OpenBabel__OBForceField,
  _swigc__p_OpenBabel__OBFormat,
  _swigc__p_OpenBabel__OBGenericData,
  _swigc__p_OpenBabel__OBGlobalDataBase,
  _swigc__p_OpenBabel__OBInternalCoord,
  _swigc__p_OpenBabel__OBIsotopeTable,
  _swigc__p_OpenBabel__OBMessageHandler,
  _swigc__p_OpenBabel__OBMol,
  _swigc__p_OpenBabel__OBMolAngleIter,
  _swigc__p_OpenBabel__OBMolAtomBFSIter,
  _swigc__p_OpenBabel__OBMolAtomDFSIter,
  _swigc__p_OpenBabel__OBMolAtomIter,
  _swigc__p_OpenBabel__OBMolBondIter,
  _swigc__p_OpenBabel__OBMolPairIter,
  _swigc__p_OpenBabel__OBMolRingIter,
  _swigc__p_OpenBabel__OBMolTorsionIter,
  _swigc__p_OpenBabel__OBPairData,
  _swigc__p_OpenBabel__OBPairTemplateTdouble_t,
  _swigc__p_OpenBabel__OBPairTemplateTint_t,
  _swigc__p_OpenBabel__OBRTree,
  _swigc__p_OpenBabel__OBRandom,
  _swigc__p_OpenBabel__OBResidue,
  _swigc__p_OpenBabel__OBResidueAtomIter,
  _swigc__p_OpenBabel__OBResidueData,
  _swigc__p_OpenBabel__OBResidueIter,
  _swigc__p_OpenBabel__OBRing,
  _swigc__p_OpenBabel__OBRingData,
  _swigc__p_OpenBabel__OBRingSearch,
  _swigc__p_OpenBabel__OBSSMatch,
  _swigc__p_OpenBabel__OBSerialNums,
  _swigc__p_OpenBabel__OBSetData,
  _swigc__p_OpenBabel__OBSmartsPattern,
  _swigc__p_OpenBabel__OBSqrtTbl,
  _swigc__p_OpenBabel__OBStopwatch,
  _swigc__p_OpenBabel__OBSymmetryData,
  _swigc__p_OpenBabel__OBTorsion,
  _swigc__p_OpenBabel__OBTorsionData,
  _swigc__p_OpenBabel__OBTypeTable,
  _swigc__p_OpenBabel__OBUnitCell,
  _swigc__p_OpenBabel__OBVibrationData,
  _swigc__p_OpenBabel__OBVirtualBond,
  _swigc__p_OpenBabel__Pattern,
  _swigc__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t,
  _swigc__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t,
  _swigc__p_OpenBabel__Template,
  _swigc__p_OpenBabel__matrix3x3,
  _swigc__p_OpenBabel__obLogBuf,
  _swigc__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  _swigc__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  _swigc__p_OpenBabel__vector3,
  _swigc__p_a_3__double,
  _swigc__p_a_4__char,
  _swigc__p_char,
  _swigc__p_double,
  _swigc__p_int,
  _swigc__p_p_OpenBabel__OBAngleData,
  _swigc__p_p_OpenBabel__OBChiralData,
  _swigc__p_p_OpenBabel__OBCommentData,
  _swigc__p_p_OpenBabel__OBConformerData,
  _swigc__p_p_OpenBabel__OBExternalBondData,
  _swigc__p_p_OpenBabel__OBFormat,
  _swigc__p_p_OpenBabel__OBGenericData,
  _swigc__p_p_OpenBabel__OBPairData,
  _swigc__p_p_OpenBabel__OBRingData,
  _swigc__p_p_OpenBabel__OBSerialNums,
  _swigc__p_p_OpenBabel__OBSetData,
  _swigc__p_p_OpenBabel__OBSymmetryData,
  _swigc__p_p_OpenBabel__OBTorsionData,
  _swigc__p_p_OpenBabel__OBUnitCell,
  _swigc__p_p_OpenBabel__OBVibrationData,
  _swigc__p_p_OpenBabel__OBVirtualBond,
  _swigc__p_p_double,
  _swigc__p_p_int,
  _swigc__p_std__dequeTint_t,
  _swigc__p_std__ifstream,
  _swigc__p_std__istream,
  _swigc__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t,
  _swigc__p_std__mapTint_OpenBabel__OBAtom_p_t,
  _swigc__p_std__mapTstd__string_std__string_t,
  _swigc__p_std__multimapTdouble_unsigned_int_t,
  _swigc__p_std__ostream,
  _swigc__p_std__out_of_range,
  _swigc__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  _swigc__p_std__streampos,
  _swigc__p_std__string,
  _swigc__p_std__type_info,
  _swigc__p_std__vectorTOpenBabel__OBAtom_p_t,
  _swigc__p_std__vectorTOpenBabel__OBAtom_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBBond_p_t,
  _swigc__p_std__vectorTOpenBabel__OBBond_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBBond_t,
  _swigc__p_std__vectorTOpenBabel__OBExternalBond_t,
  _swigc__p_std__vectorTOpenBabel__OBGenericData_p_t,
  _swigc__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBInternalCoord_p_t,
  _swigc__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBMol_t,
  _swigc__p_std__vectorTOpenBabel__OBResidue_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBResidue_t,
  _swigc__p_std__vectorTOpenBabel__OBRing_p_t,
  _swigc__p_std__vectorTOpenBabel__OBRing_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBRing_t,
  _swigc__p_std__vectorTOpenBabel__OBTorsion_t,
  _swigc__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t,
  _swigc__p_std__vectorTOpenBabel__vector3_t,
  _swigc__p_std__vectorTdouble_p_t,
  _swigc__p_std__vectorTdouble_p_t__iterator,
  _swigc__p_std__vectorTdouble_t,
  _swigc__p_std__vectorTint_t,
  _swigc__p_std__vectorTstd__pairTint_int_t_t,
  _swigc__p_std__vectorTstd__pairTstd__string_std__string_t_t,
  _swigc__p_std__vectorTstd__string_t,
  _swigc__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,
  _swigc__p_std__vectorTstd__vectorTint_t_t,
  _swigc__p_std__vectorTstd__vectorTint_t_t__iterator,
  _swigc__p_std__vectorTstd__vectorTunsigned_int_t_t,
  _swigc__p_std__vectorTunsigned_int_t,
  _swigc__p_std__vectorTunsigned_short_t,
  _swigc__p_unsigned_int,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_openbabel(void) {
  size_t i;
  
  SWIG_InitRuntime();
  mOpenbabel = rb_define_module("Openbabel");
  
  SWIG_InitializeModule(0);
  for (i = 0; i < swig_module.size; i++) {
    SWIG_define_class(swig_module.types[i]);
  }
  
  SWIG_RubyInitializeTrackings();
  
  cVectorInt.klass = rb_define_class_under(mOpenbabel, "VectorInt", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTint_t, (void *) &cVectorInt);
  rb_include_module(cVectorInt.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorInt.klass, _wrap_vectorInt_allocate);
  rb_define_method(cVectorInt.klass, "initialize", VALUEFUNC(_wrap_new_vectorInt), -1);
  rb_define_method(cVectorInt.klass, "length", VALUEFUNC(_wrap_vectorInt___len__), -1);
  rb_define_method(cVectorInt.klass, "empty?", VALUEFUNC(_wrap_vectorInt_emptyq___), -1);
  rb_define_method(cVectorInt.klass, "clear", VALUEFUNC(_wrap_vectorInt_clear), -1);
  rb_define_method(cVectorInt.klass, "push", VALUEFUNC(_wrap_vectorInt_push), -1);
  rb_define_method(cVectorInt.klass, "pop", VALUEFUNC(_wrap_vectorInt_pop), -1);
  rb_define_method(cVectorInt.klass, "[]", VALUEFUNC(_wrap_vectorInt___getitem__), -1);
  rb_define_method(cVectorInt.klass, "[]=", VALUEFUNC(_wrap_vectorInt___setitem__), -1);
  rb_define_method(cVectorInt.klass, "each", VALUEFUNC(_wrap_vectorInt_each), -1);
  cVectorInt.mark = 0;
  cVectorInt.destroy = (void (*)(void *)) free_std_vector_Sl_int_Sg_;
  cVectorInt.trackObjects = 0;
  
  cVectorUnsignedInt.klass = rb_define_class_under(mOpenbabel, "VectorUnsignedInt", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTunsigned_int_t, (void *) &cVectorUnsignedInt);
  rb_include_module(cVectorUnsignedInt.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorUnsignedInt.klass, _wrap_vectorUnsignedInt_allocate);
  rb_define_method(cVectorUnsignedInt.klass, "initialize", VALUEFUNC(_wrap_new_vectorUnsignedInt), -1);
  rb_define_method(cVectorUnsignedInt.klass, "length", VALUEFUNC(_wrap_vectorUnsignedInt___len__), -1);
  rb_define_method(cVectorUnsignedInt.klass, "empty?", VALUEFUNC(_wrap_vectorUnsignedInt_emptyq___), -1);
  rb_define_method(cVectorUnsignedInt.klass, "clear", VALUEFUNC(_wrap_vectorUnsignedInt_clear), -1);
  rb_define_method(cVectorUnsignedInt.klass, "push", VALUEFUNC(_wrap_vectorUnsignedInt_push), -1);
  rb_define_method(cVectorUnsignedInt.klass, "pop", VALUEFUNC(_wrap_vectorUnsignedInt_pop), -1);
  rb_define_method(cVectorUnsignedInt.klass, "[]", VALUEFUNC(_wrap_vectorUnsignedInt___getitem__), -1);
  rb_define_method(cVectorUnsignedInt.klass, "[]=", VALUEFUNC(_wrap_vectorUnsignedInt___setitem__), -1);
  rb_define_method(cVectorUnsignedInt.klass, "each", VALUEFUNC(_wrap_vectorUnsignedInt_each), -1);
  cVectorUnsignedInt.mark = 0;
  cVectorUnsignedInt.destroy = (void (*)(void *)) free_std_vector_Sl_unsigned_SS_int_Sg_;
  cVectorUnsignedInt.trackObjects = 0;
  
  cVvInt.klass = rb_define_class_under(mOpenbabel, "VvInt", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, (void *) &cVvInt);
  rb_include_module(cVvInt.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVvInt.klass, _wrap_vvInt_allocate);
  rb_define_method(cVvInt.klass, "initialize", VALUEFUNC(_wrap_new_vvInt), -1);
  rb_define_method(cVvInt.klass, "length", VALUEFUNC(_wrap_vvInt___len__), -1);
  rb_define_method(cVvInt.klass, "empty?", VALUEFUNC(_wrap_vvInt_emptyq___), -1);
  rb_define_method(cVvInt.klass, "clear", VALUEFUNC(_wrap_vvInt_clear), -1);
  rb_define_method(cVvInt.klass, "push", VALUEFUNC(_wrap_vvInt_push), -1);
  rb_define_method(cVvInt.klass, "pop", VALUEFUNC(_wrap_vvInt_pop), -1);
  rb_define_method(cVvInt.klass, "[]", VALUEFUNC(_wrap_vvInt___getitem__), -1);
  rb_define_method(cVvInt.klass, "[]=", VALUEFUNC(_wrap_vvInt___setitem__), -1);
  rb_define_method(cVvInt.klass, "each", VALUEFUNC(_wrap_vvInt_each), -1);
  cVvInt.mark = 0;
  cVvInt.destroy = (void (*)(void *)) free_std_vector_Sl_std_vector_Sl_int_Sg__Sg_;
  cVvInt.trackObjects = 0;
  
  cVectorDouble.klass = rb_define_class_under(mOpenbabel, "VectorDouble", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTdouble_t, (void *) &cVectorDouble);
  rb_include_module(cVectorDouble.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorDouble.klass, _wrap_vectorDouble_allocate);
  rb_define_method(cVectorDouble.klass, "initialize", VALUEFUNC(_wrap_new_vectorDouble), -1);
  rb_define_method(cVectorDouble.klass, "length", VALUEFUNC(_wrap_vectorDouble___len__), -1);
  rb_define_method(cVectorDouble.klass, "empty?", VALUEFUNC(_wrap_vectorDouble_emptyq___), -1);
  rb_define_method(cVectorDouble.klass, "clear", VALUEFUNC(_wrap_vectorDouble_clear), -1);
  rb_define_method(cVectorDouble.klass, "push", VALUEFUNC(_wrap_vectorDouble_push), -1);
  rb_define_method(cVectorDouble.klass, "pop", VALUEFUNC(_wrap_vectorDouble_pop), -1);
  rb_define_method(cVectorDouble.klass, "[]", VALUEFUNC(_wrap_vectorDouble___getitem__), -1);
  rb_define_method(cVectorDouble.klass, "[]=", VALUEFUNC(_wrap_vectorDouble___setitem__), -1);
  rb_define_method(cVectorDouble.klass, "each", VALUEFUNC(_wrap_vectorDouble_each), -1);
  cVectorDouble.mark = 0;
  cVectorDouble.destroy = (void (*)(void *)) free_std_vector_Sl_double_Sg_;
  cVectorDouble.trackObjects = 0;
  
  cVVector3.klass = rb_define_class_under(mOpenbabel, "VVector3", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, (void *) &cVVector3);
  rb_include_module(cVVector3.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVVector3.klass, _wrap_vVector3_allocate);
  rb_define_method(cVVector3.klass, "initialize", VALUEFUNC(_wrap_new_vVector3), -1);
  rb_define_method(cVVector3.klass, "length", VALUEFUNC(_wrap_vVector3___len__), -1);
  rb_define_method(cVVector3.klass, "empty?", VALUEFUNC(_wrap_vVector3_emptyq___), -1);
  rb_define_method(cVVector3.klass, "clear", VALUEFUNC(_wrap_vVector3_clear), -1);
  rb_define_method(cVVector3.klass, "push", VALUEFUNC(_wrap_vVector3_push), -1);
  rb_define_method(cVVector3.klass, "pop", VALUEFUNC(_wrap_vVector3_pop), -1);
  rb_define_method(cVVector3.klass, "[]", VALUEFUNC(_wrap_vVector3___getitem__), -1);
  rb_define_method(cVVector3.klass, "[]=", VALUEFUNC(_wrap_vVector3___setitem__), -1);
  rb_define_method(cVVector3.klass, "each", VALUEFUNC(_wrap_vVector3_each), -1);
  cVVector3.mark = 0;
  cVVector3.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_vector3_Sg_;
  cVVector3.trackObjects = 0;
  
  cVectorMol.klass = rb_define_class_under(mOpenbabel, "VectorMol", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, (void *) &cVectorMol);
  rb_include_module(cVectorMol.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorMol.klass, _wrap_vectorMol_allocate);
  rb_define_method(cVectorMol.klass, "initialize", VALUEFUNC(_wrap_new_vectorMol), -1);
  rb_define_method(cVectorMol.klass, "length", VALUEFUNC(_wrap_vectorMol___len__), -1);
  rb_define_method(cVectorMol.klass, "empty?", VALUEFUNC(_wrap_vectorMol_emptyq___), -1);
  rb_define_method(cVectorMol.klass, "clear", VALUEFUNC(_wrap_vectorMol_clear), -1);
  rb_define_method(cVectorMol.klass, "push", VALUEFUNC(_wrap_vectorMol_push), -1);
  rb_define_method(cVectorMol.klass, "pop", VALUEFUNC(_wrap_vectorMol_pop), -1);
  rb_define_method(cVectorMol.klass, "[]", VALUEFUNC(_wrap_vectorMol___getitem__), -1);
  rb_define_method(cVectorMol.klass, "[]=", VALUEFUNC(_wrap_vectorMol___setitem__), -1);
  rb_define_method(cVectorMol.klass, "each", VALUEFUNC(_wrap_vectorMol_each), -1);
  cVectorMol.mark = 0;
  cVectorMol.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBMol_Sg_;
  cVectorMol.trackObjects = 0;
  
  cVectorBond.klass = rb_define_class_under(mOpenbabel, "VectorBond", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, (void *) &cVectorBond);
  rb_include_module(cVectorBond.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorBond.klass, _wrap_vectorBond_allocate);
  rb_define_method(cVectorBond.klass, "initialize", VALUEFUNC(_wrap_new_vectorBond), -1);
  rb_define_method(cVectorBond.klass, "length", VALUEFUNC(_wrap_vectorBond___len__), -1);
  rb_define_method(cVectorBond.klass, "empty?", VALUEFUNC(_wrap_vectorBond_emptyq___), -1);
  rb_define_method(cVectorBond.klass, "clear", VALUEFUNC(_wrap_vectorBond_clear), -1);
  rb_define_method(cVectorBond.klass, "push", VALUEFUNC(_wrap_vectorBond_push), -1);
  rb_define_method(cVectorBond.klass, "pop", VALUEFUNC(_wrap_vectorBond_pop), -1);
  rb_define_method(cVectorBond.klass, "[]", VALUEFUNC(_wrap_vectorBond___getitem__), -1);
  rb_define_method(cVectorBond.klass, "[]=", VALUEFUNC(_wrap_vectorBond___setitem__), -1);
  rb_define_method(cVectorBond.klass, "each", VALUEFUNC(_wrap_vectorBond_each), -1);
  cVectorBond.mark = 0;
  cVectorBond.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBBond_Sg_;
  cVectorBond.trackObjects = 0;
  
  cVectorResidue.klass = rb_define_class_under(mOpenbabel, "VectorResidue", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, (void *) &cVectorResidue);
  rb_include_module(cVectorResidue.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorResidue.klass, _wrap_vectorResidue_allocate);
  rb_define_method(cVectorResidue.klass, "initialize", VALUEFUNC(_wrap_new_vectorResidue), -1);
  rb_define_method(cVectorResidue.klass, "length", VALUEFUNC(_wrap_vectorResidue___len__), -1);
  rb_define_method(cVectorResidue.klass, "empty?", VALUEFUNC(_wrap_vectorResidue_emptyq___), -1);
  rb_define_method(cVectorResidue.klass, "clear", VALUEFUNC(_wrap_vectorResidue_clear), -1);
  rb_define_method(cVectorResidue.klass, "push", VALUEFUNC(_wrap_vectorResidue_push), -1);
  rb_define_method(cVectorResidue.klass, "pop", VALUEFUNC(_wrap_vectorResidue_pop), -1);
  rb_define_method(cVectorResidue.klass, "[]", VALUEFUNC(_wrap_vectorResidue___getitem__), -1);
  rb_define_method(cVectorResidue.klass, "[]=", VALUEFUNC(_wrap_vectorResidue___setitem__), -1);
  rb_define_method(cVectorResidue.klass, "each", VALUEFUNC(_wrap_vectorResidue_each), -1);
  cVectorResidue.mark = 0;
  cVectorResidue.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBResidue_Sg_;
  cVectorResidue.trackObjects = 0;
  
  cVectorRing.klass = rb_define_class_under(mOpenbabel, "VectorRing", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, (void *) &cVectorRing);
  rb_include_module(cVectorRing.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorRing.klass, _wrap_vectorRing_allocate);
  rb_define_method(cVectorRing.klass, "initialize", VALUEFUNC(_wrap_new_vectorRing), -1);
  rb_define_method(cVectorRing.klass, "length", VALUEFUNC(_wrap_vectorRing___len__), -1);
  rb_define_method(cVectorRing.klass, "empty?", VALUEFUNC(_wrap_vectorRing_emptyq___), -1);
  rb_define_method(cVectorRing.klass, "clear", VALUEFUNC(_wrap_vectorRing_clear), -1);
  rb_define_method(cVectorRing.klass, "push", VALUEFUNC(_wrap_vectorRing_push), -1);
  rb_define_method(cVectorRing.klass, "pop", VALUEFUNC(_wrap_vectorRing_pop), -1);
  rb_define_method(cVectorRing.klass, "[]", VALUEFUNC(_wrap_vectorRing___getitem__), -1);
  rb_define_method(cVectorRing.klass, "[]=", VALUEFUNC(_wrap_vectorRing___setitem__), -1);
  rb_define_method(cVectorRing.klass, "each", VALUEFUNC(_wrap_vectorRing_each), -1);
  cVectorRing.mark = 0;
  cVectorRing.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBRing_Sg_;
  cVectorRing.trackObjects = 0;
  
  cVectorData.klass = rb_define_class_under(mOpenbabel, "VectorData", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, (void *) &cVectorData);
  rb_include_module(cVectorData.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorData.klass, _wrap_vectorData_allocate);
  rb_define_method(cVectorData.klass, "initialize", VALUEFUNC(_wrap_new_vectorData), -1);
  rb_define_method(cVectorData.klass, "length", VALUEFUNC(_wrap_vectorData___len__), -1);
  rb_define_method(cVectorData.klass, "empty?", VALUEFUNC(_wrap_vectorData_emptyq___), -1);
  rb_define_method(cVectorData.klass, "clear", VALUEFUNC(_wrap_vectorData_clear), -1);
  rb_define_method(cVectorData.klass, "push", VALUEFUNC(_wrap_vectorData_push), -1);
  rb_define_method(cVectorData.klass, "pop", VALUEFUNC(_wrap_vectorData_pop), -1);
  rb_define_method(cVectorData.klass, "[]", VALUEFUNC(_wrap_vectorData___getitem__), -1);
  rb_define_method(cVectorData.klass, "[]=", VALUEFUNC(_wrap_vectorData___setitem__), -1);
  rb_define_method(cVectorData.klass, "each", VALUEFUNC(_wrap_vectorData_each), -1);
  cVectorData.mark = 0;
  cVectorData.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg_;
  cVectorData.trackObjects = 0;
  
  cOBGlobalDataBase.klass = rb_define_class_under(mOpenbabel, "OBGlobalDataBase", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBGlobalDataBase, (void *) &cOBGlobalDataBase);
  rb_define_alloc_func(cOBGlobalDataBase.klass, _wrap_OBGlobalDataBase_allocate);
  rb_define_method(cOBGlobalDataBase.klass, "initialize", VALUEFUNC(_wrap_new_OBGlobalDataBase), -1);
  rb_define_method(cOBGlobalDataBase.klass, "Init", VALUEFUNC(_wrap_OBGlobalDataBase_Init), -1);
  rb_define_method(cOBGlobalDataBase.klass, "GetSize", VALUEFUNC(_wrap_OBGlobalDataBase_GetSize), -1);
  rb_define_method(cOBGlobalDataBase.klass, "SetReadDirectory", VALUEFUNC(_wrap_OBGlobalDataBase_SetReadDirectory), -1);
  rb_define_method(cOBGlobalDataBase.klass, "SetEnvironmentVariable", VALUEFUNC(_wrap_OBGlobalDataBase_SetEnvironmentVariable), -1);
  rb_define_method(cOBGlobalDataBase.klass, "ParseLine", VALUEFUNC(_wrap_OBGlobalDataBase_ParseLine), -1);
  cOBGlobalDataBase.mark = 0;
  cOBGlobalDataBase.destroy = (void (*)(void *)) free_OpenBabel_OBGlobalDataBase;
  cOBGlobalDataBase.trackObjects = 0;
  
  cOBElement.klass = rb_define_class_under(mOpenbabel, "OBElement", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBElement, (void *) &cOBElement);
  rb_define_alloc_func(cOBElement.klass, _wrap_OBElement_allocate);
  rb_define_method(cOBElement.klass, "initialize", VALUEFUNC(_wrap_new_OBElement), -1);
  rb_define_method(cOBElement.klass, "GetAtomicNum", VALUEFUNC(_wrap_OBElement_GetAtomicNum), -1);
  rb_define_method(cOBElement.klass, "GetSymbol", VALUEFUNC(_wrap_OBElement_GetSymbol), -1);
  rb_define_method(cOBElement.klass, "GetCovalentRad", VALUEFUNC(_wrap_OBElement_GetCovalentRad), -1);
  rb_define_method(cOBElement.klass, "GetVdwRad", VALUEFUNC(_wrap_OBElement_GetVdwRad), -1);
  rb_define_method(cOBElement.klass, "GetMass", VALUEFUNC(_wrap_OBElement_GetMass), -1);
  rb_define_method(cOBElement.klass, "GetMaxBonds", VALUEFUNC(_wrap_OBElement_GetMaxBonds), -1);
  rb_define_method(cOBElement.klass, "GetElectroNeg", VALUEFUNC(_wrap_OBElement_GetElectroNeg), -1);
  rb_define_method(cOBElement.klass, "GetIonization", VALUEFUNC(_wrap_OBElement_GetIonization), -1);
  rb_define_method(cOBElement.klass, "GetElectronAffinity", VALUEFUNC(_wrap_OBElement_GetElectronAffinity), -1);
  rb_define_method(cOBElement.klass, "GetName", VALUEFUNC(_wrap_OBElement_GetName), -1);
  rb_define_method(cOBElement.klass, "GetRed", VALUEFUNC(_wrap_OBElement_GetRed), -1);
  rb_define_method(cOBElement.klass, "GetGreen", VALUEFUNC(_wrap_OBElement_GetGreen), -1);
  rb_define_method(cOBElement.klass, "GetBlue", VALUEFUNC(_wrap_OBElement_GetBlue), -1);
  cOBElement.mark = 0;
  cOBElement.destroy = (void (*)(void *)) free_OpenBabel_OBElement;
  cOBElement.trackObjects = 0;
  
  cOBElementTable.klass = rb_define_class_under(mOpenbabel, "OBElementTable", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBElementTable, (void *) &cOBElementTable);
  rb_define_alloc_func(cOBElementTable.klass, _wrap_OBElementTable_allocate);
  rb_define_method(cOBElementTable.klass, "initialize", VALUEFUNC(_wrap_new_OBElementTable), -1);
  rb_define_method(cOBElementTable.klass, "ParseLine", VALUEFUNC(_wrap_OBElementTable_ParseLine), -1);
  rb_define_method(cOBElementTable.klass, "GetNumberOfElements", VALUEFUNC(_wrap_OBElementTable_GetNumberOfElements), -1);
  rb_define_method(cOBElementTable.klass, "GetSize", VALUEFUNC(_wrap_OBElementTable_GetSize), -1);
  rb_define_method(cOBElementTable.klass, "GetAtomicNum", VALUEFUNC(_wrap_OBElementTable_GetAtomicNum), -1);
  rb_define_method(cOBElementTable.klass, "GetSymbol", VALUEFUNC(_wrap_OBElementTable_GetSymbol), -1);
  rb_define_method(cOBElementTable.klass, "GetVdwRad", VALUEFUNC(_wrap_OBElementTable_GetVdwRad), -1);
  rb_define_method(cOBElementTable.klass, "GetCovalentRad", VALUEFUNC(_wrap_OBElementTable_GetCovalentRad), -1);
  rb_define_method(cOBElementTable.klass, "GetMass", VALUEFUNC(_wrap_OBElementTable_GetMass), -1);
  rb_define_method(cOBElementTable.klass, "CorrectedBondRad", VALUEFUNC(_wrap_OBElementTable_CorrectedBondRad), -1);
  rb_define_method(cOBElementTable.klass, "CorrectedVdwRad", VALUEFUNC(_wrap_OBElementTable_CorrectedVdwRad), -1);
  rb_define_method(cOBElementTable.klass, "GetMaxBonds", VALUEFUNC(_wrap_OBElementTable_GetMaxBonds), -1);
  rb_define_method(cOBElementTable.klass, "GetElectroNeg", VALUEFUNC(_wrap_OBElementTable_GetElectroNeg), -1);
  rb_define_method(cOBElementTable.klass, "GetIonization", VALUEFUNC(_wrap_OBElementTable_GetIonization), -1);
  rb_define_method(cOBElementTable.klass, "GetElectronAffinity", VALUEFUNC(_wrap_OBElementTable_GetElectronAffinity), -1);
  rb_define_method(cOBElementTable.klass, "GetRGB", VALUEFUNC(_wrap_OBElementTable_GetRGB), -1);
  rb_define_method(cOBElementTable.klass, "GetName", VALUEFUNC(_wrap_OBElementTable_GetName), -1);
  cOBElementTable.mark = 0;
  cOBElementTable.destroy = (void (*)(void *)) free_OpenBabel_OBElementTable;
  cOBElementTable.trackObjects = 0;
  
  cOBIsotopeTable.klass = rb_define_class_under(mOpenbabel, "OBIsotopeTable", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBIsotopeTable, (void *) &cOBIsotopeTable);
  rb_define_alloc_func(cOBIsotopeTable.klass, _wrap_OBIsotopeTable_allocate);
  rb_define_method(cOBIsotopeTable.klass, "initialize", VALUEFUNC(_wrap_new_OBIsotopeTable), -1);
  rb_define_method(cOBIsotopeTable.klass, "GetSize", VALUEFUNC(_wrap_OBIsotopeTable_GetSize), -1);
  rb_define_method(cOBIsotopeTable.klass, "ParseLine", VALUEFUNC(_wrap_OBIsotopeTable_ParseLine), -1);
  rb_define_method(cOBIsotopeTable.klass, "GetExactMass", VALUEFUNC(_wrap_OBIsotopeTable_GetExactMass), -1);
  cOBIsotopeTable.mark = 0;
  cOBIsotopeTable.destroy = (void (*)(void *)) free_OpenBabel_OBIsotopeTable;
  cOBIsotopeTable.trackObjects = 0;
  
  cOBTypeTable.klass = rb_define_class_under(mOpenbabel, "OBTypeTable", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBTypeTable, (void *) &cOBTypeTable);
  rb_define_alloc_func(cOBTypeTable.klass, _wrap_OBTypeTable_allocate);
  rb_define_method(cOBTypeTable.klass, "initialize", VALUEFUNC(_wrap_new_OBTypeTable), -1);
  rb_define_method(cOBTypeTable.klass, "ParseLine", VALUEFUNC(_wrap_OBTypeTable_ParseLine), -1);
  rb_define_method(cOBTypeTable.klass, "GetSize", VALUEFUNC(_wrap_OBTypeTable_GetSize), -1);
  rb_define_method(cOBTypeTable.klass, "SetFromType", VALUEFUNC(_wrap_OBTypeTable_SetFromType), -1);
  rb_define_method(cOBTypeTable.klass, "SetToType", VALUEFUNC(_wrap_OBTypeTable_SetToType), -1);
  rb_define_method(cOBTypeTable.klass, "Translate", VALUEFUNC(_wrap_OBTypeTable_Translate), -1);
  rb_define_method(cOBTypeTable.klass, "GetFromType", VALUEFUNC(_wrap_OBTypeTable_GetFromType), -1);
  rb_define_method(cOBTypeTable.klass, "GetToType", VALUEFUNC(_wrap_OBTypeTable_GetToType), -1);
  cOBTypeTable.mark = 0;
  cOBTypeTable.destroy = (void (*)(void *)) free_OpenBabel_OBTypeTable;
  cOBTypeTable.trackObjects = 0;
  
  cOBResidueData.klass = rb_define_class_under(mOpenbabel, "OBResidueData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidueData, (void *) &cOBResidueData);
  rb_define_alloc_func(cOBResidueData.klass, _wrap_OBResidueData_allocate);
  rb_define_method(cOBResidueData.klass, "initialize", VALUEFUNC(_wrap_new_OBResidueData), -1);
  rb_define_method(cOBResidueData.klass, "ParseLine", VALUEFUNC(_wrap_OBResidueData_ParseLine), -1);
  rb_define_method(cOBResidueData.klass, "GetSize", VALUEFUNC(_wrap_OBResidueData_GetSize), -1);
  rb_define_method(cOBResidueData.klass, "SetResName", VALUEFUNC(_wrap_OBResidueData_SetResName), -1);
  rb_define_method(cOBResidueData.klass, "LookupBO", VALUEFUNC(_wrap_OBResidueData_LookupBO), -1);
  rb_define_method(cOBResidueData.klass, "LookupType", VALUEFUNC(_wrap_OBResidueData_LookupType), -1);
  rb_define_method(cOBResidueData.klass, "AssignBonds", VALUEFUNC(_wrap_OBResidueData_AssignBonds), -1);
  cOBResidueData.mark = 0;
  cOBResidueData.destroy = (void (*)(void *)) free_OpenBabel_OBResidueData;
  cOBResidueData.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "OpenDatafile", VALUEFUNC(_wrap_OpenDatafile), -1);
  rb_define_const(mOpenbabel, "FILE_SEP_CHAR", SWIG_FromCharPtr("/"));
  
  cDoubleType.klass = rb_define_class_under(mOpenbabel, "DoubleType", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__DoubleType, (void *) &cDoubleType);
  rb_define_alloc_func(cDoubleType.klass, _wrap_DoubleType_allocate);
  rb_define_method(cDoubleType.klass, "initialize", VALUEFUNC(_wrap_new_DoubleType), -1);
  rb_define_method(cDoubleType.klass, "hi=", VALUEFUNC(_wrap_DoubleType_hi_set), -1);
  rb_define_method(cDoubleType.klass, "hi", VALUEFUNC(_wrap_DoubleType_hi_get), -1);
  rb_define_method(cDoubleType.klass, "lo=", VALUEFUNC(_wrap_DoubleType_lo_set), -1);
  rb_define_method(cDoubleType.klass, "lo", VALUEFUNC(_wrap_DoubleType_lo_get), -1);
  cDoubleType.mark = 0;
  cDoubleType.destroy = (void (*)(void *)) free_OpenBabel_DoubleType;
  cDoubleType.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "DoubleMultiply", VALUEFUNC(_wrap_DoubleMultiply), -1);
  rb_define_module_function(mOpenbabel, "DoubleAdd", VALUEFUNC(_wrap_DoubleAdd), -1);
  rb_define_module_function(mOpenbabel, "DoubleModulus", VALUEFUNC(_wrap_DoubleModulus), -1);
  
  cOBRandom.klass = rb_define_class_under(mOpenbabel, "OBRandom", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRandom, (void *) &cOBRandom);
  rb_define_alloc_func(cOBRandom.klass, _wrap_OBRandom_allocate);
  rb_define_method(cOBRandom.klass, "initialize", VALUEFUNC(_wrap_new_OBRandom), -1);
  rb_define_method(cOBRandom.klass, "Seed", VALUEFUNC(_wrap_OBRandom_Seed), -1);
  rb_define_method(cOBRandom.klass, "TimeSeed", VALUEFUNC(_wrap_OBRandom_TimeSeed), -1);
  rb_define_method(cOBRandom.klass, "NextInt", VALUEFUNC(_wrap_OBRandom_NextInt), -1);
  rb_define_method(cOBRandom.klass, "NextFloat", VALUEFUNC(_wrap_OBRandom_NextFloat), -1);
  cOBRandom.mark = 0;
  cOBRandom.destroy = (void (*)(void *)) free_OpenBabel_OBRandom;
  cOBRandom.trackObjects = 0;
  rb_define_const(mOpenbabel, "M_PI", SWIG_From_double(static_cast< double >(3.14159265358979323846)));
  
  cOBStopwatch.klass = rb_define_class_under(mOpenbabel, "OBStopwatch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBStopwatch, (void *) &cOBStopwatch);
  rb_define_alloc_func(cOBStopwatch.klass, _wrap_OBStopwatch_allocate);
  rb_define_method(cOBStopwatch.klass, "initialize", VALUEFUNC(_wrap_new_OBStopwatch), -1);
  rb_define_method(cOBStopwatch.klass, "Start", VALUEFUNC(_wrap_OBStopwatch_Start), -1);
  rb_define_method(cOBStopwatch.klass, "Lap", VALUEFUNC(_wrap_OBStopwatch_Lap), -1);
  rb_define_method(cOBStopwatch.klass, "Elapsed", VALUEFUNC(_wrap_OBStopwatch_Elapsed), -1);
  cOBStopwatch.mark = 0;
  cOBStopwatch.destroy = (void (*)(void *)) free_OpenBabel_OBStopwatch;
  cOBStopwatch.trackObjects = 0;
  
  cOBSqrtTbl.klass = rb_define_class_under(mOpenbabel, "OBSqrtTbl", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSqrtTbl, (void *) &cOBSqrtTbl);
  rb_define_alloc_func(cOBSqrtTbl.klass, _wrap_OBSqrtTbl_allocate);
  rb_define_method(cOBSqrtTbl.klass, "initialize", VALUEFUNC(_wrap_new_OBSqrtTbl), -1);
  rb_define_method(cOBSqrtTbl.klass, "Sqrt", VALUEFUNC(_wrap_OBSqrtTbl_Sqrt), -1);
  rb_define_method(cOBSqrtTbl.klass, "Init", VALUEFUNC(_wrap_OBSqrtTbl_Init), -1);
  cOBSqrtTbl.mark = 0;
  cOBSqrtTbl.destroy = (void (*)(void *)) free_OpenBabel_OBSqrtTbl;
  cOBSqrtTbl.trackObjects = 0;
  rb_define_const(mOpenbabel, "RAD_TO_DEG", SWIG_From_double(static_cast< double >((180.0/3.14159265358979323846))));
  rb_define_const(mOpenbabel, "DEG_TO_RAD", SWIG_From_double(static_cast< double >((3.14159265358979323846/180.0))));
  
  cVector3.klass = rb_define_class_under(mOpenbabel, "Vector3", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__vector3, (void *) &cVector3);
  rb_define_alloc_func(cVector3.klass, _wrap_vector3_allocate);
  rb_define_method(cVector3.klass, "initialize", VALUEFUNC(_wrap_new_vector3), -1);
  rb_define_method(cVector3.klass, "Set", VALUEFUNC(_wrap_vector3_Set), -1);
  rb_define_method(cVector3.klass, "SetX", VALUEFUNC(_wrap_vector3_SetX), -1);
  rb_define_method(cVector3.klass, "SetY", VALUEFUNC(_wrap_vector3_SetY), -1);
  rb_define_method(cVector3.klass, "SetZ", VALUEFUNC(_wrap_vector3_SetZ), -1);
  rb_define_method(cVector3.klass, "Get", VALUEFUNC(_wrap_vector3_Get), -1);
  rb_define_method(cVector3.klass, "AsArray", VALUEFUNC(_wrap_vector3_AsArray), -1);
  rb_define_method(cVector3.klass, "randomUnitVector", VALUEFUNC(_wrap_vector3_randomUnitVector), -1);
  rb_define_method(cVector3.klass, "normalize", VALUEFUNC(_wrap_vector3_normalize), -1);
  rb_define_method(cVector3.klass, "CanBeNormalized", VALUEFUNC(_wrap_vector3_CanBeNormalized), -1);
  rb_define_method(cVector3.klass, "length_2", VALUEFUNC(_wrap_vector3_length_2), -1);
  rb_define_method(cVector3.klass, "length", VALUEFUNC(_wrap_vector3_length), -1);
  rb_define_method(cVector3.klass, "x", VALUEFUNC(_wrap_vector3_x), -1);
  rb_define_method(cVector3.klass, "y", VALUEFUNC(_wrap_vector3_y), -1);
  rb_define_method(cVector3.klass, "z", VALUEFUNC(_wrap_vector3_z), -1);
  rb_define_method(cVector3.klass, "==", VALUEFUNC(_wrap_vector3___eq__), -1);
  rb_define_method(cVector3.klass, "IsApprox", VALUEFUNC(_wrap_vector3_IsApprox), -1);
  rb_define_method(cVector3.klass, "distSq", VALUEFUNC(_wrap_vector3_distSq), -1);
  rb_define_method(cVector3.klass, "createOrthoVector", VALUEFUNC(_wrap_vector3_createOrthoVector), -1);
  cVector3.mark = 0;
  cVector3.destroy = (void (*)(void *)) free_OpenBabel_vector3;
  cVector3.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "<<", VALUEFUNC(_wrap___lshift__), -1);
  rb_define_module_function(mOpenbabel, "+", VALUEFUNC(_wrap___add__), -1);
  rb_define_module_function(mOpenbabel, "-", VALUEFUNC(_wrap___sub__), -1);
  rb_define_module_function(mOpenbabel, "/", VALUEFUNC(_wrap___div__), -1);
  rb_define_module_function(mOpenbabel, "*", VALUEFUNC(_wrap___mul__), -1);
  rb_define_module_function(mOpenbabel, "dot", VALUEFUNC(_wrap_dot), -1);
  rb_define_module_function(mOpenbabel, "cross", VALUEFUNC(_wrap_cross), -1);
  rb_define_module_function(mOpenbabel, "vectorAngle", VALUEFUNC(_wrap_vectorAngle), -1);
  rb_define_module_function(mOpenbabel, "CalcTorsionAngle", VALUEFUNC(_wrap_CalcTorsionAngle), -1);
  rb_define_module_function(mOpenbabel, "Point2Plane", VALUEFUNC(_wrap_Point2Plane), -1);
  rb_define_module_function(mOpenbabel, "Point2PlaneAngle", VALUEFUNC(_wrap_Point2PlaneAngle), -1);
  rb_define_singleton_method(mOpenbabel, "VZero", VALUEFUNC(VZero_get), 0);
  rb_define_singleton_method(mOpenbabel, "VX", VALUEFUNC(VX_get), 0);
  rb_define_singleton_method(mOpenbabel, "VY", VALUEFUNC(VY_get), 0);
  rb_define_singleton_method(mOpenbabel, "VZ", VALUEFUNC(VZ_get), 0);
  rb_define_module_function(mOpenbabel, "Trim", VALUEFUNC(_wrap_Trim), -1);
  rb_define_const(mOpenbabel, "UndefinedData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::UndefinedData)));
  rb_define_const(mOpenbabel, "PairData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::PairData)));
  rb_define_const(mOpenbabel, "EnergyData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::EnergyData)));
  rb_define_const(mOpenbabel, "CommentData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CommentData)));
  rb_define_const(mOpenbabel, "ConformerData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ConformerData)));
  rb_define_const(mOpenbabel, "ExternalBondData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ExternalBondData)));
  rb_define_const(mOpenbabel, "RotamerList", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::RotamerList)));
  rb_define_const(mOpenbabel, "VirtualBondData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::VirtualBondData)));
  rb_define_const(mOpenbabel, "RingData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::RingData)));
  rb_define_const(mOpenbabel, "TorsionData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::TorsionData)));
  rb_define_const(mOpenbabel, "AngleData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::AngleData)));
  rb_define_const(mOpenbabel, "SerialNums", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SerialNums)));
  rb_define_const(mOpenbabel, "UnitCell", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::UnitCell)));
  rb_define_const(mOpenbabel, "SpinData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SpinData)));
  rb_define_const(mOpenbabel, "ChargeData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ChargeData)));
  rb_define_const(mOpenbabel, "SymmetryData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SymmetryData)));
  rb_define_const(mOpenbabel, "ChiralData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ChiralData)));
  rb_define_const(mOpenbabel, "OccupationData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::OccupationData)));
  rb_define_const(mOpenbabel, "DensityData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::DensityData)));
  rb_define_const(mOpenbabel, "ElectronicData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ElectronicData)));
  rb_define_const(mOpenbabel, "VibrationData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::VibrationData)));
  rb_define_const(mOpenbabel, "RotationData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::RotationData)));
  rb_define_const(mOpenbabel, "NuclearData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::NuclearData)));
  rb_define_const(mOpenbabel, "SetData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SetData)));
  rb_define_const(mOpenbabel, "CustomData0", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData0)));
  rb_define_const(mOpenbabel, "CustomData1", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData1)));
  rb_define_const(mOpenbabel, "CustomData2", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData2)));
  rb_define_const(mOpenbabel, "CustomData3", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData3)));
  rb_define_const(mOpenbabel, "CustomData4", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData4)));
  rb_define_const(mOpenbabel, "CustomData5", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData5)));
  rb_define_const(mOpenbabel, "CustomData6", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData6)));
  rb_define_const(mOpenbabel, "CustomData7", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData7)));
  rb_define_const(mOpenbabel, "CustomData8", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData8)));
  rb_define_const(mOpenbabel, "CustomData9", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData9)));
  rb_define_const(mOpenbabel, "CustomData10", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData10)));
  rb_define_const(mOpenbabel, "CustomData11", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData11)));
  rb_define_const(mOpenbabel, "CustomData12", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData12)));
  rb_define_const(mOpenbabel, "CustomData13", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData13)));
  rb_define_const(mOpenbabel, "CustomData14", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData14)));
  rb_define_const(mOpenbabel, "CustomData15", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData15)));
  rb_define_const(mOpenbabel, "Any", SWIG_From_int(static_cast< int >(OpenBabel::any)));
  rb_define_const(mOpenbabel, "FileformatInput", SWIG_From_int(static_cast< int >(OpenBabel::fileformatInput)));
  rb_define_const(mOpenbabel, "UserInput", SWIG_From_int(static_cast< int >(OpenBabel::userInput)));
  rb_define_const(mOpenbabel, "Perceived", SWIG_From_int(static_cast< int >(OpenBabel::perceived)));
  rb_define_const(mOpenbabel, "External", SWIG_From_int(static_cast< int >(OpenBabel::external)));
  
  cOBGenericData.klass = rb_define_class_under(mOpenbabel, "OBGenericData", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBGenericData, (void *) &cOBGenericData);
  rb_define_alloc_func(cOBGenericData.klass, _wrap_OBGenericData_allocate);
  rb_define_method(cOBGenericData.klass, "initialize", VALUEFUNC(_wrap_new_OBGenericData), -1);
  rb_define_method(cOBGenericData.klass, "Clone", VALUEFUNC(_wrap_OBGenericData_Clone), -1);
  rb_define_method(cOBGenericData.klass, "SetAttribute", VALUEFUNC(_wrap_OBGenericData_SetAttribute), -1);
  rb_define_method(cOBGenericData.klass, "SetOrigin", VALUEFUNC(_wrap_OBGenericData_SetOrigin), -1);
  rb_define_method(cOBGenericData.klass, "GetAttribute", VALUEFUNC(_wrap_OBGenericData_GetAttribute), -1);
  rb_define_method(cOBGenericData.klass, "GetDataType", VALUEFUNC(_wrap_OBGenericData_GetDataType), -1);
  rb_define_method(cOBGenericData.klass, "GetValue", VALUEFUNC(_wrap_OBGenericData_GetValue), -1);
  rb_define_method(cOBGenericData.klass, "GetOrigin", VALUEFUNC(_wrap_OBGenericData_GetOrigin), -1);
  cOBGenericData.mark = 0;
  cOBGenericData.destroy = (void (*)(void *)) free_OpenBabel_OBGenericData;
  cOBGenericData.trackObjects = 0;
  
  cOBCommentData.klass = rb_define_class_under(mOpenbabel, "OBCommentData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBCommentData, (void *) &cOBCommentData);
  rb_define_alloc_func(cOBCommentData.klass, _wrap_OBCommentData_allocate);
  rb_define_method(cOBCommentData.klass, "initialize", VALUEFUNC(_wrap_new_OBCommentData), -1);
  rb_define_method(cOBCommentData.klass, "Clone", VALUEFUNC(_wrap_OBCommentData_Clone), -1);
  rb_define_method(cOBCommentData.klass, "SetData", VALUEFUNC(_wrap_OBCommentData_SetData), -1);
  rb_define_method(cOBCommentData.klass, "GetData", VALUEFUNC(_wrap_OBCommentData_GetData), -1);
  rb_define_method(cOBCommentData.klass, "GetValue", VALUEFUNC(_wrap_OBCommentData_GetValue), -1);
  cOBCommentData.mark = 0;
  cOBCommentData.destroy = (void (*)(void *)) free_OpenBabel_OBCommentData;
  cOBCommentData.trackObjects = 0;
  
  cOBExternalBond.klass = rb_define_class_under(mOpenbabel, "OBExternalBond", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBExternalBond, (void *) &cOBExternalBond);
  rb_define_alloc_func(cOBExternalBond.klass, _wrap_OBExternalBond_allocate);
  rb_define_method(cOBExternalBond.klass, "initialize", VALUEFUNC(_wrap_new_OBExternalBond), -1);
  rb_define_method(cOBExternalBond.klass, "GetIdx", VALUEFUNC(_wrap_OBExternalBond_GetIdx), -1);
  rb_define_method(cOBExternalBond.klass, "GetAtom", VALUEFUNC(_wrap_OBExternalBond_GetAtom), -1);
  rb_define_method(cOBExternalBond.klass, "GetBond", VALUEFUNC(_wrap_OBExternalBond_GetBond), -1);
  rb_define_method(cOBExternalBond.klass, "SetIdx", VALUEFUNC(_wrap_OBExternalBond_SetIdx), -1);
  rb_define_method(cOBExternalBond.klass, "SetAtom", VALUEFUNC(_wrap_OBExternalBond_SetAtom), -1);
  rb_define_method(cOBExternalBond.klass, "SetBond", VALUEFUNC(_wrap_OBExternalBond_SetBond), -1);
  cOBExternalBond.mark = 0;
  cOBExternalBond.destroy = (void (*)(void *)) free_OpenBabel_OBExternalBond;
  cOBExternalBond.trackObjects = 0;
  
  cOBExternalBondData.klass = rb_define_class_under(mOpenbabel, "OBExternalBondData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBExternalBondData, (void *) &cOBExternalBondData);
  rb_define_alloc_func(cOBExternalBondData.klass, _wrap_OBExternalBondData_allocate);
  rb_define_method(cOBExternalBondData.klass, "initialize", VALUEFUNC(_wrap_new_OBExternalBondData), -1);
  rb_define_method(cOBExternalBondData.klass, "Clone", VALUEFUNC(_wrap_OBExternalBondData_Clone), -1);
  rb_define_method(cOBExternalBondData.klass, "SetData", VALUEFUNC(_wrap_OBExternalBondData_SetData), -1);
  rb_define_method(cOBExternalBondData.klass, "GetData", VALUEFUNC(_wrap_OBExternalBondData_GetData), -1);
  cOBExternalBondData.mark = 0;
  cOBExternalBondData.destroy = (void (*)(void *)) free_OpenBabel_OBExternalBondData;
  cOBExternalBondData.trackObjects = 0;
  
  cOBPairData.klass = rb_define_class_under(mOpenbabel, "OBPairData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBPairData, (void *) &cOBPairData);
  rb_define_alloc_func(cOBPairData.klass, _wrap_OBPairData_allocate);
  rb_define_method(cOBPairData.klass, "initialize", VALUEFUNC(_wrap_new_OBPairData), -1);
  rb_define_method(cOBPairData.klass, "Clone", VALUEFUNC(_wrap_OBPairData_Clone), -1);
  rb_define_method(cOBPairData.klass, "SetValue", VALUEFUNC(_wrap_OBPairData_SetValue), -1);
  rb_define_method(cOBPairData.klass, "GetValue", VALUEFUNC(_wrap_OBPairData_GetValue), -1);
  cOBPairData.mark = 0;
  cOBPairData.destroy = (void (*)(void *)) free_OpenBabel_OBPairData;
  cOBPairData.trackObjects = 0;
  
  cOBSetData.klass = rb_define_class_under(mOpenbabel, "OBSetData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSetData, (void *) &cOBSetData);
  rb_define_alloc_func(cOBSetData.klass, _wrap_OBSetData_allocate);
  rb_define_method(cOBSetData.klass, "initialize", VALUEFUNC(_wrap_new_OBSetData), -1);
  rb_define_method(cOBSetData.klass, "Clone", VALUEFUNC(_wrap_OBSetData_Clone), -1);
  rb_define_method(cOBSetData.klass, "AddData", VALUEFUNC(_wrap_OBSetData_AddData), -1);
  rb_define_method(cOBSetData.klass, "SetData", VALUEFUNC(_wrap_OBSetData_SetData), -1);
  rb_define_method(cOBSetData.klass, "GetData", VALUEFUNC(_wrap_OBSetData_GetData), -1);
  rb_define_method(cOBSetData.klass, "GetBegin", VALUEFUNC(_wrap_OBSetData_GetBegin), -1);
  rb_define_method(cOBSetData.klass, "GetEnd", VALUEFUNC(_wrap_OBSetData_GetEnd), -1);
  rb_define_method(cOBSetData.klass, "DeleteData", VALUEFUNC(_wrap_OBSetData_DeleteData), -1);
  cOBSetData.mark = 0;
  cOBSetData.destroy = (void (*)(void *)) free_OpenBabel_OBSetData;
  cOBSetData.trackObjects = 0;
  
  cOBVirtualBond.klass = rb_define_class_under(mOpenbabel, "OBVirtualBond", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBVirtualBond, (void *) &cOBVirtualBond);
  rb_define_alloc_func(cOBVirtualBond.klass, _wrap_OBVirtualBond_allocate);
  rb_define_method(cOBVirtualBond.klass, "initialize", VALUEFUNC(_wrap_new_OBVirtualBond), -1);
  rb_define_method(cOBVirtualBond.klass, "Clone", VALUEFUNC(_wrap_OBVirtualBond_Clone), -1);
  rb_define_method(cOBVirtualBond.klass, "GetBgn", VALUEFUNC(_wrap_OBVirtualBond_GetBgn), -1);
  rb_define_method(cOBVirtualBond.klass, "GetEnd", VALUEFUNC(_wrap_OBVirtualBond_GetEnd), -1);
  rb_define_method(cOBVirtualBond.klass, "GetOrder", VALUEFUNC(_wrap_OBVirtualBond_GetOrder), -1);
  rb_define_method(cOBVirtualBond.klass, "GetStereo", VALUEFUNC(_wrap_OBVirtualBond_GetStereo), -1);
  cOBVirtualBond.mark = 0;
  cOBVirtualBond.destroy = (void (*)(void *)) free_OpenBabel_OBVirtualBond;
  cOBVirtualBond.trackObjects = 0;
  
  cOBRingData.klass = rb_define_class_under(mOpenbabel, "OBRingData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRingData, (void *) &cOBRingData);
  rb_define_alloc_func(cOBRingData.klass, _wrap_OBRingData_allocate);
  rb_define_method(cOBRingData.klass, "initialize", VALUEFUNC(_wrap_new_OBRingData), -1);
  rb_define_method(cOBRingData.klass, "Clone", VALUEFUNC(_wrap_OBRingData_Clone), -1);
  rb_define_method(cOBRingData.klass, "SetData", VALUEFUNC(_wrap_OBRingData_SetData), -1);
  rb_define_method(cOBRingData.klass, "PushBack", VALUEFUNC(_wrap_OBRingData_PushBack), -1);
  rb_define_method(cOBRingData.klass, "GetData", VALUEFUNC(_wrap_OBRingData_GetData), -1);
  rb_define_method(cOBRingData.klass, "BeginRings", VALUEFUNC(_wrap_OBRingData_BeginRings), -1);
  rb_define_method(cOBRingData.klass, "EndRings", VALUEFUNC(_wrap_OBRingData_EndRings), -1);
  rb_define_method(cOBRingData.klass, "BeginRing", VALUEFUNC(_wrap_OBRingData_BeginRing), -1);
  rb_define_method(cOBRingData.klass, "NextRing", VALUEFUNC(_wrap_OBRingData_NextRing), -1);
  cOBRingData.mark = 0;
  cOBRingData.destroy = (void (*)(void *)) free_OpenBabel_OBRingData;
  cOBRingData.trackObjects = 0;
  
  cOBUnitCell.klass = rb_define_class_under(mOpenbabel, "OBUnitCell", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBUnitCell, (void *) &cOBUnitCell);
  rb_define_alloc_func(cOBUnitCell.klass, _wrap_OBUnitCell_allocate);
  rb_define_method(cOBUnitCell.klass, "initialize", VALUEFUNC(_wrap_new_OBUnitCell), -1);
  rb_define_const(cOBUnitCell.klass, "Undefined", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Undefined)));
  rb_define_const(cOBUnitCell.klass, "Triclinic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Triclinic)));
  rb_define_const(cOBUnitCell.klass, "Monoclinic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Monoclinic)));
  rb_define_const(cOBUnitCell.klass, "Orthorhombic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Orthorhombic)));
  rb_define_const(cOBUnitCell.klass, "Tetragonal", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Tetragonal)));
  rb_define_const(cOBUnitCell.klass, "Rhombohedral", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Rhombohedral)));
  rb_define_const(cOBUnitCell.klass, "Hexagonal", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Hexagonal)));
  rb_define_const(cOBUnitCell.klass, "Cubic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Cubic)));
  rb_define_method(cOBUnitCell.klass, "Clone", VALUEFUNC(_wrap_OBUnitCell_Clone), -1);
  rb_define_method(cOBUnitCell.klass, "SetData", VALUEFUNC(_wrap_OBUnitCell_SetData), -1);
  rb_define_method(cOBUnitCell.klass, "SetOffset", VALUEFUNC(_wrap_OBUnitCell_SetOffset), -1);
  rb_define_method(cOBUnitCell.klass, "SetSpaceGroup", VALUEFUNC(_wrap_OBUnitCell_SetSpaceGroup), -1);
  rb_define_method(cOBUnitCell.klass, "SetLatticeType", VALUEFUNC(_wrap_OBUnitCell_SetLatticeType), -1);
  rb_define_method(cOBUnitCell.klass, "GetA", VALUEFUNC(_wrap_OBUnitCell_GetA), -1);
  rb_define_method(cOBUnitCell.klass, "GetB", VALUEFUNC(_wrap_OBUnitCell_GetB), -1);
  rb_define_method(cOBUnitCell.klass, "GetC", VALUEFUNC(_wrap_OBUnitCell_GetC), -1);
  rb_define_method(cOBUnitCell.klass, "GetAlpha", VALUEFUNC(_wrap_OBUnitCell_GetAlpha), -1);
  rb_define_method(cOBUnitCell.klass, "GetBeta", VALUEFUNC(_wrap_OBUnitCell_GetBeta), -1);
  rb_define_method(cOBUnitCell.klass, "GetGamma", VALUEFUNC(_wrap_OBUnitCell_GetGamma), -1);
  rb_define_method(cOBUnitCell.klass, "GetOffset", VALUEFUNC(_wrap_OBUnitCell_GetOffset), -1);
  rb_define_method(cOBUnitCell.klass, "GetSpaceGroup", VALUEFUNC(_wrap_OBUnitCell_GetSpaceGroup), -1);
  rb_define_method(cOBUnitCell.klass, "GetLatticeType", VALUEFUNC(_wrap_OBUnitCell_GetLatticeType), -1);
  rb_define_method(cOBUnitCell.klass, "GetCellVectors", VALUEFUNC(_wrap_OBUnitCell_GetCellVectors), -1);
  rb_define_method(cOBUnitCell.klass, "GetCellMatrix", VALUEFUNC(_wrap_OBUnitCell_GetCellMatrix), -1);
  rb_define_method(cOBUnitCell.klass, "GetOrthoMatrix", VALUEFUNC(_wrap_OBUnitCell_GetOrthoMatrix), -1);
  rb_define_method(cOBUnitCell.klass, "GetFractionalMatrix", VALUEFUNC(_wrap_OBUnitCell_GetFractionalMatrix), -1);
  rb_define_method(cOBUnitCell.klass, "GetSpaceGroupNumber", VALUEFUNC(_wrap_OBUnitCell_GetSpaceGroupNumber), -1);
  rb_define_method(cOBUnitCell.klass, "GetCellVolume", VALUEFUNC(_wrap_OBUnitCell_GetCellVolume), -1);
  cOBUnitCell.mark = 0;
  cOBUnitCell.destroy = (void (*)(void *)) free_OpenBabel_OBUnitCell;
  cOBUnitCell.trackObjects = 0;
  
  cOBConformerData.klass = rb_define_class_under(mOpenbabel, "OBConformerData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBConformerData, (void *) &cOBConformerData);
  rb_define_alloc_func(cOBConformerData.klass, _wrap_OBConformerData_allocate);
  rb_define_method(cOBConformerData.klass, "initialize", VALUEFUNC(_wrap_new_OBConformerData), -1);
  rb_define_method(cOBConformerData.klass, "Clone", VALUEFUNC(_wrap_OBConformerData_Clone), -1);
  rb_define_method(cOBConformerData.klass, "SetDimension", VALUEFUNC(_wrap_OBConformerData_SetDimension), -1);
  rb_define_method(cOBConformerData.klass, "SetEnergies", VALUEFUNC(_wrap_OBConformerData_SetEnergies), -1);
  rb_define_method(cOBConformerData.klass, "SetForces", VALUEFUNC(_wrap_OBConformerData_SetForces), -1);
  rb_define_method(cOBConformerData.klass, "SetVelocities", VALUEFUNC(_wrap_OBConformerData_SetVelocities), -1);
  rb_define_method(cOBConformerData.klass, "SetDisplacements", VALUEFUNC(_wrap_OBConformerData_SetDisplacements), -1);
  rb_define_method(cOBConformerData.klass, "SetData", VALUEFUNC(_wrap_OBConformerData_SetData), -1);
  rb_define_method(cOBConformerData.klass, "GetDimension", VALUEFUNC(_wrap_OBConformerData_GetDimension), -1);
  rb_define_method(cOBConformerData.klass, "GetEnergies", VALUEFUNC(_wrap_OBConformerData_GetEnergies), -1);
  rb_define_method(cOBConformerData.klass, "GetForces", VALUEFUNC(_wrap_OBConformerData_GetForces), -1);
  rb_define_method(cOBConformerData.klass, "GetVelocities", VALUEFUNC(_wrap_OBConformerData_GetVelocities), -1);
  rb_define_method(cOBConformerData.klass, "GetDisplacements", VALUEFUNC(_wrap_OBConformerData_GetDisplacements), -1);
  rb_define_method(cOBConformerData.klass, "GetData", VALUEFUNC(_wrap_OBConformerData_GetData), -1);
  cOBConformerData.mark = 0;
  cOBConformerData.destroy = (void (*)(void *)) free_OpenBabel_OBConformerData;
  cOBConformerData.trackObjects = 0;
  
  cOBSymmetryData.klass = rb_define_class_under(mOpenbabel, "OBSymmetryData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSymmetryData, (void *) &cOBSymmetryData);
  rb_define_alloc_func(cOBSymmetryData.klass, _wrap_OBSymmetryData_allocate);
  rb_define_method(cOBSymmetryData.klass, "initialize", VALUEFUNC(_wrap_new_OBSymmetryData), -1);
  rb_define_method(cOBSymmetryData.klass, "Clone", VALUEFUNC(_wrap_OBSymmetryData_Clone), -1);
  rb_define_method(cOBSymmetryData.klass, "SetData", VALUEFUNC(_wrap_OBSymmetryData_SetData), -1);
  rb_define_method(cOBSymmetryData.klass, "SetPointGroup", VALUEFUNC(_wrap_OBSymmetryData_SetPointGroup), -1);
  rb_define_method(cOBSymmetryData.klass, "SetSpaceGroup", VALUEFUNC(_wrap_OBSymmetryData_SetSpaceGroup), -1);
  rb_define_method(cOBSymmetryData.klass, "GetPointGroup", VALUEFUNC(_wrap_OBSymmetryData_GetPointGroup), -1);
  rb_define_method(cOBSymmetryData.klass, "GetSpaceGroup", VALUEFUNC(_wrap_OBSymmetryData_GetSpaceGroup), -1);
  cOBSymmetryData.mark = 0;
  cOBSymmetryData.destroy = (void (*)(void *)) free_OpenBabel_OBSymmetryData;
  cOBSymmetryData.trackObjects = 0;
  
  cOBTorsion.klass = rb_define_class_under(mOpenbabel, "OBTorsion", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBTorsion, (void *) &cOBTorsion);
  rb_define_alloc_func(cOBTorsion.klass, _wrap_OBTorsion_allocate);
  rb_define_method(cOBTorsion.klass, "initialize", VALUEFUNC(_wrap_new_OBTorsion), -1);
  rb_define_method(cOBTorsion.klass, "Clear", VALUEFUNC(_wrap_OBTorsion_Clear), -1);
  rb_define_method(cOBTorsion.klass, "Empty", VALUEFUNC(_wrap_OBTorsion_Empty), -1);
  rb_define_method(cOBTorsion.klass, "AddTorsion", VALUEFUNC(_wrap_OBTorsion_AddTorsion), -1);
  rb_define_method(cOBTorsion.klass, "SetAngle", VALUEFUNC(_wrap_OBTorsion_SetAngle), -1);
  rb_define_method(cOBTorsion.klass, "SetData", VALUEFUNC(_wrap_OBTorsion_SetData), -1);
  rb_define_method(cOBTorsion.klass, "GetAngle", VALUEFUNC(_wrap_OBTorsion_GetAngle), -1);
  rb_define_method(cOBTorsion.klass, "GetBondIdx", VALUEFUNC(_wrap_OBTorsion_GetBondIdx), -1);
  rb_define_method(cOBTorsion.klass, "GetSize", VALUEFUNC(_wrap_OBTorsion_GetSize), -1);
  rb_define_method(cOBTorsion.klass, "GetBC", VALUEFUNC(_wrap_OBTorsion_GetBC), -1);
  rb_define_method(cOBTorsion.klass, "GetADs", VALUEFUNC(_wrap_OBTorsion_GetADs), -1);
  rb_define_method(cOBTorsion.klass, "IsProtonRotor", VALUEFUNC(_wrap_OBTorsion_IsProtonRotor), -1);
  cOBTorsion.mark = 0;
  cOBTorsion.destroy = (void (*)(void *)) free_OpenBabel_OBTorsion;
  cOBTorsion.trackObjects = 0;
  
  cOBTorsionData.klass = rb_define_class_under(mOpenbabel, "OBTorsionData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBTorsionData, (void *) &cOBTorsionData);
  rb_undef_alloc_func(cOBTorsionData.klass);
  rb_define_method(cOBTorsionData.klass, "Clone", VALUEFUNC(_wrap_OBTorsionData_Clone), -1);
  rb_define_method(cOBTorsionData.klass, "Clear", VALUEFUNC(_wrap_OBTorsionData_Clear), -1);
  rb_define_method(cOBTorsionData.klass, "GetData", VALUEFUNC(_wrap_OBTorsionData_GetData), -1);
  rb_define_method(cOBTorsionData.klass, "GetSize", VALUEFUNC(_wrap_OBTorsionData_GetSize), -1);
  rb_define_method(cOBTorsionData.klass, "SetData", VALUEFUNC(_wrap_OBTorsionData_SetData), -1);
  rb_define_method(cOBTorsionData.klass, "FillTorsionArray", VALUEFUNC(_wrap_OBTorsionData_FillTorsionArray), -1);
  cOBTorsionData.mark = 0;
  cOBTorsionData.destroy = (void (*)(void *)) free_OpenBabel_OBTorsionData;
  cOBTorsionData.trackObjects = 0;
  
  cOBAngle.klass = rb_define_class_under(mOpenbabel, "OBAngle", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAngle, (void *) &cOBAngle);
  rb_define_alloc_func(cOBAngle.klass, _wrap_OBAngle_allocate);
  rb_define_method(cOBAngle.klass, "initialize", VALUEFUNC(_wrap_new_OBAngle), -1);
  rb_define_method(cOBAngle.klass, "==", VALUEFUNC(_wrap_OBAngle___eq__), -1);
  rb_define_method(cOBAngle.klass, "Clear", VALUEFUNC(_wrap_OBAngle_Clear), -1);
  rb_define_method(cOBAngle.klass, "GetAngle", VALUEFUNC(_wrap_OBAngle_GetAngle), -1);
  rb_define_method(cOBAngle.klass, "SetAngle", VALUEFUNC(_wrap_OBAngle_SetAngle), -1);
  rb_define_method(cOBAngle.klass, "SetAtoms", VALUEFUNC(_wrap_OBAngle_SetAtoms), -1);
  cOBAngle.mark = 0;
  cOBAngle.destroy = (void (*)(void *)) free_OpenBabel_OBAngle;
  cOBAngle.trackObjects = 0;
  
  cOBAngleData.klass = rb_define_class_under(mOpenbabel, "OBAngleData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAngleData, (void *) &cOBAngleData);
  rb_undef_alloc_func(cOBAngleData.klass);
  rb_define_method(cOBAngleData.klass, "Clone", VALUEFUNC(_wrap_OBAngleData_Clone), -1);
  rb_define_method(cOBAngleData.klass, "Clear", VALUEFUNC(_wrap_OBAngleData_Clear), -1);
  rb_define_method(cOBAngleData.klass, "FillAngleArray", VALUEFUNC(_wrap_OBAngleData_FillAngleArray), -1);
  rb_define_method(cOBAngleData.klass, "SetData", VALUEFUNC(_wrap_OBAngleData_SetData), -1);
  rb_define_method(cOBAngleData.klass, "GetSize", VALUEFUNC(_wrap_OBAngleData_GetSize), -1);
  cOBAngleData.mark = 0;
  cOBAngleData.destroy = (void (*)(void *)) free_OpenBabel_OBAngleData;
  cOBAngleData.trackObjects = 0;
  rb_define_const(mOpenbabel, "Output", SWIG_From_int(static_cast< int >(OpenBabel::output)));
  rb_define_const(mOpenbabel, "Input", SWIG_From_int(static_cast< int >(OpenBabel::input)));
  rb_define_const(mOpenbabel, "Calcvolume", SWIG_From_int(static_cast< int >(OpenBabel::calcvolume)));
  
  cOBChiralData.klass = rb_define_class_under(mOpenbabel, "OBChiralData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBChiralData, (void *) &cOBChiralData);
  rb_define_alloc_func(cOBChiralData.klass, _wrap_OBChiralData_allocate);
  rb_define_method(cOBChiralData.klass, "initialize", VALUEFUNC(_wrap_new_OBChiralData), -1);
  rb_define_method(cOBChiralData.klass, "Clone", VALUEFUNC(_wrap_OBChiralData_Clone), -1);
  rb_define_method(cOBChiralData.klass, "Clear", VALUEFUNC(_wrap_OBChiralData_Clear), -1);
  rb_define_method(cOBChiralData.klass, "GetAtom4Refs", VALUEFUNC(_wrap_OBChiralData_GetAtom4Refs), -1);
  rb_define_method(cOBChiralData.klass, "GetAtomRef", VALUEFUNC(_wrap_OBChiralData_GetAtomRef), -1);
  rb_define_method(cOBChiralData.klass, "SetAtom4Refs", VALUEFUNC(_wrap_OBChiralData_SetAtom4Refs), -1);
  rb_define_method(cOBChiralData.klass, "AddAtomRef", VALUEFUNC(_wrap_OBChiralData_AddAtomRef), -1);
  rb_define_method(cOBChiralData.klass, "GetSize", VALUEFUNC(_wrap_OBChiralData_GetSize), -1);
  cOBChiralData.mark = 0;
  cOBChiralData.destroy = (void (*)(void *)) free_OpenBabel_OBChiralData;
  cOBChiralData.trackObjects = 0;
  
  cOBSerialNums.klass = rb_define_class_under(mOpenbabel, "OBSerialNums", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSerialNums, (void *) &cOBSerialNums);
  rb_define_alloc_func(cOBSerialNums.klass, _wrap_OBSerialNums_allocate);
  rb_define_method(cOBSerialNums.klass, "initialize", VALUEFUNC(_wrap_new_OBSerialNums), -1);
  rb_define_method(cOBSerialNums.klass, "Clone", VALUEFUNC(_wrap_OBSerialNums_Clone), -1);
  rb_define_method(cOBSerialNums.klass, "GetData", VALUEFUNC(_wrap_OBSerialNums_GetData), -1);
  rb_define_method(cOBSerialNums.klass, "SetData", VALUEFUNC(_wrap_OBSerialNums_SetData), -1);
  cOBSerialNums.mark = 0;
  cOBSerialNums.destroy = (void (*)(void *)) free_OpenBabel_OBSerialNums;
  cOBSerialNums.trackObjects = 0;
  
  cOBVibrationData.klass = rb_define_class_under(mOpenbabel, "OBVibrationData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBVibrationData, (void *) &cOBVibrationData);
  rb_define_alloc_func(cOBVibrationData.klass, _wrap_OBVibrationData_allocate);
  rb_define_method(cOBVibrationData.klass, "initialize", VALUEFUNC(_wrap_new_OBVibrationData), -1);
  rb_define_method(cOBVibrationData.klass, "SetData", VALUEFUNC(_wrap_OBVibrationData_SetData), -1);
  rb_define_method(cOBVibrationData.klass, "GetLx", VALUEFUNC(_wrap_OBVibrationData_GetLx), -1);
  rb_define_method(cOBVibrationData.klass, "GetFrequencies", VALUEFUNC(_wrap_OBVibrationData_GetFrequencies), -1);
  rb_define_method(cOBVibrationData.klass, "GetIntensities", VALUEFUNC(_wrap_OBVibrationData_GetIntensities), -1);
  rb_define_method(cOBVibrationData.klass, "GetNumberOfFrequencies", VALUEFUNC(_wrap_OBVibrationData_GetNumberOfFrequencies), -1);
  cOBVibrationData.mark = 0;
  cOBVibrationData.destroy = (void (*)(void *)) free_OpenBabel_OBVibrationData;
  cOBVibrationData.trackObjects = 0;
  
  cOBBase.klass = rb_define_class_under(mOpenbabel, "OBBase", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBBase, (void *) &cOBBase);
  rb_define_alloc_func(cOBBase.klass, _wrap_OBBase_allocate);
  rb_define_method(cOBBase.klass, "initialize", VALUEFUNC(_wrap_new_OBBase), -1);
  rb_define_method(cOBBase.klass, "Clear", VALUEFUNC(_wrap_OBBase_Clear), -1);
  rb_define_method(cOBBase.klass, "DoTransformations", VALUEFUNC(_wrap_OBBase_DoTransformations), -1);
  rb_define_singleton_method(cOBBase.klass, "ClassDescription", VALUEFUNC(_wrap_OBBase_ClassDescription), -1);
  rb_define_method(cOBBase.klass, "HasData", VALUEFUNC(_wrap_OBBase_HasData), -1);
  rb_define_method(cOBBase.klass, "DeleteData", VALUEFUNC(_wrap_OBBase_DeleteData), -1);
  rb_define_method(cOBBase.klass, "SetData", VALUEFUNC(_wrap_OBBase_SetData), -1);
  rb_define_method(cOBBase.klass, "DataSize", VALUEFUNC(_wrap_OBBase_DataSize), -1);
  rb_define_method(cOBBase.klass, "GetData", VALUEFUNC(_wrap_OBBase_GetData), -1);
  rb_define_method(cOBBase.klass, "BeginData", VALUEFUNC(_wrap_OBBase_BeginData), -1);
  rb_define_method(cOBBase.klass, "EndData", VALUEFUNC(_wrap_OBBase_EndData), -1);
  cOBBase.mark = 0;
  cOBBase.destroy = (void (*)(void *)) free_OpenBabel_OBBase;
  cOBBase.trackObjects = 0;
  
  cPluginiterFingerprint.klass = rb_define_class_under(mOpenbabel, "PluginiterFingerprint", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, (void *) &cPluginiterFingerprint);
  rb_define_alloc_func(cPluginiterFingerprint.klass, _wrap_pluginiterFingerprint_allocate);
  rb_define_method(cPluginiterFingerprint.klass, "initialize", VALUEFUNC(_wrap_new_pluginiterFingerprint), -1);
  rb_define_method(cPluginiterFingerprint.klass, "Register", VALUEFUNC(_wrap_pluginiterFingerprint_Register), -1);
  rb_define_method(cPluginiterFingerprint.klass, "FindType", VALUEFUNC(_wrap_pluginiterFingerprint_FindType), -1);
  rb_define_method(cPluginiterFingerprint.klass, "FindDefaultType", VALUEFUNC(_wrap_pluginiterFingerprint_FindDefaultType), -1);
  rb_define_method(cPluginiterFingerprint.klass, "ID", VALUEFUNC(_wrap_pluginiterFingerprint_ID), -1);
  rb_define_method(cPluginiterFingerprint.klass, "ToStart", VALUEFUNC(_wrap_pluginiterFingerprint_ToStart), -1);
  rb_define_method(cPluginiterFingerprint.klass, "inc", VALUEFUNC(_wrap_pluginiterFingerprint_inc), -1);
  rb_define_method(cPluginiterFingerprint.klass, "good", VALUEFUNC(_wrap_pluginiterFingerprint_good), -1);
  rb_define_method(cPluginiterFingerprint.klass, "deref", VALUEFUNC(_wrap_pluginiterFingerprint_deref), -1);
  rb_define_method(cPluginiterFingerprint.klass, "Iter", VALUEFUNC(_wrap_pluginiterFingerprint_Iter), -1);
  rb_define_method(cPluginiterFingerprint.klass, "SetBit", VALUEFUNC(_wrap_pluginiterFingerprint_SetBit), -1);
  rb_define_method(cPluginiterFingerprint.klass, "Fold", VALUEFUNC(_wrap_pluginiterFingerprint_Fold), -1);
  rb_define_method(cPluginiterFingerprint.klass, "GetFingerprint", VALUEFUNC(_wrap_pluginiterFingerprint_GetFingerprint), -1);
  rb_define_method(cPluginiterFingerprint.klass, "Description", VALUEFUNC(_wrap_pluginiterFingerprint_Description), -1);
  rb_define_method(cPluginiterFingerprint.klass, "Flags", VALUEFUNC(_wrap_pluginiterFingerprint_Flags), -1);
  rb_define_method(cPluginiterFingerprint.klass, "Tanimoto", VALUEFUNC(_wrap_pluginiterFingerprint_Tanimoto), -1);
  rb_define_method(cPluginiterFingerprint.klass, "Getbitsperint", VALUEFUNC(_wrap_pluginiterFingerprint_Getbitsperint), -1);
  rb_define_method(cPluginiterFingerprint.klass, "FindFingerprint", VALUEFUNC(_wrap_pluginiterFingerprint_FindFingerprint), -1);
  cPluginiterFingerprint.mark = 0;
  cPluginiterFingerprint.destroy = (void (*)(void *)) free_OpenBabel_PluginIter_Sl_OpenBabel_OBFingerprint_Sg_;
  cPluginiterFingerprint.trackObjects = 0;
  
  cPluginiterForceField.klass = rb_define_class_under(mOpenbabel, "PluginiterForceField", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, (void *) &cPluginiterForceField);
  rb_define_alloc_func(cPluginiterForceField.klass, _wrap_pluginiterForceField_allocate);
  rb_define_method(cPluginiterForceField.klass, "initialize", VALUEFUNC(_wrap_new_pluginiterForceField), -1);
  rb_define_method(cPluginiterForceField.klass, "Register", VALUEFUNC(_wrap_pluginiterForceField_Register), -1);
  rb_define_method(cPluginiterForceField.klass, "FindType", VALUEFUNC(_wrap_pluginiterForceField_FindType), -1);
  rb_define_method(cPluginiterForceField.klass, "FindDefaultType", VALUEFUNC(_wrap_pluginiterForceField_FindDefaultType), -1);
  rb_define_method(cPluginiterForceField.klass, "ID", VALUEFUNC(_wrap_pluginiterForceField_ID), -1);
  rb_define_method(cPluginiterForceField.klass, "ToStart", VALUEFUNC(_wrap_pluginiterForceField_ToStart), -1);
  rb_define_method(cPluginiterForceField.klass, "inc", VALUEFUNC(_wrap_pluginiterForceField_inc), -1);
  rb_define_method(cPluginiterForceField.klass, "good", VALUEFUNC(_wrap_pluginiterForceField_good), -1);
  rb_define_method(cPluginiterForceField.klass, "deref", VALUEFUNC(_wrap_pluginiterForceField_deref), -1);
  rb_define_method(cPluginiterForceField.klass, "Iter", VALUEFUNC(_wrap_pluginiterForceField_Iter), -1);
  rb_define_method(cPluginiterForceField.klass, "FindForceField", VALUEFUNC(_wrap_pluginiterForceField_FindForceField), -1);
  rb_define_method(cPluginiterForceField.klass, "GetUnit", VALUEFUNC(_wrap_pluginiterForceField_GetUnit), -1);
  rb_define_method(cPluginiterForceField.klass, "Setup", VALUEFUNC(_wrap_pluginiterForceField_Setup), -1);
  rb_define_method(cPluginiterForceField.klass, "UpdateCoordinates", VALUEFUNC(_wrap_pluginiterForceField_UpdateCoordinates), -1);
  rb_define_method(cPluginiterForceField.klass, "UpdateConformers", VALUEFUNC(_wrap_pluginiterForceField_UpdateConformers), -1);
  rb_define_method(cPluginiterForceField.klass, "OBFFLog", VALUEFUNC(_wrap_pluginiterForceField_OBFFLog), -1);
  rb_define_method(cPluginiterForceField.klass, "Energy", VALUEFUNC(_wrap_pluginiterForceField_Energy), -1);
  rb_define_method(cPluginiterForceField.klass, "E_Bond", VALUEFUNC(_wrap_pluginiterForceField_E_Bond), -1);
  rb_define_method(cPluginiterForceField.klass, "E_Angle", VALUEFUNC(_wrap_pluginiterForceField_E_Angle), -1);
  rb_define_method(cPluginiterForceField.klass, "E_StrBnd", VALUEFUNC(_wrap_pluginiterForceField_E_StrBnd), -1);
  rb_define_method(cPluginiterForceField.klass, "E_Torsion", VALUEFUNC(_wrap_pluginiterForceField_E_Torsion), -1);
  rb_define_method(cPluginiterForceField.klass, "E_OOP", VALUEFUNC(_wrap_pluginiterForceField_E_OOP), -1);
  rb_define_method(cPluginiterForceField.klass, "E_VDW", VALUEFUNC(_wrap_pluginiterForceField_E_VDW), -1);
  rb_define_method(cPluginiterForceField.klass, "E_Electrostatic", VALUEFUNC(_wrap_pluginiterForceField_E_Electrostatic), -1);
  rb_define_method(cPluginiterForceField.klass, "SetLogFile", VALUEFUNC(_wrap_pluginiterForceField_SetLogFile), -1);
  rb_define_method(cPluginiterForceField.klass, "SetLogLevel", VALUEFUNC(_wrap_pluginiterForceField_SetLogLevel), -1);
  rb_define_method(cPluginiterForceField.klass, "GetLogLevel", VALUEFUNC(_wrap_pluginiterForceField_GetLogLevel), -1);
  rb_define_method(cPluginiterForceField.klass, "SystematicRotorSearch", VALUEFUNC(_wrap_pluginiterForceField_SystematicRotorSearch), -1);
  rb_define_method(cPluginiterForceField.klass, "LineSearch", VALUEFUNC(_wrap_pluginiterForceField_LineSearch), -1);
  rb_define_method(cPluginiterForceField.klass, "SteepestDescent", VALUEFUNC(_wrap_pluginiterForceField_SteepestDescent), -1);
  rb_define_method(cPluginiterForceField.klass, "SteepestDescentInitialize", VALUEFUNC(_wrap_pluginiterForceField_SteepestDescentInitialize), -1);
  rb_define_method(cPluginiterForceField.klass, "SteepestDescentTakeNSteps", VALUEFUNC(_wrap_pluginiterForceField_SteepestDescentTakeNSteps), -1);
  rb_define_method(cPluginiterForceField.klass, "ConjugateGradients", VALUEFUNC(_wrap_pluginiterForceField_ConjugateGradients), -1);
  rb_define_method(cPluginiterForceField.klass, "ConjugateGradientsInitialize", VALUEFUNC(_wrap_pluginiterForceField_ConjugateGradientsInitialize), -1);
  rb_define_method(cPluginiterForceField.klass, "ConjugateGradientsTakeNSteps", VALUEFUNC(_wrap_pluginiterForceField_ConjugateGradientsTakeNSteps), -1);
  rb_define_method(cPluginiterForceField.klass, "Validate", VALUEFUNC(_wrap_pluginiterForceField_Validate), -1);
  rb_define_method(cPluginiterForceField.klass, "ValidateGradients", VALUEFUNC(_wrap_pluginiterForceField_ValidateGradients), -1);
  rb_define_method(cPluginiterForceField.klass, "ValidateGradientError", VALUEFUNC(_wrap_pluginiterForceField_ValidateGradientError), -1);
  rb_define_method(cPluginiterForceField.klass, "VectorLengthDerivative", VALUEFUNC(_wrap_pluginiterForceField_VectorLengthDerivative), -1);
  rb_define_method(cPluginiterForceField.klass, "VectorAngleDerivative", VALUEFUNC(_wrap_pluginiterForceField_VectorAngleDerivative), -1);
  rb_define_method(cPluginiterForceField.klass, "VectorTorsionDerivative", VALUEFUNC(_wrap_pluginiterForceField_VectorTorsionDerivative), -1);
  rb_define_method(cPluginiterForceField.klass, "kludge", VALUEFUNC(_wrap_pluginiterForceField_kludge), -1);
  cPluginiterForceField.mark = 0;
  cPluginiterForceField.destroy = (void (*)(void *)) free_OpenBabel_PluginIter_Sl_OpenBabel_OBForceField_Sg_;
  cPluginiterForceField.trackObjects = 0;
  rb_define_const(mOpenbabel, "ObError", SWIG_From_int(static_cast< int >(OpenBabel::obError)));
  rb_define_const(mOpenbabel, "ObWarning", SWIG_From_int(static_cast< int >(OpenBabel::obWarning)));
  rb_define_const(mOpenbabel, "ObInfo", SWIG_From_int(static_cast< int >(OpenBabel::obInfo)));
  rb_define_const(mOpenbabel, "ObAuditMsg", SWIG_From_int(static_cast< int >(OpenBabel::obAuditMsg)));
  rb_define_const(mOpenbabel, "ObDebug", SWIG_From_int(static_cast< int >(OpenBabel::obDebug)));
  
  cOBError.klass = rb_define_class_under(mOpenbabel, "OBError", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBError, (void *) &cOBError);
  rb_define_alloc_func(cOBError.klass, _wrap_OBError_allocate);
  rb_define_method(cOBError.klass, "initialize", VALUEFUNC(_wrap_new_OBError), -1);
  rb_define_method(cOBError.klass, "message", VALUEFUNC(_wrap_OBError_message), -1);
  rb_define_method(cOBError.klass, "GetMethod", VALUEFUNC(_wrap_OBError_GetMethod), -1);
  rb_define_method(cOBError.klass, "GetError", VALUEFUNC(_wrap_OBError_GetError), -1);
  rb_define_method(cOBError.klass, "GetExplanation", VALUEFUNC(_wrap_OBError_GetExplanation), -1);
  rb_define_method(cOBError.klass, "GetPossibleCause", VALUEFUNC(_wrap_OBError_GetPossibleCause), -1);
  rb_define_method(cOBError.klass, "GetSuggestedRemedy", VALUEFUNC(_wrap_OBError_GetSuggestedRemedy), -1);
  rb_define_method(cOBError.klass, "GetLevel", VALUEFUNC(_wrap_OBError_GetLevel), -1);
  cOBError.mark = 0;
  cOBError.destroy = (void (*)(void *)) free_OpenBabel_OBError;
  cOBError.trackObjects = 0;
  
  cOBMessageHandler.klass = rb_define_class_under(mOpenbabel, "OBMessageHandler", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMessageHandler, (void *) &cOBMessageHandler);
  rb_define_alloc_func(cOBMessageHandler.klass, _wrap_OBMessageHandler_allocate);
  rb_define_method(cOBMessageHandler.klass, "initialize", VALUEFUNC(_wrap_new_OBMessageHandler), -1);
  rb_define_method(cOBMessageHandler.klass, "ThrowError", VALUEFUNC(_wrap_OBMessageHandler_ThrowError), -1);
  rb_define_method(cOBMessageHandler.klass, "GetMessagesOfLevel", VALUEFUNC(_wrap_OBMessageHandler_GetMessagesOfLevel), -1);
  rb_define_method(cOBMessageHandler.klass, "StartLogging", VALUEFUNC(_wrap_OBMessageHandler_StartLogging), -1);
  rb_define_method(cOBMessageHandler.klass, "StopLogging", VALUEFUNC(_wrap_OBMessageHandler_StopLogging), -1);
  rb_define_method(cOBMessageHandler.klass, "SetMaxLogEntries", VALUEFUNC(_wrap_OBMessageHandler_SetMaxLogEntries), -1);
  rb_define_method(cOBMessageHandler.klass, "GetMaxLogEntries", VALUEFUNC(_wrap_OBMessageHandler_GetMaxLogEntries), -1);
  rb_define_method(cOBMessageHandler.klass, "ClearLog", VALUEFUNC(_wrap_OBMessageHandler_ClearLog), -1);
  rb_define_method(cOBMessageHandler.klass, "SetOutputLevel", VALUEFUNC(_wrap_OBMessageHandler_SetOutputLevel), -1);
  rb_define_method(cOBMessageHandler.klass, "GetOutputLevel", VALUEFUNC(_wrap_OBMessageHandler_GetOutputLevel), -1);
  rb_define_method(cOBMessageHandler.klass, "SetOutputStream", VALUEFUNC(_wrap_OBMessageHandler_SetOutputStream), -1);
  rb_define_method(cOBMessageHandler.klass, "GetOutputStream", VALUEFUNC(_wrap_OBMessageHandler_GetOutputStream), -1);
  rb_define_method(cOBMessageHandler.klass, "StartErrorWrap", VALUEFUNC(_wrap_OBMessageHandler_StartErrorWrap), -1);
  rb_define_method(cOBMessageHandler.klass, "StopErrorWrap", VALUEFUNC(_wrap_OBMessageHandler_StopErrorWrap), -1);
  rb_define_method(cOBMessageHandler.klass, "GetErrorMessageCount", VALUEFUNC(_wrap_OBMessageHandler_GetErrorMessageCount), -1);
  rb_define_method(cOBMessageHandler.klass, "GetWarningMessageCount", VALUEFUNC(_wrap_OBMessageHandler_GetWarningMessageCount), -1);
  rb_define_method(cOBMessageHandler.klass, "GetInfoMessageCount", VALUEFUNC(_wrap_OBMessageHandler_GetInfoMessageCount), -1);
  rb_define_method(cOBMessageHandler.klass, "GetAuditMessageCount", VALUEFUNC(_wrap_OBMessageHandler_GetAuditMessageCount), -1);
  rb_define_method(cOBMessageHandler.klass, "GetDebugMessageCount", VALUEFUNC(_wrap_OBMessageHandler_GetDebugMessageCount), -1);
  rb_define_method(cOBMessageHandler.klass, "GetMessageSummary", VALUEFUNC(_wrap_OBMessageHandler_GetMessageSummary), -1);
  cOBMessageHandler.mark = 0;
  cOBMessageHandler.destroy = (void (*)(void *)) free_OpenBabel_OBMessageHandler;
  cOBMessageHandler.trackObjects = 0;
  rb_define_singleton_method(mOpenbabel, "obErrorLog", VALUEFUNC(obErrorLog_get), 0);
  rb_define_singleton_method(mOpenbabel, "obErrorLog=", VALUEFUNC(obErrorLog_set), 1);
  
  cObLogBuf.klass = rb_define_class_under(mOpenbabel, "ObLogBuf", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__obLogBuf, (void *) &cObLogBuf);
  rb_define_alloc_func(cObLogBuf.klass, _wrap_obLogBuf_allocate);
  rb_define_method(cObLogBuf.klass, "initialize", VALUEFUNC(_wrap_new_obLogBuf), -1);
  cObLogBuf.mark = 0;
  cObLogBuf.destroy = (void (*)(void *)) free_OpenBabel_obLogBuf;
  cObLogBuf.trackObjects = 0;
  
  cOBFormat.klass = rb_define_class_under(mOpenbabel, "OBFormat", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFormat, (void *) &cOBFormat);
  rb_undef_alloc_func(cOBFormat.klass);
  rb_define_method(cOBFormat.klass, "ReadMolecule", VALUEFUNC(_wrap_OBFormat_ReadMolecule), -1);
  rb_define_method(cOBFormat.klass, "ReadChemObject", VALUEFUNC(_wrap_OBFormat_ReadChemObject), -1);
  rb_define_method(cOBFormat.klass, "WriteMolecule", VALUEFUNC(_wrap_OBFormat_WriteMolecule), -1);
  rb_define_method(cOBFormat.klass, "WriteChemObject", VALUEFUNC(_wrap_OBFormat_WriteChemObject), -1);
  rb_define_method(cOBFormat.klass, "Description", VALUEFUNC(_wrap_OBFormat_Description), -1);
  rb_define_method(cOBFormat.klass, "TargetClassDescription", VALUEFUNC(_wrap_OBFormat_TargetClassDescription), -1);
  rb_define_method(cOBFormat.klass, "GetType", VALUEFUNC(_wrap_OBFormat_GetType), -1);
  rb_define_method(cOBFormat.klass, "SpecificationURL", VALUEFUNC(_wrap_OBFormat_SpecificationURL), -1);
  rb_define_method(cOBFormat.klass, "GetMIMEType", VALUEFUNC(_wrap_OBFormat_GetMIMEType), -1);
  rb_define_method(cOBFormat.klass, "Flags", VALUEFUNC(_wrap_OBFormat_Flags), -1);
  rb_define_method(cOBFormat.klass, "SkipObjects", VALUEFUNC(_wrap_OBFormat_SkipObjects), -1);
  rb_define_method(cOBFormat.klass, "MakeNewInstance", VALUEFUNC(_wrap_OBFormat_MakeNewInstance), -1);
  cOBFormat.mark = 0;
  cOBFormat.destroy = (void (*)(void *)) free_OpenBabel_OBFormat;
  cOBFormat.trackObjects = 0;
  
  cCharPtrLess.klass = rb_define_class_under(mOpenbabel, "CharPtrLess", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__CharPtrLess, (void *) &cCharPtrLess);
  rb_define_alloc_func(cCharPtrLess.klass, _wrap_CharPtrLess_allocate);
  rb_define_method(cCharPtrLess.klass, "initialize", VALUEFUNC(_wrap_new_CharPtrLess), -1);
  rb_define_method(cCharPtrLess.klass, "call", VALUEFUNC(_wrap_CharPtrLess___call__), -1);
  cCharPtrLess.mark = 0;
  cCharPtrLess.destroy = (void (*)(void *)) free_OpenBabel_CharPtrLess;
  cCharPtrLess.trackObjects = 0;
  
  cOBConversion.klass = rb_define_class_under(mOpenbabel, "OBConversion", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBConversion, (void *) &cOBConversion);
  rb_define_alloc_func(cOBConversion.klass, _wrap_OBConversion_allocate);
  rb_define_method(cOBConversion.klass, "initialize", VALUEFUNC(_wrap_new_OBConversion), -1);
  rb_define_singleton_method(cOBConversion.klass, "RegisterFormat", VALUEFUNC(_wrap_OBConversion_RegisterFormat), -1);
  rb_define_singleton_method(cOBConversion.klass, "FindFormat", VALUEFUNC(_wrap_OBConversion_FindFormat), -1);
  rb_define_singleton_method(cOBConversion.klass, "FormatFromExt", VALUEFUNC(_wrap_OBConversion_FormatFromExt), -1);
  rb_define_singleton_method(cOBConversion.klass, "FormatFromMIME", VALUEFUNC(_wrap_OBConversion_FormatFromMIME), -1);
  rb_define_singleton_method(cOBConversion.klass, "GetNextFormat", VALUEFUNC(_wrap_OBConversion_GetNextFormat), -1);
  rb_define_singleton_method(cOBConversion.klass, "Description", VALUEFUNC(_wrap_OBConversion_Description), -1);
  rb_define_method(cOBConversion.klass, "GetInStream", VALUEFUNC(_wrap_OBConversion_GetInStream), -1);
  rb_define_method(cOBConversion.klass, "GetOutStream", VALUEFUNC(_wrap_OBConversion_GetOutStream), -1);
  rb_define_method(cOBConversion.klass, "SetInStream", VALUEFUNC(_wrap_OBConversion_SetInStream), -1);
  rb_define_method(cOBConversion.klass, "SetOutStream", VALUEFUNC(_wrap_OBConversion_SetOutStream), -1);
  rb_define_method(cOBConversion.klass, "SetInAndOutFormats", VALUEFUNC(_wrap_OBConversion_SetInAndOutFormats), -1);
  rb_define_method(cOBConversion.klass, "SetInFormat", VALUEFUNC(_wrap_OBConversion_SetInFormat), -1);
  rb_define_method(cOBConversion.klass, "SetOutFormat", VALUEFUNC(_wrap_OBConversion_SetOutFormat), -1);
  rb_define_method(cOBConversion.klass, "GetInFormat", VALUEFUNC(_wrap_OBConversion_GetInFormat), -1);
  rb_define_method(cOBConversion.klass, "GetOutFormat", VALUEFUNC(_wrap_OBConversion_GetOutFormat), -1);
  rb_define_method(cOBConversion.klass, "GetInFilename", VALUEFUNC(_wrap_OBConversion_GetInFilename), -1);
  rb_define_method(cOBConversion.klass, "GetInPos", VALUEFUNC(_wrap_OBConversion_GetInPos), -1);
  rb_define_method(cOBConversion.klass, "GetInLen", VALUEFUNC(_wrap_OBConversion_GetInLen), -1);
  rb_define_method(cOBConversion.klass, "GetTitle", VALUEFUNC(_wrap_OBConversion_GetTitle), -1);
  rb_define_method(cOBConversion.klass, "GetAuxConv", VALUEFUNC(_wrap_OBConversion_GetAuxConv), -1);
  rb_define_method(cOBConversion.klass, "SetAuxConv", VALUEFUNC(_wrap_OBConversion_SetAuxConv), -1);
  rb_define_const(cOBConversion.klass, "INOPTIONS", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::INOPTIONS)));
  rb_define_const(cOBConversion.klass, "OUTOPTIONS", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::OUTOPTIONS)));
  rb_define_const(cOBConversion.klass, "GENOPTIONS", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::GENOPTIONS)));
  rb_define_method(cOBConversion.klass, "IsOption", VALUEFUNC(_wrap_OBConversion_IsOption), -1);
  rb_define_method(cOBConversion.klass, "GetOptions", VALUEFUNC(_wrap_OBConversion_GetOptions), -1);
  rb_define_method(cOBConversion.klass, "AddOption", VALUEFUNC(_wrap_OBConversion_AddOption), -1);
  rb_define_method(cOBConversion.klass, "RemoveOption", VALUEFUNC(_wrap_OBConversion_RemoveOption), -1);
  rb_define_method(cOBConversion.klass, "SetOptions", VALUEFUNC(_wrap_OBConversion_SetOptions), -1);
  rb_define_singleton_method(cOBConversion.klass, "RegisterOptionParam", VALUEFUNC(_wrap_OBConversion_RegisterOptionParam), -1);
  rb_define_singleton_method(cOBConversion.klass, "GetOptionParams", VALUEFUNC(_wrap_OBConversion_GetOptionParams), -1);
  rb_define_method(cOBConversion.klass, "GetSupportedInputFormat", VALUEFUNC(_wrap_OBConversion_GetSupportedInputFormat), -1);
  rb_define_method(cOBConversion.klass, "GetSupportedOutputFormat", VALUEFUNC(_wrap_OBConversion_GetSupportedOutputFormat), -1);
  rb_define_method(cOBConversion.klass, "Convert", VALUEFUNC(_wrap_OBConversion_Convert), -1);
  rb_define_method(cOBConversion.klass, "FullConvert", VALUEFUNC(_wrap_OBConversion_FullConvert), -1);
  rb_define_method(cOBConversion.klass, "AddChemObject", VALUEFUNC(_wrap_OBConversion_AddChemObject), -1);
  rb_define_method(cOBConversion.klass, "GetChemObject", VALUEFUNC(_wrap_OBConversion_GetChemObject), -1);
  rb_define_method(cOBConversion.klass, "IsLast", VALUEFUNC(_wrap_OBConversion_IsLast), -1);
  rb_define_method(cOBConversion.klass, "IsFirstInput", VALUEFUNC(_wrap_OBConversion_IsFirstInput), -1);
  rb_define_method(cOBConversion.klass, "GetOutputIndex", VALUEFUNC(_wrap_OBConversion_GetOutputIndex), -1);
  rb_define_method(cOBConversion.klass, "SetOutputIndex", VALUEFUNC(_wrap_OBConversion_SetOutputIndex), -1);
  rb_define_method(cOBConversion.klass, "SetMoreFilesToCome", VALUEFUNC(_wrap_OBConversion_SetMoreFilesToCome), -1);
  rb_define_method(cOBConversion.klass, "SetOneObjectOnly", VALUEFUNC(_wrap_OBConversion_SetOneObjectOnly), -1);
  rb_define_method(cOBConversion.klass, "SetLast", VALUEFUNC(_wrap_OBConversion_SetLast), -1);
  rb_define_singleton_method(cOBConversion.klass, "GetDefaultFormat", VALUEFUNC(_wrap_OBConversion_GetDefaultFormat), -1);
  rb_define_method(cOBConversion.klass, "Write", VALUEFUNC(_wrap_OBConversion_Write), -1);
  rb_define_method(cOBConversion.klass, "WriteString", VALUEFUNC(_wrap_OBConversion_WriteString), -1);
  rb_define_method(cOBConversion.klass, "WriteFile", VALUEFUNC(_wrap_OBConversion_WriteFile), -1);
  rb_define_method(cOBConversion.klass, "CloseOutFile", VALUEFUNC(_wrap_OBConversion_CloseOutFile), -1);
  rb_define_method(cOBConversion.klass, "Read", VALUEFUNC(_wrap_OBConversion_Read), -1);
  rb_define_method(cOBConversion.klass, "ReadString", VALUEFUNC(_wrap_OBConversion_ReadString), -1);
  rb_define_method(cOBConversion.klass, "ReadFile", VALUEFUNC(_wrap_OBConversion_ReadFile), -1);
  cOBConversion.mark = 0;
  cOBConversion.destroy = (void (*)(void *)) free_OpenBabel_OBConversion;
  cOBConversion.trackObjects = 0;
  rb_define_const(mOpenbabel, "NOTREADABLE", SWIG_From_int(static_cast< int >(0x01)));
  rb_define_const(mOpenbabel, "READONEONLY", SWIG_From_int(static_cast< int >(0x02)));
  rb_define_const(mOpenbabel, "READBINARY", SWIG_From_int(static_cast< int >(0x04)));
  rb_define_const(mOpenbabel, "ZEROATOMSOK", SWIG_From_int(static_cast< int >(0x08)));
  rb_define_const(mOpenbabel, "NOTWRITABLE", SWIG_From_int(static_cast< int >(0x10)));
  rb_define_const(mOpenbabel, "WRITEONEONLY", SWIG_From_int(static_cast< int >(0x20)));
  rb_define_const(mOpenbabel, "WRITEBINARY", SWIG_From_int(static_cast< int >(0x40)));
  rb_define_const(mOpenbabel, "READXML", SWIG_From_int(static_cast< int >(0x80)));
  rb_define_const(mOpenbabel, "DEFAULTFORMAT", SWIG_From_int(static_cast< int >(0x4000)));
  
  cOBResidue.klass = rb_define_class_under(mOpenbabel, "OBResidue", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidue, (void *) &cOBResidue);
  rb_define_alloc_func(cOBResidue.klass, _wrap_OBResidue_allocate);
  rb_define_method(cOBResidue.klass, "initialize", VALUEFUNC(_wrap_new_OBResidue), -1);
  rb_define_method(cOBResidue.klass, "AddAtom", VALUEFUNC(_wrap_OBResidue_AddAtom), -1);
  rb_define_method(cOBResidue.klass, "InsertAtom", VALUEFUNC(_wrap_OBResidue_InsertAtom), -1);
  rb_define_method(cOBResidue.klass, "RemoveAtom", VALUEFUNC(_wrap_OBResidue_RemoveAtom), -1);
  rb_define_method(cOBResidue.klass, "Clear", VALUEFUNC(_wrap_OBResidue_Clear), -1);
  rb_define_method(cOBResidue.klass, "SetName", VALUEFUNC(_wrap_OBResidue_SetName), -1);
  rb_define_method(cOBResidue.klass, "SetNum", VALUEFUNC(_wrap_OBResidue_SetNum), -1);
  rb_define_method(cOBResidue.klass, "SetChain", VALUEFUNC(_wrap_OBResidue_SetChain), -1);
  rb_define_method(cOBResidue.klass, "SetChainNum", VALUEFUNC(_wrap_OBResidue_SetChainNum), -1);
  rb_define_method(cOBResidue.klass, "SetIdx", VALUEFUNC(_wrap_OBResidue_SetIdx), -1);
  rb_define_method(cOBResidue.klass, "SetAtomID", VALUEFUNC(_wrap_OBResidue_SetAtomID), -1);
  rb_define_method(cOBResidue.klass, "SetHetAtom", VALUEFUNC(_wrap_OBResidue_SetHetAtom), -1);
  rb_define_method(cOBResidue.klass, "SetSerialNum", VALUEFUNC(_wrap_OBResidue_SetSerialNum), -1);
  rb_define_method(cOBResidue.klass, "GetName", VALUEFUNC(_wrap_OBResidue_GetName), -1);
  rb_define_method(cOBResidue.klass, "GetNum", VALUEFUNC(_wrap_OBResidue_GetNum), -1);
  rb_define_method(cOBResidue.klass, "GetNumAtoms", VALUEFUNC(_wrap_OBResidue_GetNumAtoms), -1);
  rb_define_method(cOBResidue.klass, "GetChain", VALUEFUNC(_wrap_OBResidue_GetChain), -1);
  rb_define_method(cOBResidue.klass, "GetChainNum", VALUEFUNC(_wrap_OBResidue_GetChainNum), -1);
  rb_define_method(cOBResidue.klass, "GetIdx", VALUEFUNC(_wrap_OBResidue_GetIdx), -1);
  rb_define_method(cOBResidue.klass, "GetResKey", VALUEFUNC(_wrap_OBResidue_GetResKey), -1);
  rb_define_method(cOBResidue.klass, "GetAtoms", VALUEFUNC(_wrap_OBResidue_GetAtoms), -1);
  rb_define_method(cOBResidue.klass, "GetBonds", VALUEFUNC(_wrap_OBResidue_GetBonds), -1);
  rb_define_method(cOBResidue.klass, "GetAtomID", VALUEFUNC(_wrap_OBResidue_GetAtomID), -1);
  rb_define_method(cOBResidue.klass, "GetSerialNum", VALUEFUNC(_wrap_OBResidue_GetSerialNum), -1);
  rb_define_method(cOBResidue.klass, "GetAminoAcidProperty", VALUEFUNC(_wrap_OBResidue_GetAminoAcidProperty), -1);
  rb_define_method(cOBResidue.klass, "GetAtomProperty", VALUEFUNC(_wrap_OBResidue_GetAtomProperty), -1);
  rb_define_method(cOBResidue.klass, "GetResidueProperty", VALUEFUNC(_wrap_OBResidue_GetResidueProperty), -1);
  rb_define_method(cOBResidue.klass, "IsHetAtom", VALUEFUNC(_wrap_OBResidue_IsHetAtom), -1);
  rb_define_method(cOBResidue.klass, "IsResidueType", VALUEFUNC(_wrap_OBResidue_IsResidueType), -1);
  rb_define_method(cOBResidue.klass, "BeginAtoms", VALUEFUNC(_wrap_OBResidue_BeginAtoms), -1);
  rb_define_method(cOBResidue.klass, "EndAtoms", VALUEFUNC(_wrap_OBResidue_EndAtoms), -1);
  rb_define_method(cOBResidue.klass, "BeginAtom", VALUEFUNC(_wrap_OBResidue_BeginAtom), -1);
  rb_define_method(cOBResidue.klass, "NextAtom", VALUEFUNC(_wrap_OBResidue_NextAtom), -1);
  cOBResidue.mark = 0;
  cOBResidue.destroy = (void (*)(void *)) free_OpenBabel_OBResidue;
  cOBResidue.trackObjects = 0;
  rb_define_const(mOpenbabel, "MAXSETNO", SWIG_From_int(static_cast< int >(40)));
  rb_define_const(mOpenbabel, "MAXELEM", SWIG_From_int(static_cast< int >(1024)));
  rb_define_const(mOpenbabel, "MINELEM", SWIG_From_int(static_cast< int >(29)));
  rb_define_const(mOpenbabel, "MAXRES", SWIG_From_int(static_cast< int >(100)));
  rb_define_const(mOpenbabel, "MINRES", SWIG_From_int(static_cast< int >(54)));
  rb_define_const(mOpenbabel, "AA_ALA", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "AA_GLY", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "AA_LEU", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "AA_SER", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "AA_VAL", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "AA_THR", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "AA_LYS", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenbabel, "AA_ASP", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenbabel, "AA_ILE", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenbabel, "AA_ASN", SWIG_From_int(static_cast< int >((1 << 10))));
  rb_define_const(mOpenbabel, "AA_GLU", SWIG_From_int(static_cast< int >((1 << 11))));
  rb_define_const(mOpenbabel, "AA_PRO", SWIG_From_int(static_cast< int >((1 << 12))));
  rb_define_const(mOpenbabel, "AA_ARG", SWIG_From_int(static_cast< int >((1 << 13))));
  rb_define_const(mOpenbabel, "AA_PHE", SWIG_From_int(static_cast< int >((1 << 14))));
  rb_define_const(mOpenbabel, "AA_GLN", SWIG_From_int(static_cast< int >((1 << 15))));
  rb_define_const(mOpenbabel, "AA_TYR", SWIG_From_int(static_cast< int >((1 << 16))));
  rb_define_const(mOpenbabel, "AA_HIS", SWIG_From_int(static_cast< int >((1 << 17))));
  rb_define_const(mOpenbabel, "AA_CYS", SWIG_From_int(static_cast< int >((1 << 18))));
  rb_define_const(mOpenbabel, "AA_MET", SWIG_From_int(static_cast< int >((1 << 19))));
  rb_define_const(mOpenbabel, "AA_TRP", SWIG_From_int(static_cast< int >((1 << 20))));
  rb_define_const(mOpenbabel, "ACIDIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::ACIDIC)));
  rb_define_const(mOpenbabel, "ACYCLIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::ACYCLIC)));
  rb_define_const(mOpenbabel, "ALIPHATIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::ALIPHATIC)));
  rb_define_const(mOpenbabel, "AROMATIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::AROMATIC)));
  rb_define_const(mOpenbabel, "BASIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::BASIC)));
  rb_define_const(mOpenbabel, "BURIED", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::BURIED)));
  rb_define_const(mOpenbabel, "CHARGED", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::CHARGED)));
  rb_define_const(mOpenbabel, "CYCLIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::CYCLIC)));
  rb_define_const(mOpenbabel, "HYDROPHOBIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::HYDROPHOBIC)));
  rb_define_const(mOpenbabel, "LARGE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::LARGE)));
  rb_define_const(mOpenbabel, "MEDIUM", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::MEDIUM)));
  rb_define_const(mOpenbabel, "NEGATIVE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::NEGATIVE)));
  rb_define_const(mOpenbabel, "NEUTRAL", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::NEUTRAL)));
  rb_define_const(mOpenbabel, "POLAR", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::POLAR)));
  rb_define_const(mOpenbabel, "POSITIVE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::POSITIVE)));
  rb_define_const(mOpenbabel, "SMALL", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::SMALL)));
  rb_define_const(mOpenbabel, "SURFACE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::SURFACE)));
  rb_define_const(mOpenbabel, "ALPHA_CARBON", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::ALPHA_CARBON)));
  rb_define_const(mOpenbabel, "AMINO_BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::AMINO_BACKBONE)));
  rb_define_const(mOpenbabel, "BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::BACKBONE)));
  rb_define_const(mOpenbabel, "CYSTEINE_SULPHUR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::CYSTEINE_SULPHUR)));
  rb_define_const(mOpenbabel, "LIGAND", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::LIGAND)));
  rb_define_const(mOpenbabel, "NUCLEIC_BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::NUCLEIC_BACKBONE)));
  rb_define_const(mOpenbabel, "SHAPELY_BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SHAPELY_BACKBONE)));
  rb_define_const(mOpenbabel, "SHAPELY_SPECIAL", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SHAPELY_SPECIAL)));
  rb_define_const(mOpenbabel, "SIDECHAIN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SIDECHAIN)));
  rb_define_const(mOpenbabel, "SUGAR_PHOSPHATE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SUGAR_PHOSPHATE)));
  rb_define_const(mOpenbabel, "ALA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ALA)));
  rb_define_const(mOpenbabel, "GLY", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLY)));
  rb_define_const(mOpenbabel, "LEU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::LEU)));
  rb_define_const(mOpenbabel, "SER", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::SER)));
  rb_define_const(mOpenbabel, "VAL", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::VAL)));
  rb_define_const(mOpenbabel, "THR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::THR)));
  rb_define_const(mOpenbabel, "LYS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::LYS)));
  rb_define_const(mOpenbabel, "ASP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ASP)));
  rb_define_const(mOpenbabel, "ILE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ILE)));
  rb_define_const(mOpenbabel, "ASN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ASN)));
  rb_define_const(mOpenbabel, "GLU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLU)));
  rb_define_const(mOpenbabel, "PRO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PRO)));
  rb_define_const(mOpenbabel, "ARG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ARG)));
  rb_define_const(mOpenbabel, "PHE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PHE)));
  rb_define_const(mOpenbabel, "GLN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLN)));
  rb_define_const(mOpenbabel, "TYR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::TYR)));
  rb_define_const(mOpenbabel, "HIS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::HIS)));
  rb_define_const(mOpenbabel, "CYS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::CYS)));
  rb_define_const(mOpenbabel, "MET", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::MET)));
  rb_define_const(mOpenbabel, "TRP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::TRP)));
  rb_define_const(mOpenbabel, "ASX", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ASX)));
  rb_define_const(mOpenbabel, "GLX", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLX)));
  rb_define_const(mOpenbabel, "PCA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PCA)));
  rb_define_const(mOpenbabel, "HYP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::HYP)));
  rb_define_const(mOpenbabel, "A", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::A)));
  rb_define_const(mOpenbabel, "C", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::C)));
  rb_define_const(mOpenbabel, "G", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::G)));
  rb_define_const(mOpenbabel, "T", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::T)));
  rb_define_const(mOpenbabel, "U", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::U)));
  rb_define_const(mOpenbabel, "UPLUS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::UPLUS)));
  rb_define_const(mOpenbabel, "I", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::I)));
  rb_define_const(mOpenbabel, "_1MA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_1MA)));
  rb_define_const(mOpenbabel, "_5MC", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_5MC)));
  rb_define_const(mOpenbabel, "OMC", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::OMC)));
  rb_define_const(mOpenbabel, "_1MG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_1MG)));
  rb_define_const(mOpenbabel, "_2MG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_2MG)));
  rb_define_const(mOpenbabel, "M2G", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::M2G)));
  rb_define_const(mOpenbabel, "_7MG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_7MG)));
  rb_define_const(mOpenbabel, "OMG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::OMG)));
  rb_define_const(mOpenbabel, "YG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::YG)));
  rb_define_const(mOpenbabel, "H2U", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::H2U)));
  rb_define_const(mOpenbabel, "_5MU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_5MU)));
  rb_define_const(mOpenbabel, "PSU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PSU)));
  rb_define_const(mOpenbabel, "UNK", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::UNK)));
  rb_define_const(mOpenbabel, "ACE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ACE)));
  rb_define_const(mOpenbabel, "FOR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::FOR)));
  rb_define_const(mOpenbabel, "HOH", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::HOH)));
  rb_define_const(mOpenbabel, "DOD", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::DOD)));
  rb_define_const(mOpenbabel, "SO4", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::SO4)));
  rb_define_const(mOpenbabel, "PO4", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PO4)));
  rb_define_const(mOpenbabel, "NAD", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::NAD)));
  rb_define_const(mOpenbabel, "COA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::COA)));
  rb_define_const(mOpenbabel, "NAP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::NAP)));
  rb_define_const(mOpenbabel, "NDP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::NDP)));
  rb_define_const(mOpenbabel, "AMINO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::AMINO)));
  rb_define_const(mOpenbabel, "AMINO_NUCLEO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::AMINO_NUCLEO)));
  rb_define_const(mOpenbabel, "COENZYME", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::COENZYME)));
  rb_define_const(mOpenbabel, "ION", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::ION)));
  rb_define_const(mOpenbabel, "NUCLEO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::NUCLEO)));
  rb_define_const(mOpenbabel, "PROTEIN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::PROTEIN)));
  rb_define_const(mOpenbabel, "PURINE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::PURINE)));
  rb_define_const(mOpenbabel, "PYRIMIDINE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::PYRIMIDINE)));
  rb_define_const(mOpenbabel, "SOLVENT", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::SOLVENT)));
  rb_define_const(mOpenbabel, "WATER", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::WATER)));
  rb_define_singleton_method(mOpenbabel, "Residue", VALUEFUNC(Residue_get), 0);
  rb_define_singleton_method(mOpenbabel, "Residue=", VALUEFUNC(Residue_set), 1);
  rb_define_singleton_method(mOpenbabel, "ElemDesc", VALUEFUNC(ElemDesc_get), 0);
  rb_define_singleton_method(mOpenbabel, "ElemDesc=", VALUEFUNC(ElemDesc_set), 1);
  rb_define_singleton_method(mOpenbabel, "ResNo", VALUEFUNC(ResNo_get), 0);
  rb_define_singleton_method(mOpenbabel, "ResNo=", VALUEFUNC(ResNo_set), 1);
  rb_define_singleton_method(mOpenbabel, "ElemNo", VALUEFUNC(ElemNo_get), 0);
  rb_define_singleton_method(mOpenbabel, "ElemNo=", VALUEFUNC(ElemNo_set), 1);
  
  cOBInternalCoord.klass = rb_define_class_under(mOpenbabel, "OBInternalCoord", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBInternalCoord, (void *) &cOBInternalCoord);
  rb_define_alloc_func(cOBInternalCoord.klass, _wrap_OBInternalCoord_allocate);
  rb_define_method(cOBInternalCoord.klass, "initialize", VALUEFUNC(_wrap_new_OBInternalCoord), -1);
  rb_define_method(cOBInternalCoord.klass, "_a=", VALUEFUNC(_wrap_OBInternalCoord__a_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_a", VALUEFUNC(_wrap_OBInternalCoord__a_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_b=", VALUEFUNC(_wrap_OBInternalCoord__b_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_b", VALUEFUNC(_wrap_OBInternalCoord__b_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_c=", VALUEFUNC(_wrap_OBInternalCoord__c_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_c", VALUEFUNC(_wrap_OBInternalCoord__c_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_dst=", VALUEFUNC(_wrap_OBInternalCoord__dst_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_dst", VALUEFUNC(_wrap_OBInternalCoord__dst_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_ang=", VALUEFUNC(_wrap_OBInternalCoord__ang_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_ang", VALUEFUNC(_wrap_OBInternalCoord__ang_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_tor=", VALUEFUNC(_wrap_OBInternalCoord__tor_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_tor", VALUEFUNC(_wrap_OBInternalCoord__tor_get), -1);
  cOBInternalCoord.mark = 0;
  cOBInternalCoord.destroy = (void (*)(void *)) free_OpenBabel_OBInternalCoord;
  cOBInternalCoord.trackObjects = 0;
  rb_define_const(mOpenbabel, "OB_4RING_ATOM", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "OB_3RING_ATOM", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "OB_AROMATIC_ATOM", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "OB_RING_ATOM", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "OB_CSTEREO_ATOM", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "OB_ACSTEREO_ATOM", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "OB_DONOR_ATOM", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenbabel, "OB_ACCEPTOR_ATOM", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenbabel, "OB_CHIRAL_ATOM", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenbabel, "OB_POS_CHIRAL_ATOM", SWIG_From_int(static_cast< int >((1 << 10))));
  rb_define_const(mOpenbabel, "OB_NEG_CHIRAL_ATOM", SWIG_From_int(static_cast< int >((1 << 11))));
  rb_define_const(mOpenbabel, "OB_ATOM_HAS_NO_H", SWIG_From_int(static_cast< int >((1 << 12))));
  
  cOBAtom.klass = rb_define_class_under(mOpenbabel, "OBAtom", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAtom, (void *) &cOBAtom);
  rb_define_alloc_func(cOBAtom.klass, _wrap_OBAtom_allocate);
  rb_define_method(cOBAtom.klass, "initialize", VALUEFUNC(_wrap_new_OBAtom), -1);
  rb_define_method(cOBAtom.klass, "Visit=", VALUEFUNC(_wrap_OBAtom_Visit_set), -1);
  rb_define_method(cOBAtom.klass, "Visit", VALUEFUNC(_wrap_OBAtom_Visit_get), -1);
  rb_define_method(cOBAtom.klass, "Clear", VALUEFUNC(_wrap_OBAtom_Clear), -1);
  rb_define_method(cOBAtom.klass, "SetIdx", VALUEFUNC(_wrap_OBAtom_SetIdx), -1);
  rb_define_method(cOBAtom.klass, "SetHyb", VALUEFUNC(_wrap_OBAtom_SetHyb), -1);
  rb_define_method(cOBAtom.klass, "SetAtomicNum", VALUEFUNC(_wrap_OBAtom_SetAtomicNum), -1);
  rb_define_method(cOBAtom.klass, "SetIsotope", VALUEFUNC(_wrap_OBAtom_SetIsotope), -1);
  rb_define_method(cOBAtom.klass, "SetImplicitValence", VALUEFUNC(_wrap_OBAtom_SetImplicitValence), -1);
  rb_define_method(cOBAtom.klass, "IncrementImplicitValence", VALUEFUNC(_wrap_OBAtom_IncrementImplicitValence), -1);
  rb_define_method(cOBAtom.klass, "DecrementImplicitValence", VALUEFUNC(_wrap_OBAtom_DecrementImplicitValence), -1);
  rb_define_method(cOBAtom.klass, "SetFormalCharge", VALUEFUNC(_wrap_OBAtom_SetFormalCharge), -1);
  rb_define_method(cOBAtom.klass, "SetSpinMultiplicity", VALUEFUNC(_wrap_OBAtom_SetSpinMultiplicity), -1);
  rb_define_method(cOBAtom.klass, "SetType", VALUEFUNC(_wrap_OBAtom_SetType), -1);
  rb_define_method(cOBAtom.klass, "SetPartialCharge", VALUEFUNC(_wrap_OBAtom_SetPartialCharge), -1);
  rb_define_method(cOBAtom.klass, "SetCoordPtr", VALUEFUNC(_wrap_OBAtom_SetCoordPtr), -1);
  rb_define_method(cOBAtom.klass, "SetVector", VALUEFUNC(_wrap_OBAtom_SetVector), -1);
  rb_define_method(cOBAtom.klass, "SetResidue", VALUEFUNC(_wrap_OBAtom_SetResidue), -1);
  rb_define_method(cOBAtom.klass, "SetParent", VALUEFUNC(_wrap_OBAtom_SetParent), -1);
  rb_define_method(cOBAtom.klass, "SetAromatic", VALUEFUNC(_wrap_OBAtom_SetAromatic), -1);
  rb_define_method(cOBAtom.klass, "UnsetAromatic", VALUEFUNC(_wrap_OBAtom_UnsetAromatic), -1);
  rb_define_method(cOBAtom.klass, "SetClockwiseStereo", VALUEFUNC(_wrap_OBAtom_SetClockwiseStereo), -1);
  rb_define_method(cOBAtom.klass, "SetAntiClockwiseStereo", VALUEFUNC(_wrap_OBAtom_SetAntiClockwiseStereo), -1);
  rb_define_method(cOBAtom.klass, "SetPositiveStereo", VALUEFUNC(_wrap_OBAtom_SetPositiveStereo), -1);
  rb_define_method(cOBAtom.klass, "SetNegativeStereo", VALUEFUNC(_wrap_OBAtom_SetNegativeStereo), -1);
  rb_define_method(cOBAtom.klass, "UnsetStereo", VALUEFUNC(_wrap_OBAtom_UnsetStereo), -1);
  rb_define_method(cOBAtom.klass, "SetInRing", VALUEFUNC(_wrap_OBAtom_SetInRing), -1);
  rb_define_method(cOBAtom.klass, "SetChiral", VALUEFUNC(_wrap_OBAtom_SetChiral), -1);
  rb_define_method(cOBAtom.klass, "ClearCoordPtr", VALUEFUNC(_wrap_OBAtom_ClearCoordPtr), -1);
  rb_define_method(cOBAtom.klass, "GetFormalCharge", VALUEFUNC(_wrap_OBAtom_GetFormalCharge), -1);
  rb_define_method(cOBAtom.klass, "GetAtomicNum", VALUEFUNC(_wrap_OBAtom_GetAtomicNum), -1);
  rb_define_method(cOBAtom.klass, "GetIsotope", VALUEFUNC(_wrap_OBAtom_GetIsotope), -1);
  rb_define_method(cOBAtom.klass, "GetSpinMultiplicity", VALUEFUNC(_wrap_OBAtom_GetSpinMultiplicity), -1);
  rb_define_method(cOBAtom.klass, "GetAtomicMass", VALUEFUNC(_wrap_OBAtom_GetAtomicMass), -1);
  rb_define_method(cOBAtom.klass, "GetExactMass", VALUEFUNC(_wrap_OBAtom_GetExactMass), -1);
  rb_define_method(cOBAtom.klass, "GetIdx", VALUEFUNC(_wrap_OBAtom_GetIdx), -1);
  rb_define_method(cOBAtom.klass, "GetCoordinateIdx", VALUEFUNC(_wrap_OBAtom_GetCoordinateIdx), -1);
  rb_define_method(cOBAtom.klass, "GetCIdx", VALUEFUNC(_wrap_OBAtom_GetCIdx), -1);
  rb_define_method(cOBAtom.klass, "GetValence", VALUEFUNC(_wrap_OBAtom_GetValence), -1);
  rb_define_method(cOBAtom.klass, "GetHyb", VALUEFUNC(_wrap_OBAtom_GetHyb), -1);
  rb_define_method(cOBAtom.klass, "GetImplicitValence", VALUEFUNC(_wrap_OBAtom_GetImplicitValence), -1);
  rb_define_method(cOBAtom.klass, "GetHvyValence", VALUEFUNC(_wrap_OBAtom_GetHvyValence), -1);
  rb_define_method(cOBAtom.klass, "GetHeteroValence", VALUEFUNC(_wrap_OBAtom_GetHeteroValence), -1);
  rb_define_method(cOBAtom.klass, "GetType", VALUEFUNC(_wrap_OBAtom_GetType), -1);
  rb_define_method(cOBAtom.klass, "GetX", VALUEFUNC(_wrap_OBAtom_GetX), -1);
  rb_define_method(cOBAtom.klass, "GetY", VALUEFUNC(_wrap_OBAtom_GetY), -1);
  rb_define_method(cOBAtom.klass, "GetZ", VALUEFUNC(_wrap_OBAtom_GetZ), -1);
  rb_define_method(cOBAtom.klass, "x", VALUEFUNC(_wrap_OBAtom_x), -1);
  rb_define_method(cOBAtom.klass, "y", VALUEFUNC(_wrap_OBAtom_y), -1);
  rb_define_method(cOBAtom.klass, "z", VALUEFUNC(_wrap_OBAtom_z), -1);
  rb_define_method(cOBAtom.klass, "GetCoordinate", VALUEFUNC(_wrap_OBAtom_GetCoordinate), -1);
  rb_define_method(cOBAtom.klass, "GetVector", VALUEFUNC(_wrap_OBAtom_GetVector), -1);
  rb_define_method(cOBAtom.klass, "GetPartialCharge", VALUEFUNC(_wrap_OBAtom_GetPartialCharge), -1);
  rb_define_method(cOBAtom.klass, "GetResidue", VALUEFUNC(_wrap_OBAtom_GetResidue), -1);
  rb_define_method(cOBAtom.klass, "GetParent", VALUEFUNC(_wrap_OBAtom_GetParent), -1);
  rb_define_method(cOBAtom.klass, "GetNewBondVector", VALUEFUNC(_wrap_OBAtom_GetNewBondVector), -1);
  rb_define_method(cOBAtom.klass, "GetBond", VALUEFUNC(_wrap_OBAtom_GetBond), -1);
  rb_define_method(cOBAtom.klass, "GetNextAtom", VALUEFUNC(_wrap_OBAtom_GetNextAtom), -1);
  rb_define_method(cOBAtom.klass, "BeginBonds", VALUEFUNC(_wrap_OBAtom_BeginBonds), -1);
  rb_define_method(cOBAtom.klass, "EndBonds", VALUEFUNC(_wrap_OBAtom_EndBonds), -1);
  rb_define_method(cOBAtom.klass, "BeginBond", VALUEFUNC(_wrap_OBAtom_BeginBond), -1);
  rb_define_method(cOBAtom.klass, "NextBond", VALUEFUNC(_wrap_OBAtom_NextBond), -1);
  rb_define_method(cOBAtom.klass, "BeginNbrAtom", VALUEFUNC(_wrap_OBAtom_BeginNbrAtom), -1);
  rb_define_method(cOBAtom.klass, "NextNbrAtom", VALUEFUNC(_wrap_OBAtom_NextNbrAtom), -1);
  rb_define_method(cOBAtom.klass, "GetDistance", VALUEFUNC(_wrap_OBAtom_GetDistance), -1);
  rb_define_method(cOBAtom.klass, "GetAngle", VALUEFUNC(_wrap_OBAtom_GetAngle), -1);
  rb_define_method(cOBAtom.klass, "NewResidue", VALUEFUNC(_wrap_OBAtom_NewResidue), -1);
  rb_define_method(cOBAtom.klass, "AddResidue", VALUEFUNC(_wrap_OBAtom_AddResidue), -1);
  rb_define_method(cOBAtom.klass, "DeleteResidue", VALUEFUNC(_wrap_OBAtom_DeleteResidue), -1);
  rb_define_method(cOBAtom.klass, "AddBond", VALUEFUNC(_wrap_OBAtom_AddBond), -1);
  rb_define_method(cOBAtom.klass, "InsertBond", VALUEFUNC(_wrap_OBAtom_InsertBond), -1);
  rb_define_method(cOBAtom.klass, "DeleteBond", VALUEFUNC(_wrap_OBAtom_DeleteBond), -1);
  rb_define_method(cOBAtom.klass, "ClearBond", VALUEFUNC(_wrap_OBAtom_ClearBond), -1);
  rb_define_method(cOBAtom.klass, "HtoMethyl", VALUEFUNC(_wrap_OBAtom_HtoMethyl), -1);
  rb_define_method(cOBAtom.klass, "SetHybAndGeom", VALUEFUNC(_wrap_OBAtom_SetHybAndGeom), -1);
  rb_define_method(cOBAtom.klass, "ForceNoH", VALUEFUNC(_wrap_OBAtom_ForceNoH), -1);
  rb_define_method(cOBAtom.klass, "HasNoHForced", VALUEFUNC(_wrap_OBAtom_HasNoHForced), -1);
  rb_define_method(cOBAtom.klass, "CountFreeOxygens", VALUEFUNC(_wrap_OBAtom_CountFreeOxygens), -1);
  rb_define_method(cOBAtom.klass, "ImplicitHydrogenCount", VALUEFUNC(_wrap_OBAtom_ImplicitHydrogenCount), -1);
  rb_define_method(cOBAtom.klass, "ExplicitHydrogenCount", VALUEFUNC(_wrap_OBAtom_ExplicitHydrogenCount), -1);
  rb_define_method(cOBAtom.klass, "MemberOfRingCount", VALUEFUNC(_wrap_OBAtom_MemberOfRingCount), -1);
  rb_define_method(cOBAtom.klass, "MemberOfRingSize", VALUEFUNC(_wrap_OBAtom_MemberOfRingSize), -1);
  rb_define_method(cOBAtom.klass, "CountRingBonds", VALUEFUNC(_wrap_OBAtom_CountRingBonds), -1);
  rb_define_method(cOBAtom.klass, "SmallestBondAngle", VALUEFUNC(_wrap_OBAtom_SmallestBondAngle), -1);
  rb_define_method(cOBAtom.klass, "AverageBondAngle", VALUEFUNC(_wrap_OBAtom_AverageBondAngle), -1);
  rb_define_method(cOBAtom.klass, "BOSum", VALUEFUNC(_wrap_OBAtom_BOSum), -1);
  rb_define_method(cOBAtom.klass, "KBOSum", VALUEFUNC(_wrap_OBAtom_KBOSum), -1);
  rb_define_method(cOBAtom.klass, "HasResidue", VALUEFUNC(_wrap_OBAtom_HasResidue), -1);
  rb_define_method(cOBAtom.klass, "IsHydrogen", VALUEFUNC(_wrap_OBAtom_IsHydrogen), -1);
  rb_define_method(cOBAtom.klass, "IsCarbon", VALUEFUNC(_wrap_OBAtom_IsCarbon), -1);
  rb_define_method(cOBAtom.klass, "IsNitrogen", VALUEFUNC(_wrap_OBAtom_IsNitrogen), -1);
  rb_define_method(cOBAtom.klass, "IsOxygen", VALUEFUNC(_wrap_OBAtom_IsOxygen), -1);
  rb_define_method(cOBAtom.klass, "IsSulfur", VALUEFUNC(_wrap_OBAtom_IsSulfur), -1);
  rb_define_method(cOBAtom.klass, "IsPhosphorus", VALUEFUNC(_wrap_OBAtom_IsPhosphorus), -1);
  rb_define_method(cOBAtom.klass, "IsAromatic", VALUEFUNC(_wrap_OBAtom_IsAromatic), -1);
  rb_define_method(cOBAtom.klass, "IsInRing", VALUEFUNC(_wrap_OBAtom_IsInRing), -1);
  rb_define_method(cOBAtom.klass, "IsInRingSize", VALUEFUNC(_wrap_OBAtom_IsInRingSize), -1);
  rb_define_method(cOBAtom.klass, "IsHeteroatom", VALUEFUNC(_wrap_OBAtom_IsHeteroatom), -1);
  rb_define_method(cOBAtom.klass, "IsNotCorH", VALUEFUNC(_wrap_OBAtom_IsNotCorH), -1);
  rb_define_method(cOBAtom.klass, "IsConnected", VALUEFUNC(_wrap_OBAtom_IsConnected), -1);
  rb_define_method(cOBAtom.klass, "IsOneThree", VALUEFUNC(_wrap_OBAtom_IsOneThree), -1);
  rb_define_method(cOBAtom.klass, "IsOneFour", VALUEFUNC(_wrap_OBAtom_IsOneFour), -1);
  rb_define_method(cOBAtom.klass, "IsCarboxylOxygen", VALUEFUNC(_wrap_OBAtom_IsCarboxylOxygen), -1);
  rb_define_method(cOBAtom.klass, "IsPhosphateOxygen", VALUEFUNC(_wrap_OBAtom_IsPhosphateOxygen), -1);
  rb_define_method(cOBAtom.klass, "IsSulfateOxygen", VALUEFUNC(_wrap_OBAtom_IsSulfateOxygen), -1);
  rb_define_method(cOBAtom.klass, "IsNitroOxygen", VALUEFUNC(_wrap_OBAtom_IsNitroOxygen), -1);
  rb_define_method(cOBAtom.klass, "IsAmideNitrogen", VALUEFUNC(_wrap_OBAtom_IsAmideNitrogen), -1);
  rb_define_method(cOBAtom.klass, "IsPolarHydrogen", VALUEFUNC(_wrap_OBAtom_IsPolarHydrogen), -1);
  rb_define_method(cOBAtom.klass, "IsNonPolarHydrogen", VALUEFUNC(_wrap_OBAtom_IsNonPolarHydrogen), -1);
  rb_define_method(cOBAtom.klass, "IsAromaticNOxide", VALUEFUNC(_wrap_OBAtom_IsAromaticNOxide), -1);
  rb_define_method(cOBAtom.klass, "IsChiral", VALUEFUNC(_wrap_OBAtom_IsChiral), -1);
  rb_define_method(cOBAtom.klass, "IsAxial", VALUEFUNC(_wrap_OBAtom_IsAxial), -1);
  rb_define_method(cOBAtom.klass, "IsClockwise", VALUEFUNC(_wrap_OBAtom_IsClockwise), -1);
  rb_define_method(cOBAtom.klass, "IsAntiClockwise", VALUEFUNC(_wrap_OBAtom_IsAntiClockwise), -1);
  rb_define_method(cOBAtom.klass, "IsPositiveStereo", VALUEFUNC(_wrap_OBAtom_IsPositiveStereo), -1);
  rb_define_method(cOBAtom.klass, "IsNegativeStereo", VALUEFUNC(_wrap_OBAtom_IsNegativeStereo), -1);
  rb_define_method(cOBAtom.klass, "HasChiralitySpecified", VALUEFUNC(_wrap_OBAtom_HasChiralitySpecified), -1);
  rb_define_method(cOBAtom.klass, "HasChiralVolume", VALUEFUNC(_wrap_OBAtom_HasChiralVolume), -1);
  rb_define_method(cOBAtom.klass, "IsHbondAcceptor", VALUEFUNC(_wrap_OBAtom_IsHbondAcceptor), -1);
  rb_define_method(cOBAtom.klass, "IsHbondDonor", VALUEFUNC(_wrap_OBAtom_IsHbondDonor), -1);
  rb_define_method(cOBAtom.klass, "IsHbondDonorH", VALUEFUNC(_wrap_OBAtom_IsHbondDonorH), -1);
  rb_define_method(cOBAtom.klass, "HasAlphaBetaUnsat", VALUEFUNC(_wrap_OBAtom_HasAlphaBetaUnsat), -1);
  rb_define_method(cOBAtom.klass, "HasBondOfOrder", VALUEFUNC(_wrap_OBAtom_HasBondOfOrder), -1);
  rb_define_method(cOBAtom.klass, "CountBondsOfOrder", VALUEFUNC(_wrap_OBAtom_CountBondsOfOrder), -1);
  rb_define_method(cOBAtom.klass, "HasNonSingleBond", VALUEFUNC(_wrap_OBAtom_HasNonSingleBond), -1);
  rb_define_method(cOBAtom.klass, "HasSingleBond", VALUEFUNC(_wrap_OBAtom_HasSingleBond), -1);
  rb_define_method(cOBAtom.klass, "HasDoubleBond", VALUEFUNC(_wrap_OBAtom_HasDoubleBond), -1);
  rb_define_method(cOBAtom.klass, "HasAromaticBond", VALUEFUNC(_wrap_OBAtom_HasAromaticBond), -1);
  rb_define_method(cOBAtom.klass, "MatchesSMARTS", VALUEFUNC(_wrap_OBAtom_MatchesSMARTS), -1);
  cOBAtom.mark = 0;
  cOBAtom.destroy = (void (*)(void *)) free_OpenBabel_OBAtom;
  cOBAtom.trackObjects = 0;
  rb_define_const(mOpenbabel, "OB_AROMATIC_BOND", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "OB_WEDGE_BOND", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "OB_HASH_BOND", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "OB_RING_BOND", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "OB_TORUP_BOND", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "OB_TORDOWN_BOND", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "OB_KSINGLE_BOND", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenbabel, "OB_KDOUBLE_BOND", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenbabel, "OB_KTRIPLE_BOND", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenbabel, "OB_CLOSURE_BOND", SWIG_From_int(static_cast< int >((1 << 10))));
  
  cOBBond.klass = rb_define_class_under(mOpenbabel, "OBBond", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBBond, (void *) &cOBBond);
  rb_define_alloc_func(cOBBond.klass, _wrap_OBBond_allocate);
  rb_define_method(cOBBond.klass, "initialize", VALUEFUNC(_wrap_new_OBBond), -1);
  rb_define_method(cOBBond.klass, "Visit=", VALUEFUNC(_wrap_OBBond_Visit_set), -1);
  rb_define_method(cOBBond.klass, "Visit", VALUEFUNC(_wrap_OBBond_Visit_get), -1);
  rb_define_method(cOBBond.klass, "SetIdx", VALUEFUNC(_wrap_OBBond_SetIdx), -1);
  rb_define_method(cOBBond.klass, "SetBO", VALUEFUNC(_wrap_OBBond_SetBO), -1);
  rb_define_method(cOBBond.klass, "SetBondOrder", VALUEFUNC(_wrap_OBBond_SetBondOrder), -1);
  rb_define_method(cOBBond.klass, "SetBegin", VALUEFUNC(_wrap_OBBond_SetBegin), -1);
  rb_define_method(cOBBond.klass, "SetEnd", VALUEFUNC(_wrap_OBBond_SetEnd), -1);
  rb_define_method(cOBBond.klass, "SetParent", VALUEFUNC(_wrap_OBBond_SetParent), -1);
  rb_define_method(cOBBond.klass, "SetLength", VALUEFUNC(_wrap_OBBond_SetLength), -1);
  rb_define_method(cOBBond.klass, "Set", VALUEFUNC(_wrap_OBBond_Set), -1);
  rb_define_method(cOBBond.klass, "SetKSingle", VALUEFUNC(_wrap_OBBond_SetKSingle), -1);
  rb_define_method(cOBBond.klass, "SetKDouble", VALUEFUNC(_wrap_OBBond_SetKDouble), -1);
  rb_define_method(cOBBond.klass, "SetKTriple", VALUEFUNC(_wrap_OBBond_SetKTriple), -1);
  rb_define_method(cOBBond.klass, "SetAromatic", VALUEFUNC(_wrap_OBBond_SetAromatic), -1);
  rb_define_method(cOBBond.klass, "SetHash", VALUEFUNC(_wrap_OBBond_SetHash), -1);
  rb_define_method(cOBBond.klass, "SetWedge", VALUEFUNC(_wrap_OBBond_SetWedge), -1);
  rb_define_method(cOBBond.klass, "SetUp", VALUEFUNC(_wrap_OBBond_SetUp), -1);
  rb_define_method(cOBBond.klass, "SetDown", VALUEFUNC(_wrap_OBBond_SetDown), -1);
  rb_define_method(cOBBond.klass, "SetInRing", VALUEFUNC(_wrap_OBBond_SetInRing), -1);
  rb_define_method(cOBBond.klass, "SetClosure", VALUEFUNC(_wrap_OBBond_SetClosure), -1);
  rb_define_method(cOBBond.klass, "UnsetHash", VALUEFUNC(_wrap_OBBond_UnsetHash), -1);
  rb_define_method(cOBBond.klass, "UnsetWedge", VALUEFUNC(_wrap_OBBond_UnsetWedge), -1);
  rb_define_method(cOBBond.klass, "UnsetUp", VALUEFUNC(_wrap_OBBond_UnsetUp), -1);
  rb_define_method(cOBBond.klass, "UnsetDown", VALUEFUNC(_wrap_OBBond_UnsetDown), -1);
  rb_define_method(cOBBond.klass, "UnsetAromatic", VALUEFUNC(_wrap_OBBond_UnsetAromatic), -1);
  rb_define_method(cOBBond.klass, "UnsetKekule", VALUEFUNC(_wrap_OBBond_UnsetKekule), -1);
  rb_define_method(cOBBond.klass, "GetIdx", VALUEFUNC(_wrap_OBBond_GetIdx), -1);
  rb_define_method(cOBBond.klass, "GetBO", VALUEFUNC(_wrap_OBBond_GetBO), -1);
  rb_define_method(cOBBond.klass, "GetBondOrder", VALUEFUNC(_wrap_OBBond_GetBondOrder), -1);
  rb_define_method(cOBBond.klass, "GetFlags", VALUEFUNC(_wrap_OBBond_GetFlags), -1);
  rb_define_method(cOBBond.klass, "GetBeginAtomIdx", VALUEFUNC(_wrap_OBBond_GetBeginAtomIdx), -1);
  rb_define_method(cOBBond.klass, "GetEndAtomIdx", VALUEFUNC(_wrap_OBBond_GetEndAtomIdx), -1);
  rb_define_method(cOBBond.klass, "GetBeginAtom", VALUEFUNC(_wrap_OBBond_GetBeginAtom), -1);
  rb_define_method(cOBBond.klass, "GetEndAtom", VALUEFUNC(_wrap_OBBond_GetEndAtom), -1);
  rb_define_method(cOBBond.klass, "GetNbrAtom", VALUEFUNC(_wrap_OBBond_GetNbrAtom), -1);
  rb_define_method(cOBBond.klass, "GetParent", VALUEFUNC(_wrap_OBBond_GetParent), -1);
  rb_define_method(cOBBond.klass, "GetEquibLength", VALUEFUNC(_wrap_OBBond_GetEquibLength), -1);
  rb_define_method(cOBBond.klass, "GetLength", VALUEFUNC(_wrap_OBBond_GetLength), -1);
  rb_define_method(cOBBond.klass, "GetNbrAtomIdx", VALUEFUNC(_wrap_OBBond_GetNbrAtomIdx), -1);
  rb_define_method(cOBBond.klass, "IsAromatic", VALUEFUNC(_wrap_OBBond_IsAromatic), -1);
  rb_define_method(cOBBond.klass, "IsInRing", VALUEFUNC(_wrap_OBBond_IsInRing), -1);
  rb_define_method(cOBBond.klass, "IsRotor", VALUEFUNC(_wrap_OBBond_IsRotor), -1);
  rb_define_method(cOBBond.klass, "IsAmide", VALUEFUNC(_wrap_OBBond_IsAmide), -1);
  rb_define_method(cOBBond.klass, "IsPrimaryAmide", VALUEFUNC(_wrap_OBBond_IsPrimaryAmide), -1);
  rb_define_method(cOBBond.klass, "IsSecondaryAmide", VALUEFUNC(_wrap_OBBond_IsSecondaryAmide), -1);
  rb_define_method(cOBBond.klass, "IsEster", VALUEFUNC(_wrap_OBBond_IsEster), -1);
  rb_define_method(cOBBond.klass, "IsCarbonyl", VALUEFUNC(_wrap_OBBond_IsCarbonyl), -1);
  rb_define_method(cOBBond.klass, "IsSingle", VALUEFUNC(_wrap_OBBond_IsSingle), -1);
  rb_define_method(cOBBond.klass, "IsDouble", VALUEFUNC(_wrap_OBBond_IsDouble), -1);
  rb_define_method(cOBBond.klass, "IsTriple", VALUEFUNC(_wrap_OBBond_IsTriple), -1);
  rb_define_method(cOBBond.klass, "IsKSingle", VALUEFUNC(_wrap_OBBond_IsKSingle), -1);
  rb_define_method(cOBBond.klass, "IsKDouble", VALUEFUNC(_wrap_OBBond_IsKDouble), -1);
  rb_define_method(cOBBond.klass, "IsKTriple", VALUEFUNC(_wrap_OBBond_IsKTriple), -1);
  rb_define_method(cOBBond.klass, "IsClosure", VALUEFUNC(_wrap_OBBond_IsClosure), -1);
  rb_define_method(cOBBond.klass, "IsUp", VALUEFUNC(_wrap_OBBond_IsUp), -1);
  rb_define_method(cOBBond.klass, "IsDown", VALUEFUNC(_wrap_OBBond_IsDown), -1);
  rb_define_method(cOBBond.klass, "IsWedge", VALUEFUNC(_wrap_OBBond_IsWedge), -1);
  rb_define_method(cOBBond.klass, "IsHash", VALUEFUNC(_wrap_OBBond_IsHash), -1);
  rb_define_method(cOBBond.klass, "IsDoubleBondGeometry", VALUEFUNC(_wrap_OBBond_IsDoubleBondGeometry), -1);
  cOBBond.mark = 0;
  cOBBond.destroy = (void (*)(void *)) free_OpenBabel_OBBond;
  cOBBond.trackObjects = 0;
  rb_define_const(mOpenbabel, "OB_SSSR_MOL", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "OB_RINGFLAGS_MOL", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "OB_AROMATIC_MOL", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "OB_ATOMTYPES_MOL", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "OB_CHIRALITY_MOL", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "OB_PCHARGE_MOL", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "OB_HYBRID_MOL", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenbabel, "OB_IMPVAL_MOL", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenbabel, "OB_KEKULE_MOL", SWIG_From_int(static_cast< int >((1 << 10))));
  rb_define_const(mOpenbabel, "OB_CLOSURE_MOL", SWIG_From_int(static_cast< int >((1 << 11))));
  rb_define_const(mOpenbabel, "OB_H_ADDED_MOL", SWIG_From_int(static_cast< int >((1 << 12))));
  rb_define_const(mOpenbabel, "OB_PH_CORRECTED_MOL", SWIG_From_int(static_cast< int >((1 << 13))));
  rb_define_const(mOpenbabel, "OB_AROM_CORRECTED_MOL", SWIG_From_int(static_cast< int >((1 << 14))));
  rb_define_const(mOpenbabel, "OB_CHAINS_MOL", SWIG_From_int(static_cast< int >((1 << 15))));
  rb_define_const(mOpenbabel, "OB_TCHARGE_MOL", SWIG_From_int(static_cast< int >((1 << 16))));
  rb_define_const(mOpenbabel, "OB_TSPIN_MOL", SWIG_From_int(static_cast< int >((1 << 17))));
  rb_define_const(mOpenbabel, "OB_CURRENT_CONFORMER", SWIG_From_int(static_cast< int >(-1)));
  
  cOBMol.klass = rb_define_class_under(mOpenbabel, "OBMol", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMol, (void *) &cOBMol);
  rb_define_alloc_func(cOBMol.klass, _wrap_OBMol_allocate);
  rb_define_method(cOBMol.klass, "initialize", VALUEFUNC(_wrap_new_OBMol), -1);
  rb_define_method(cOBMol.klass, "ReserveAtoms", VALUEFUNC(_wrap_OBMol_ReserveAtoms), -1);
  rb_define_method(cOBMol.klass, "CreateAtom", VALUEFUNC(_wrap_OBMol_CreateAtom), -1);
  rb_define_method(cOBMol.klass, "CreateBond", VALUEFUNC(_wrap_OBMol_CreateBond), -1);
  rb_define_method(cOBMol.klass, "CreateResidue", VALUEFUNC(_wrap_OBMol_CreateResidue), -1);
  rb_define_method(cOBMol.klass, "DestroyAtom", VALUEFUNC(_wrap_OBMol_DestroyAtom), -1);
  rb_define_method(cOBMol.klass, "DestroyBond", VALUEFUNC(_wrap_OBMol_DestroyBond), -1);
  rb_define_method(cOBMol.klass, "DestroyResidue", VALUEFUNC(_wrap_OBMol_DestroyResidue), -1);
  rb_define_method(cOBMol.klass, "AddAtom", VALUEFUNC(_wrap_OBMol_AddAtom), -1);
  rb_define_method(cOBMol.klass, "InsertAtom", VALUEFUNC(_wrap_OBMol_InsertAtom), -1);
  rb_define_method(cOBMol.klass, "AddBond", VALUEFUNC(_wrap_OBMol_AddBond), -1);
  rb_define_method(cOBMol.klass, "AddResidue", VALUEFUNC(_wrap_OBMol_AddResidue), -1);
  rb_define_method(cOBMol.klass, "NewAtom", VALUEFUNC(_wrap_OBMol_NewAtom), -1);
  rb_define_method(cOBMol.klass, "NewBond", VALUEFUNC(_wrap_OBMol_NewBond), -1);
  rb_define_method(cOBMol.klass, "NewResidue", VALUEFUNC(_wrap_OBMol_NewResidue), -1);
  rb_define_method(cOBMol.klass, "DeleteAtom", VALUEFUNC(_wrap_OBMol_DeleteAtom), -1);
  rb_define_method(cOBMol.klass, "DeleteBond", VALUEFUNC(_wrap_OBMol_DeleteBond), -1);
  rb_define_method(cOBMol.klass, "DeleteResidue", VALUEFUNC(_wrap_OBMol_DeleteResidue), -1);
  rb_define_method(cOBMol.klass, "BeginModify", VALUEFUNC(_wrap_OBMol_BeginModify), -1);
  rb_define_method(cOBMol.klass, "EndModify", VALUEFUNC(_wrap_OBMol_EndModify), -1);
  rb_define_method(cOBMol.klass, "GetMod", VALUEFUNC(_wrap_OBMol_GetMod), -1);
  rb_define_method(cOBMol.klass, "IncrementMod", VALUEFUNC(_wrap_OBMol_IncrementMod), -1);
  rb_define_method(cOBMol.klass, "DecrementMod", VALUEFUNC(_wrap_OBMol_DecrementMod), -1);
  rb_define_method(cOBMol.klass, "GetFlags", VALUEFUNC(_wrap_OBMol_GetFlags), -1);
  rb_define_method(cOBMol.klass, "GetTitle", VALUEFUNC(_wrap_OBMol_GetTitle), -1);
  rb_define_method(cOBMol.klass, "NumAtoms", VALUEFUNC(_wrap_OBMol_NumAtoms), -1);
  rb_define_method(cOBMol.klass, "NumBonds", VALUEFUNC(_wrap_OBMol_NumBonds), -1);
  rb_define_method(cOBMol.klass, "NumHvyAtoms", VALUEFUNC(_wrap_OBMol_NumHvyAtoms), -1);
  rb_define_method(cOBMol.klass, "NumResidues", VALUEFUNC(_wrap_OBMol_NumResidues), -1);
  rb_define_method(cOBMol.klass, "NumRotors", VALUEFUNC(_wrap_OBMol_NumRotors), -1);
  rb_define_method(cOBMol.klass, "GetAtom", VALUEFUNC(_wrap_OBMol_GetAtom), -1);
  rb_define_method(cOBMol.klass, "GetFirstAtom", VALUEFUNC(_wrap_OBMol_GetFirstAtom), -1);
  rb_define_method(cOBMol.klass, "GetBond", VALUEFUNC(_wrap_OBMol_GetBond), -1);
  rb_define_method(cOBMol.klass, "GetResidue", VALUEFUNC(_wrap_OBMol_GetResidue), -1);
  rb_define_method(cOBMol.klass, "GetInternalCoord", VALUEFUNC(_wrap_OBMol_GetInternalCoord), -1);
  rb_define_method(cOBMol.klass, "GetTorsion", VALUEFUNC(_wrap_OBMol_GetTorsion), -1);
  rb_define_method(cOBMol.klass, "GetAngle", VALUEFUNC(_wrap_OBMol_GetAngle), -1);
  rb_define_method(cOBMol.klass, "GetFormula", VALUEFUNC(_wrap_OBMol_GetFormula), -1);
  rb_define_method(cOBMol.klass, "GetSpacedFormula", VALUEFUNC(_wrap_OBMol_GetSpacedFormula), -1);
  rb_define_method(cOBMol.klass, "GetEnergy", VALUEFUNC(_wrap_OBMol_GetEnergy), -1);
  rb_define_method(cOBMol.klass, "GetMolWt", VALUEFUNC(_wrap_OBMol_GetMolWt), -1);
  rb_define_method(cOBMol.klass, "GetExactMass", VALUEFUNC(_wrap_OBMol_GetExactMass), -1);
  rb_define_method(cOBMol.klass, "GetTotalCharge", VALUEFUNC(_wrap_OBMol_GetTotalCharge), -1);
  rb_define_method(cOBMol.klass, "GetTotalSpinMultiplicity", VALUEFUNC(_wrap_OBMol_GetTotalSpinMultiplicity), -1);
  rb_define_method(cOBMol.klass, "GetDimension", VALUEFUNC(_wrap_OBMol_GetDimension), -1);
  rb_define_method(cOBMol.klass, "GetCoordinates", VALUEFUNC(_wrap_OBMol_GetCoordinates), -1);
  rb_define_method(cOBMol.klass, "GetSSSR", VALUEFUNC(_wrap_OBMol_GetSSSR), -1);
  rb_define_method(cOBMol.klass, "AutomaticFormalCharge", VALUEFUNC(_wrap_OBMol_AutomaticFormalCharge), -1);
  rb_define_method(cOBMol.klass, "AutomaticPartialCharge", VALUEFUNC(_wrap_OBMol_AutomaticPartialCharge), -1);
  rb_define_method(cOBMol.klass, "SetTitle", VALUEFUNC(_wrap_OBMol_SetTitle), -1);
  rb_define_method(cOBMol.klass, "SetFormula", VALUEFUNC(_wrap_OBMol_SetFormula), -1);
  rb_define_method(cOBMol.klass, "SetEnergy", VALUEFUNC(_wrap_OBMol_SetEnergy), -1);
  rb_define_method(cOBMol.klass, "SetDimension", VALUEFUNC(_wrap_OBMol_SetDimension), -1);
  rb_define_method(cOBMol.klass, "SetTotalCharge", VALUEFUNC(_wrap_OBMol_SetTotalCharge), -1);
  rb_define_method(cOBMol.klass, "SetTotalSpinMultiplicity", VALUEFUNC(_wrap_OBMol_SetTotalSpinMultiplicity), -1);
  rb_define_method(cOBMol.klass, "SetInternalCoord", VALUEFUNC(_wrap_OBMol_SetInternalCoord), -1);
  rb_define_method(cOBMol.klass, "SetAutomaticFormalCharge", VALUEFUNC(_wrap_OBMol_SetAutomaticFormalCharge), -1);
  rb_define_method(cOBMol.klass, "SetAutomaticPartialCharge", VALUEFUNC(_wrap_OBMol_SetAutomaticPartialCharge), -1);
  rb_define_method(cOBMol.klass, "SetAromaticPerceived", VALUEFUNC(_wrap_OBMol_SetAromaticPerceived), -1);
  rb_define_method(cOBMol.klass, "SetSSSRPerceived", VALUEFUNC(_wrap_OBMol_SetSSSRPerceived), -1);
  rb_define_method(cOBMol.klass, "SetRingAtomsAndBondsPerceived", VALUEFUNC(_wrap_OBMol_SetRingAtomsAndBondsPerceived), -1);
  rb_define_method(cOBMol.klass, "SetAtomTypesPerceived", VALUEFUNC(_wrap_OBMol_SetAtomTypesPerceived), -1);
  rb_define_method(cOBMol.klass, "SetChainsPerceived", VALUEFUNC(_wrap_OBMol_SetChainsPerceived), -1);
  rb_define_method(cOBMol.klass, "SetChiralityPerceived", VALUEFUNC(_wrap_OBMol_SetChiralityPerceived), -1);
  rb_define_method(cOBMol.klass, "SetPartialChargesPerceived", VALUEFUNC(_wrap_OBMol_SetPartialChargesPerceived), -1);
  rb_define_method(cOBMol.klass, "SetHybridizationPerceived", VALUEFUNC(_wrap_OBMol_SetHybridizationPerceived), -1);
  rb_define_method(cOBMol.klass, "SetImplicitValencePerceived", VALUEFUNC(_wrap_OBMol_SetImplicitValencePerceived), -1);
  rb_define_method(cOBMol.klass, "SetKekulePerceived", VALUEFUNC(_wrap_OBMol_SetKekulePerceived), -1);
  rb_define_method(cOBMol.klass, "SetClosureBondsPerceived", VALUEFUNC(_wrap_OBMol_SetClosureBondsPerceived), -1);
  rb_define_method(cOBMol.klass, "SetHydrogensAdded", VALUEFUNC(_wrap_OBMol_SetHydrogensAdded), -1);
  rb_define_method(cOBMol.klass, "SetCorrectedForPH", VALUEFUNC(_wrap_OBMol_SetCorrectedForPH), -1);
  rb_define_method(cOBMol.klass, "SetAromaticCorrected", VALUEFUNC(_wrap_OBMol_SetAromaticCorrected), -1);
  rb_define_method(cOBMol.klass, "SetSpinMultiplicityAssigned", VALUEFUNC(_wrap_OBMol_SetSpinMultiplicityAssigned), -1);
  rb_define_method(cOBMol.klass, "SetFlags", VALUEFUNC(_wrap_OBMol_SetFlags), -1);
  rb_define_method(cOBMol.klass, "UnsetAromaticPerceived", VALUEFUNC(_wrap_OBMol_UnsetAromaticPerceived), -1);
  rb_define_method(cOBMol.klass, "UnsetPartialChargesPerceived", VALUEFUNC(_wrap_OBMol_UnsetPartialChargesPerceived), -1);
  rb_define_method(cOBMol.klass, "UnsetImplicitValencePerceived", VALUEFUNC(_wrap_OBMol_UnsetImplicitValencePerceived), -1);
  rb_define_method(cOBMol.klass, "UnsetHydrogensAdded", VALUEFUNC(_wrap_OBMol_UnsetHydrogensAdded), -1);
  rb_define_method(cOBMol.klass, "UnsetFlag", VALUEFUNC(_wrap_OBMol_UnsetFlag), -1);
  rb_define_method(cOBMol.klass, "DoTransformations", VALUEFUNC(_wrap_OBMol_DoTransformations), -1);
  rb_define_singleton_method(cOBMol.klass, "ClassDescription", VALUEFUNC(_wrap_OBMol_ClassDescription), -1);
  rb_define_method(cOBMol.klass, "Clear", VALUEFUNC(_wrap_OBMol_Clear), -1);
  rb_define_method(cOBMol.klass, "RenumberAtoms", VALUEFUNC(_wrap_OBMol_RenumberAtoms), -1);
  rb_define_method(cOBMol.klass, "ToInertialFrame", VALUEFUNC(_wrap_OBMol_ToInertialFrame), -1);
  rb_define_method(cOBMol.klass, "Translate", VALUEFUNC(_wrap_OBMol_Translate), -1);
  rb_define_method(cOBMol.klass, "Rotate", VALUEFUNC(_wrap_OBMol_Rotate), -1);
  rb_define_method(cOBMol.klass, "Kekulize", VALUEFUNC(_wrap_OBMol_Kekulize), -1);
  rb_define_method(cOBMol.klass, "PerceiveKekuleBonds", VALUEFUNC(_wrap_OBMol_PerceiveKekuleBonds), -1);
  rb_define_method(cOBMol.klass, "NewPerceiveKekuleBonds", VALUEFUNC(_wrap_OBMol_NewPerceiveKekuleBonds), -1);
  rb_define_method(cOBMol.klass, "DeleteHydrogens", VALUEFUNC(_wrap_OBMol_DeleteHydrogens), -1);
  rb_define_method(cOBMol.klass, "DeleteNonPolarHydrogens", VALUEFUNC(_wrap_OBMol_DeleteNonPolarHydrogens), -1);
  rb_define_method(cOBMol.klass, "DeleteHydrogen", VALUEFUNC(_wrap_OBMol_DeleteHydrogen), -1);
  rb_define_method(cOBMol.klass, "AddHydrogens", VALUEFUNC(_wrap_OBMol_AddHydrogens), -1);
  rb_define_method(cOBMol.klass, "AddPolarHydrogens", VALUEFUNC(_wrap_OBMol_AddPolarHydrogens), -1);
  rb_define_method(cOBMol.klass, "StripSalts", VALUEFUNC(_wrap_OBMol_StripSalts), -1);
  rb_define_method(cOBMol.klass, "Separate", VALUEFUNC(_wrap_OBMol_Separate), -1);
  rb_define_method(cOBMol.klass, "ConvertDativeBonds", VALUEFUNC(_wrap_OBMol_ConvertDativeBonds), -1);
  rb_define_method(cOBMol.klass, "CorrectForPH", VALUEFUNC(_wrap_OBMol_CorrectForPH), -1);
  rb_define_method(cOBMol.klass, "AssignSpinMultiplicity", VALUEFUNC(_wrap_OBMol_AssignSpinMultiplicity), -1);
  rb_define_method(cOBMol.klass, "Center", VALUEFUNC(_wrap_OBMol_Center), -1);
  rb_define_method(cOBMol.klass, "SetTorsion", VALUEFUNC(_wrap_OBMol_SetTorsion), -1);
  rb_define_method(cOBMol.klass, "FindSSSR", VALUEFUNC(_wrap_OBMol_FindSSSR), -1);
  rb_define_method(cOBMol.klass, "FindRingAtomsAndBonds", VALUEFUNC(_wrap_OBMol_FindRingAtomsAndBonds), -1);
  rb_define_method(cOBMol.klass, "FindChiralCenters", VALUEFUNC(_wrap_OBMol_FindChiralCenters), -1);
  rb_define_method(cOBMol.klass, "FindChildren", VALUEFUNC(_wrap_OBMol_FindChildren), -1);
  rb_define_method(cOBMol.klass, "FindLargestFragment", VALUEFUNC(_wrap_OBMol_FindLargestFragment), -1);
  rb_define_method(cOBMol.klass, "ContigFragList", VALUEFUNC(_wrap_OBMol_ContigFragList), -1);
  rb_define_method(cOBMol.klass, "Align", VALUEFUNC(_wrap_OBMol_Align), -1);
  rb_define_method(cOBMol.klass, "ConnectTheDots", VALUEFUNC(_wrap_OBMol_ConnectTheDots), -1);
  rb_define_method(cOBMol.klass, "PerceiveBondOrders", VALUEFUNC(_wrap_OBMol_PerceiveBondOrders), -1);
  rb_define_method(cOBMol.klass, "FindAngles", VALUEFUNC(_wrap_OBMol_FindAngles), -1);
  rb_define_method(cOBMol.klass, "FindTorsions", VALUEFUNC(_wrap_OBMol_FindTorsions), -1);
  rb_define_method(cOBMol.klass, "GetGTDVector", VALUEFUNC(_wrap_OBMol_GetGTDVector), -1);
  rb_define_method(cOBMol.klass, "GetGIVector", VALUEFUNC(_wrap_OBMol_GetGIVector), -1);
  rb_define_method(cOBMol.klass, "GetGIDVector", VALUEFUNC(_wrap_OBMol_GetGIDVector), -1);
  rb_define_method(cOBMol.klass, "Has2D", VALUEFUNC(_wrap_OBMol_Has2D), -1);
  rb_define_method(cOBMol.klass, "Has3D", VALUEFUNC(_wrap_OBMol_Has3D), -1);
  rb_define_method(cOBMol.klass, "HasNonZeroCoords", VALUEFUNC(_wrap_OBMol_HasNonZeroCoords), -1);
  rb_define_method(cOBMol.klass, "HasAromaticPerceived", VALUEFUNC(_wrap_OBMol_HasAromaticPerceived), -1);
  rb_define_method(cOBMol.klass, "HasSSSRPerceived", VALUEFUNC(_wrap_OBMol_HasSSSRPerceived), -1);
  rb_define_method(cOBMol.klass, "HasRingAtomsAndBondsPerceived", VALUEFUNC(_wrap_OBMol_HasRingAtomsAndBondsPerceived), -1);
  rb_define_method(cOBMol.klass, "HasAtomTypesPerceived", VALUEFUNC(_wrap_OBMol_HasAtomTypesPerceived), -1);
  rb_define_method(cOBMol.klass, "HasChiralityPerceived", VALUEFUNC(_wrap_OBMol_HasChiralityPerceived), -1);
  rb_define_method(cOBMol.klass, "HasPartialChargesPerceived", VALUEFUNC(_wrap_OBMol_HasPartialChargesPerceived), -1);
  rb_define_method(cOBMol.klass, "HasHybridizationPerceived", VALUEFUNC(_wrap_OBMol_HasHybridizationPerceived), -1);
  rb_define_method(cOBMol.klass, "HasImplicitValencePerceived", VALUEFUNC(_wrap_OBMol_HasImplicitValencePerceived), -1);
  rb_define_method(cOBMol.klass, "HasKekulePerceived", VALUEFUNC(_wrap_OBMol_HasKekulePerceived), -1);
  rb_define_method(cOBMol.klass, "HasClosureBondsPerceived", VALUEFUNC(_wrap_OBMol_HasClosureBondsPerceived), -1);
  rb_define_method(cOBMol.klass, "HasChainsPerceived", VALUEFUNC(_wrap_OBMol_HasChainsPerceived), -1);
  rb_define_method(cOBMol.klass, "HasHydrogensAdded", VALUEFUNC(_wrap_OBMol_HasHydrogensAdded), -1);
  rb_define_method(cOBMol.klass, "HasAromaticCorrected", VALUEFUNC(_wrap_OBMol_HasAromaticCorrected), -1);
  rb_define_method(cOBMol.klass, "IsCorrectedForPH", VALUEFUNC(_wrap_OBMol_IsCorrectedForPH), -1);
  rb_define_method(cOBMol.klass, "HasSpinMultiplicityAssigned", VALUEFUNC(_wrap_OBMol_HasSpinMultiplicityAssigned), -1);
  rb_define_method(cOBMol.klass, "IsChiral", VALUEFUNC(_wrap_OBMol_IsChiral), -1);
  rb_define_method(cOBMol.klass, "Empty", VALUEFUNC(_wrap_OBMol_Empty), -1);
  rb_define_method(cOBMol.klass, "NumConformers", VALUEFUNC(_wrap_OBMol_NumConformers), -1);
  rb_define_method(cOBMol.klass, "SetConformers", VALUEFUNC(_wrap_OBMol_SetConformers), -1);
  rb_define_method(cOBMol.klass, "AddConformer", VALUEFUNC(_wrap_OBMol_AddConformer), -1);
  rb_define_method(cOBMol.klass, "SetConformer", VALUEFUNC(_wrap_OBMol_SetConformer), -1);
  rb_define_method(cOBMol.klass, "CopyConformer", VALUEFUNC(_wrap_OBMol_CopyConformer), -1);
  rb_define_method(cOBMol.klass, "DeleteConformer", VALUEFUNC(_wrap_OBMol_DeleteConformer), -1);
  rb_define_method(cOBMol.klass, "GetConformer", VALUEFUNC(_wrap_OBMol_GetConformer), -1);
  rb_define_method(cOBMol.klass, "BeginConformer", VALUEFUNC(_wrap_OBMol_BeginConformer), -1);
  rb_define_method(cOBMol.klass, "NextConformer", VALUEFUNC(_wrap_OBMol_NextConformer), -1);
  rb_define_method(cOBMol.klass, "GetConformers", VALUEFUNC(_wrap_OBMol_GetConformers), -1);
  rb_define_method(cOBMol.klass, "BeginAtoms", VALUEFUNC(_wrap_OBMol_BeginAtoms), -1);
  rb_define_method(cOBMol.klass, "EndAtoms", VALUEFUNC(_wrap_OBMol_EndAtoms), -1);
  rb_define_method(cOBMol.klass, "BeginBonds", VALUEFUNC(_wrap_OBMol_BeginBonds), -1);
  rb_define_method(cOBMol.klass, "EndBonds", VALUEFUNC(_wrap_OBMol_EndBonds), -1);
  rb_define_method(cOBMol.klass, "BeginResidues", VALUEFUNC(_wrap_OBMol_BeginResidues), -1);
  rb_define_method(cOBMol.klass, "EndResidues", VALUEFUNC(_wrap_OBMol_EndResidues), -1);
  rb_define_method(cOBMol.klass, "BeginAtom", VALUEFUNC(_wrap_OBMol_BeginAtom), -1);
  rb_define_method(cOBMol.klass, "NextAtom", VALUEFUNC(_wrap_OBMol_NextAtom), -1);
  rb_define_method(cOBMol.klass, "BeginBond", VALUEFUNC(_wrap_OBMol_BeginBond), -1);
  rb_define_method(cOBMol.klass, "NextBond", VALUEFUNC(_wrap_OBMol_NextBond), -1);
  rb_define_method(cOBMol.klass, "BeginResidue", VALUEFUNC(_wrap_OBMol_BeginResidue), -1);
  rb_define_method(cOBMol.klass, "NextResidue", VALUEFUNC(_wrap_OBMol_NextResidue), -1);
  rb_define_method(cOBMol.klass, "BeginInternalCoord", VALUEFUNC(_wrap_OBMol_BeginInternalCoord), -1);
  rb_define_method(cOBMol.klass, "NextInternalCoord", VALUEFUNC(_wrap_OBMol_NextInternalCoord), -1);
  cOBMol.mark = 0;
  cOBMol.destroy = (void (*)(void *)) free_OpenBabel_OBMol;
  cOBMol.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "tokenize", VALUEFUNC(_wrap_tokenize), -1);
  rb_define_module_function(mOpenbabel, "ThrowError", VALUEFUNC(_wrap_ThrowError), -1);
  rb_define_module_function(mOpenbabel, "CartesianToInternal", VALUEFUNC(_wrap_CartesianToInternal), -1);
  rb_define_module_function(mOpenbabel, "InternalToCartesian", VALUEFUNC(_wrap_InternalToCartesian), -1);
  rb_define_module_function(mOpenbabel, "NewExtension", VALUEFUNC(_wrap_NewExtension), -1);
  rb_define_singleton_method(mOpenbabel, "etab", VALUEFUNC(etab_get), 0);
  rb_define_singleton_method(mOpenbabel, "etab=", VALUEFUNC(etab_set), 1);
  rb_define_singleton_method(mOpenbabel, "ttab", VALUEFUNC(ttab_get), 0);
  rb_define_singleton_method(mOpenbabel, "ttab=", VALUEFUNC(ttab_set), 1);
  rb_define_singleton_method(mOpenbabel, "isotab", VALUEFUNC(isotab_get), 0);
  rb_define_singleton_method(mOpenbabel, "isotab=", VALUEFUNC(isotab_set), 1);
  rb_define_singleton_method(mOpenbabel, "aromtyper", VALUEFUNC(aromtyper_get), 0);
  rb_define_singleton_method(mOpenbabel, "aromtyper=", VALUEFUNC(aromtyper_set), 1);
  rb_define_singleton_method(mOpenbabel, "atomtyper", VALUEFUNC(atomtyper_get), 0);
  rb_define_singleton_method(mOpenbabel, "atomtyper=", VALUEFUNC(atomtyper_set), 1);
  rb_define_singleton_method(mOpenbabel, "chainsparser", VALUEFUNC(chainsparser_get), 0);
  rb_define_singleton_method(mOpenbabel, "chainsparser=", VALUEFUNC(chainsparser_set), 1);
  rb_define_singleton_method(mOpenbabel, "resdat", VALUEFUNC(resdat_get), 0);
  rb_define_singleton_method(mOpenbabel, "resdat=", VALUEFUNC(resdat_set), 1);
  rb_define_const(mOpenbabel, "BUFF_SIZE", SWIG_From_int(static_cast< int >(32768)));
  rb_define_module_function(mOpenbabel, "get_rmat", VALUEFUNC(_wrap_get_rmat), -1);
  rb_define_module_function(mOpenbabel, "ob_make_rmat", VALUEFUNC(_wrap_ob_make_rmat), -1);
  rb_define_module_function(mOpenbabel, "qtrfit", VALUEFUNC(_wrap_qtrfit), -1);
  rb_define_module_function(mOpenbabel, "superimpose", VALUEFUNC(_wrap_superimpose), -1);
  
  cOBRing.klass = rb_define_class_under(mOpenbabel, "OBRing", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRing, (void *) &cOBRing);
  rb_define_alloc_func(cOBRing.klass, _wrap_OBRing_allocate);
  rb_define_method(cOBRing.klass, "initialize", VALUEFUNC(_wrap_new_OBRing), -1);
  rb_define_method(cOBRing.klass, "_path=", VALUEFUNC(_wrap_OBRing__path_set), -1);
  rb_define_method(cOBRing.klass, "_path", VALUEFUNC(_wrap_OBRing__path_get), -1);
  rb_define_method(cOBRing.klass, "_pathset=", VALUEFUNC(_wrap_OBRing__pathset_set), -1);
  rb_define_method(cOBRing.klass, "_pathset", VALUEFUNC(_wrap_OBRing__pathset_get), -1);
  rb_define_method(cOBRing.klass, "Size", VALUEFUNC(_wrap_OBRing_Size), -1);
  rb_define_method(cOBRing.klass, "PathSize", VALUEFUNC(_wrap_OBRing_PathSize), -1);
  rb_define_method(cOBRing.klass, "IsAromatic", VALUEFUNC(_wrap_OBRing_IsAromatic), -1);
  rb_define_method(cOBRing.klass, "IsMember", VALUEFUNC(_wrap_OBRing_IsMember), -1);
  rb_define_method(cOBRing.klass, "IsInRing", VALUEFUNC(_wrap_OBRing_IsInRing), -1);
  rb_define_method(cOBRing.klass, "SetParent", VALUEFUNC(_wrap_OBRing_SetParent), -1);
  rb_define_method(cOBRing.klass, "GetParent", VALUEFUNC(_wrap_OBRing_GetParent), -1);
  rb_define_method(cOBRing.klass, "findCenterAndNormal", VALUEFUNC(_wrap_OBRing_findCenterAndNormal), -1);
  cOBRing.mark = 0;
  cOBRing.destroy = (void (*)(void *)) free_OpenBabel_OBRing;
  cOBRing.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "CompareRingSize", VALUEFUNC(_wrap_CompareRingSize), -1);
  
  cOBRingSearch.klass = rb_define_class_under(mOpenbabel, "OBRingSearch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRingSearch, (void *) &cOBRingSearch);
  rb_define_alloc_func(cOBRingSearch.klass, _wrap_OBRingSearch_allocate);
  rb_define_method(cOBRingSearch.klass, "initialize", VALUEFUNC(_wrap_new_OBRingSearch), -1);
  rb_define_method(cOBRingSearch.klass, "SortRings", VALUEFUNC(_wrap_OBRingSearch_SortRings), -1);
  rb_define_method(cOBRingSearch.klass, "RemoveRedundant", VALUEFUNC(_wrap_OBRingSearch_RemoveRedundant), -1);
  rb_define_method(cOBRingSearch.klass, "AddRingFromClosure", VALUEFUNC(_wrap_OBRingSearch_AddRingFromClosure), -1);
  rb_define_method(cOBRingSearch.klass, "SaveUniqueRing", VALUEFUNC(_wrap_OBRingSearch_SaveUniqueRing), -1);
  rb_define_method(cOBRingSearch.klass, "WriteRings", VALUEFUNC(_wrap_OBRingSearch_WriteRings), -1);
  rb_define_method(cOBRingSearch.klass, "BeginRings", VALUEFUNC(_wrap_OBRingSearch_BeginRings), -1);
  rb_define_method(cOBRingSearch.klass, "EndRings", VALUEFUNC(_wrap_OBRingSearch_EndRings), -1);
  cOBRingSearch.mark = 0;
  cOBRingSearch.destroy = (void (*)(void *)) free_OpenBabel_OBRingSearch;
  cOBRingSearch.trackObjects = 0;
  
  cOBRTree.klass = rb_define_class_under(mOpenbabel, "OBRTree", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRTree, (void *) &cOBRTree);
  rb_define_alloc_func(cOBRTree.klass, _wrap_OBRTree_allocate);
  rb_define_method(cOBRTree.klass, "initialize", VALUEFUNC(_wrap_new_OBRTree), -1);
  rb_define_method(cOBRTree.klass, "GetAtomIdx", VALUEFUNC(_wrap_OBRTree_GetAtomIdx), -1);
  rb_define_method(cOBRTree.klass, "PathToRoot", VALUEFUNC(_wrap_OBRTree_PathToRoot), -1);
  cOBRTree.mark = 0;
  cOBRTree.destroy = (void (*)(void *)) free_OpenBabel_OBRTree;
  cOBRTree.trackObjects = 0;
  
  cOBSmartsPattern.klass = rb_define_class_under(mOpenbabel, "OBSmartsPattern", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSmartsPattern, (void *) &cOBSmartsPattern);
  rb_define_alloc_func(cOBSmartsPattern.klass, _wrap_OBSmartsPattern_allocate);
  rb_define_method(cOBSmartsPattern.klass, "initialize", VALUEFUNC(_wrap_new_OBSmartsPattern), -1);
  rb_define_method(cOBSmartsPattern.klass, "Init", VALUEFUNC(_wrap_OBSmartsPattern_Init), -1);
  rb_define_method(cOBSmartsPattern.klass, "GetSMARTS", VALUEFUNC(_wrap_OBSmartsPattern_GetSMARTS), -1);
  rb_define_method(cOBSmartsPattern.klass, "Empty", VALUEFUNC(_wrap_OBSmartsPattern_Empty), -1);
  rb_define_method(cOBSmartsPattern.klass, "IsValid", VALUEFUNC(_wrap_OBSmartsPattern_IsValid), -1);
  rb_define_method(cOBSmartsPattern.klass, "NumAtoms", VALUEFUNC(_wrap_OBSmartsPattern_NumAtoms), -1);
  rb_define_method(cOBSmartsPattern.klass, "NumBonds", VALUEFUNC(_wrap_OBSmartsPattern_NumBonds), -1);
  rb_define_method(cOBSmartsPattern.klass, "GetBond", VALUEFUNC(_wrap_OBSmartsPattern_GetBond), -1);
  rb_define_method(cOBSmartsPattern.klass, "GetAtomicNum", VALUEFUNC(_wrap_OBSmartsPattern_GetAtomicNum), -1);
  rb_define_method(cOBSmartsPattern.klass, "GetCharge", VALUEFUNC(_wrap_OBSmartsPattern_GetCharge), -1);
  rb_define_method(cOBSmartsPattern.klass, "GetVectorBinding", VALUEFUNC(_wrap_OBSmartsPattern_GetVectorBinding), -1);
  rb_define_method(cOBSmartsPattern.klass, "Match", VALUEFUNC(_wrap_OBSmartsPattern_Match), -1);
  rb_define_method(cOBSmartsPattern.klass, "RestrictedMatch", VALUEFUNC(_wrap_OBSmartsPattern_RestrictedMatch), -1);
  rb_define_method(cOBSmartsPattern.klass, "NumMatches", VALUEFUNC(_wrap_OBSmartsPattern_NumMatches), -1);
  rb_define_method(cOBSmartsPattern.klass, "GetMapList", VALUEFUNC(_wrap_OBSmartsPattern_GetMapList), -1);
  rb_define_method(cOBSmartsPattern.klass, "BeginMList", VALUEFUNC(_wrap_OBSmartsPattern_BeginMList), -1);
  rb_define_method(cOBSmartsPattern.klass, "EndMList", VALUEFUNC(_wrap_OBSmartsPattern_EndMList), -1);
  rb_define_method(cOBSmartsPattern.klass, "GetUMapList", VALUEFUNC(_wrap_OBSmartsPattern_GetUMapList), -1);
  rb_define_method(cOBSmartsPattern.klass, "WriteMapList", VALUEFUNC(_wrap_OBSmartsPattern_WriteMapList), -1);
  cOBSmartsPattern.mark = 0;
  cOBSmartsPattern.destroy = (void (*)(void *)) free_OpenBabel_OBSmartsPattern;
  cOBSmartsPattern.trackObjects = 0;
  
  cOBSSMatch.klass = rb_define_class_under(mOpenbabel, "OBSSMatch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSSMatch, (void *) &cOBSSMatch);
  rb_define_alloc_func(cOBSSMatch.klass, _wrap_OBSSMatch_allocate);
  rb_define_method(cOBSSMatch.klass, "initialize", VALUEFUNC(_wrap_new_OBSSMatch), -1);
  rb_define_method(cOBSSMatch.klass, "Match", VALUEFUNC(_wrap_OBSSMatch_Match), -1);
  cOBSSMatch.mark = 0;
  cOBSSMatch.destroy = (void (*)(void *)) free_OpenBabel_OBSSMatch;
  cOBSSMatch.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "SmartsLexReplace", VALUEFUNC(_wrap_SmartsLexReplace), -1);
  
  cOBFingerprint.klass = rb_define_class_under(mOpenbabel, "OBFingerprint", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFingerprint, (void *) &cOBFingerprint);
  rb_undef_alloc_func(cOBFingerprint.klass);
  rb_define_singleton_method(cOBFingerprint.klass, "Iter", VALUEFUNC(_wrap_OBFingerprint_Iter), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "FindDefaultType", VALUEFUNC(_wrap_OBFingerprint_FindDefaultType), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "FindType", VALUEFUNC(_wrap_OBFingerprint_FindType), -1);
  rb_define_method(cOBFingerprint.klass, "SetBit", VALUEFUNC(_wrap_OBFingerprint_SetBit), -1);
  rb_define_method(cOBFingerprint.klass, "Fold", VALUEFUNC(_wrap_OBFingerprint_Fold), -1);
  rb_define_method(cOBFingerprint.klass, "GetFingerprint", VALUEFUNC(_wrap_OBFingerprint_GetFingerprint), -1);
  rb_define_method(cOBFingerprint.klass, "Description", VALUEFUNC(_wrap_OBFingerprint_Description), -1);
  rb_define_const(cOBFingerprint.klass, "FPT_UNIQUEBITS", SWIG_From_int(static_cast< int >(OpenBabel::OBFingerprint::FPT_UNIQUEBITS)));
  rb_define_method(cOBFingerprint.klass, "Flags", VALUEFUNC(_wrap_OBFingerprint_Flags), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "Tanimoto", VALUEFUNC(_wrap_OBFingerprint_Tanimoto), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "Getbitsperint", VALUEFUNC(_wrap_OBFingerprint_Getbitsperint), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "FindFingerprint", VALUEFUNC(_wrap_OBFingerprint_FindFingerprint), -1);
  cOBFingerprint.mark = 0;
  cOBFingerprint.destroy = (void (*)(void *)) free_OpenBabel_OBFingerprint;
  cOBFingerprint.trackObjects = 0;
  
  cFptIndexHeader.klass = rb_define_class_under(mOpenbabel, "FptIndexHeader", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FptIndexHeader, (void *) &cFptIndexHeader);
  rb_define_alloc_func(cFptIndexHeader.klass, _wrap_FptIndexHeader_allocate);
  rb_define_method(cFptIndexHeader.klass, "initialize", VALUEFUNC(_wrap_new_FptIndexHeader), -1);
  rb_define_method(cFptIndexHeader.klass, "headerlength=", VALUEFUNC(_wrap_FptIndexHeader_headerlength_set), -1);
  rb_define_method(cFptIndexHeader.klass, "headerlength", VALUEFUNC(_wrap_FptIndexHeader_headerlength_get), -1);
  rb_define_method(cFptIndexHeader.klass, "nEntries=", VALUEFUNC(_wrap_FptIndexHeader_nEntries_set), -1);
  rb_define_method(cFptIndexHeader.klass, "nEntries", VALUEFUNC(_wrap_FptIndexHeader_nEntries_get), -1);
  rb_define_method(cFptIndexHeader.klass, "words=", VALUEFUNC(_wrap_FptIndexHeader_words_set), -1);
  rb_define_method(cFptIndexHeader.klass, "words", VALUEFUNC(_wrap_FptIndexHeader_words_get), -1);
  rb_define_method(cFptIndexHeader.klass, "fpid=", VALUEFUNC(_wrap_FptIndexHeader_fpid_set), -1);
  rb_define_method(cFptIndexHeader.klass, "fpid", VALUEFUNC(_wrap_FptIndexHeader_fpid_get), -1);
  rb_define_method(cFptIndexHeader.klass, "datafilename=", VALUEFUNC(_wrap_FptIndexHeader_datafilename_set), -1);
  rb_define_method(cFptIndexHeader.klass, "datafilename", VALUEFUNC(_wrap_FptIndexHeader_datafilename_get), -1);
  cFptIndexHeader.mark = 0;
  cFptIndexHeader.destroy = (void (*)(void *)) free_OpenBabel_FptIndexHeader;
  cFptIndexHeader.trackObjects = 0;
  
  cFptIndex.klass = rb_define_class_under(mOpenbabel, "FptIndex", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FptIndex, (void *) &cFptIndex);
  rb_define_alloc_func(cFptIndex.klass, _wrap_FptIndex_allocate);
  rb_define_method(cFptIndex.klass, "initialize", VALUEFUNC(_wrap_new_FptIndex), -1);
  rb_define_method(cFptIndex.klass, "header=", VALUEFUNC(_wrap_FptIndex_header_set), -1);
  rb_define_method(cFptIndex.klass, "header", VALUEFUNC(_wrap_FptIndex_header_get), -1);
  rb_define_method(cFptIndex.klass, "fptdata=", VALUEFUNC(_wrap_FptIndex_fptdata_set), -1);
  rb_define_method(cFptIndex.klass, "fptdata", VALUEFUNC(_wrap_FptIndex_fptdata_get), -1);
  rb_define_method(cFptIndex.klass, "seekdata=", VALUEFUNC(_wrap_FptIndex_seekdata_set), -1);
  rb_define_method(cFptIndex.klass, "seekdata", VALUEFUNC(_wrap_FptIndex_seekdata_get), -1);
  rb_define_method(cFptIndex.klass, "Read", VALUEFUNC(_wrap_FptIndex_Read), -1);
  rb_define_method(cFptIndex.klass, "CheckFP", VALUEFUNC(_wrap_FptIndex_CheckFP), -1);
  cFptIndex.mark = 0;
  cFptIndex.destroy = (void (*)(void *)) free_OpenBabel_FptIndex;
  cFptIndex.trackObjects = 0;
  
  cFastSearch.klass = rb_define_class_under(mOpenbabel, "FastSearch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FastSearch, (void *) &cFastSearch);
  rb_define_alloc_func(cFastSearch.klass, _wrap_FastSearch_allocate);
  rb_define_method(cFastSearch.klass, "initialize", VALUEFUNC(_wrap_new_FastSearch), -1);
  rb_define_method(cFastSearch.klass, "ReadIndexFile", VALUEFUNC(_wrap_FastSearch_ReadIndexFile), -1);
  rb_define_method(cFastSearch.klass, "ReadIndex", VALUEFUNC(_wrap_FastSearch_ReadIndex), -1);
  rb_define_method(cFastSearch.klass, "Find", VALUEFUNC(_wrap_FastSearch_Find), -1);
  rb_define_method(cFastSearch.klass, "FindMatch", VALUEFUNC(_wrap_FastSearch_FindMatch), -1);
  rb_define_method(cFastSearch.klass, "FindSimilar", VALUEFUNC(_wrap_FastSearch_FindSimilar), -1);
  rb_define_method(cFastSearch.klass, "GetFingerprint", VALUEFUNC(_wrap_FastSearch_GetFingerprint), -1);
  rb_define_method(cFastSearch.klass, "GetIndexHeader", VALUEFUNC(_wrap_FastSearch_GetIndexHeader), -1);
  cFastSearch.mark = 0;
  cFastSearch.destroy = (void (*)(void *)) free_OpenBabel_FastSearch;
  cFastSearch.trackObjects = 0;
  
  cFastSearchIndexer.klass = rb_define_class_under(mOpenbabel, "FastSearchIndexer", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FastSearchIndexer, (void *) &cFastSearchIndexer);
  rb_define_alloc_func(cFastSearchIndexer.klass, _wrap_FastSearchIndexer_allocate);
  rb_define_method(cFastSearchIndexer.klass, "initialize", VALUEFUNC(_wrap_new_FastSearchIndexer), -1);
  rb_define_method(cFastSearchIndexer.klass, "Add", VALUEFUNC(_wrap_FastSearchIndexer_Add), -1);
  cFastSearchIndexer.mark = 0;
  cFastSearchIndexer.destroy = (void (*)(void *)) free_OpenBabel_FastSearchIndexer;
  cFastSearchIndexer.trackObjects = 0;
  rb_define_const(mOpenbabel, "OBFF_LOGLVL_NONE", SWIG_From_int(static_cast< int >(0)));
  rb_define_const(mOpenbabel, "OBFF_LOGLVL_LOW", SWIG_From_int(static_cast< int >(1)));
  rb_define_const(mOpenbabel, "OBFF_LOGLVL_MEDIUM", SWIG_From_int(static_cast< int >(2)));
  rb_define_const(mOpenbabel, "OBFF_LOGLVL_HIGH", SWIG_From_int(static_cast< int >(3)));
  rb_define_const(mOpenbabel, "OBFF_ENERGY", SWIG_From_int(static_cast< int >((1 << 0))));
  rb_define_const(mOpenbabel, "OBFF_EBOND", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "OBFF_EANGLE", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "OBFF_ESTRBND", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "OBFF_ETORSION", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "OBFF_EOOP", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "OBFF_EVDW", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "OBFF_EELECTROSTATIC", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenbabel, "OBFF_NUMERICAL_GRADIENT", SWIG_From_int(static_cast< int >((1 << 0))));
  rb_define_const(mOpenbabel, "OBFF_ANALYTICAL_GRADIENT", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "KCAL_TO_KJ", SWIG_From_double(static_cast< double >(4.1868)));
  
  cOBFFParameter.klass = rb_define_class_under(mOpenbabel, "OBFFParameter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFParameter, (void *) &cOBFFParameter);
  rb_define_alloc_func(cOBFFParameter.klass, _wrap_OBFFParameter_allocate);
  rb_define_method(cOBFFParameter.klass, "initialize", VALUEFUNC(_wrap_new_OBFFParameter), -1);
  rb_define_method(cOBFFParameter.klass, "a=", VALUEFUNC(_wrap_OBFFParameter_a_set), -1);
  rb_define_method(cOBFFParameter.klass, "a", VALUEFUNC(_wrap_OBFFParameter_a_get), -1);
  rb_define_method(cOBFFParameter.klass, "b=", VALUEFUNC(_wrap_OBFFParameter_b_set), -1);
  rb_define_method(cOBFFParameter.klass, "b", VALUEFUNC(_wrap_OBFFParameter_b_get), -1);
  rb_define_method(cOBFFParameter.klass, "c=", VALUEFUNC(_wrap_OBFFParameter_c_set), -1);
  rb_define_method(cOBFFParameter.klass, "c", VALUEFUNC(_wrap_OBFFParameter_c_get), -1);
  rb_define_method(cOBFFParameter.klass, "d=", VALUEFUNC(_wrap_OBFFParameter_d_set), -1);
  rb_define_method(cOBFFParameter.klass, "d", VALUEFUNC(_wrap_OBFFParameter_d_get), -1);
  rb_define_method(cOBFFParameter.klass, "_a=", VALUEFUNC(_wrap_OBFFParameter__a_set), -1);
  rb_define_method(cOBFFParameter.klass, "_a", VALUEFUNC(_wrap_OBFFParameter__a_get), -1);
  rb_define_method(cOBFFParameter.klass, "_b=", VALUEFUNC(_wrap_OBFFParameter__b_set), -1);
  rb_define_method(cOBFFParameter.klass, "_b", VALUEFUNC(_wrap_OBFFParameter__b_get), -1);
  rb_define_method(cOBFFParameter.klass, "_c=", VALUEFUNC(_wrap_OBFFParameter__c_set), -1);
  rb_define_method(cOBFFParameter.klass, "_c", VALUEFUNC(_wrap_OBFFParameter__c_get), -1);
  rb_define_method(cOBFFParameter.klass, "_d=", VALUEFUNC(_wrap_OBFFParameter__d_set), -1);
  rb_define_method(cOBFFParameter.klass, "_d", VALUEFUNC(_wrap_OBFFParameter__d_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar1=", VALUEFUNC(_wrap_OBFFParameter_ipar1_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar1", VALUEFUNC(_wrap_OBFFParameter_ipar1_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar2=", VALUEFUNC(_wrap_OBFFParameter_ipar2_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar2", VALUEFUNC(_wrap_OBFFParameter_ipar2_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar3=", VALUEFUNC(_wrap_OBFFParameter_ipar3_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar3", VALUEFUNC(_wrap_OBFFParameter_ipar3_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar4=", VALUEFUNC(_wrap_OBFFParameter_ipar4_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar4", VALUEFUNC(_wrap_OBFFParameter_ipar4_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar5=", VALUEFUNC(_wrap_OBFFParameter_ipar5_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar5", VALUEFUNC(_wrap_OBFFParameter_ipar5_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar1=", VALUEFUNC(_wrap_OBFFParameter_dpar1_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar1", VALUEFUNC(_wrap_OBFFParameter_dpar1_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar2=", VALUEFUNC(_wrap_OBFFParameter_dpar2_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar2", VALUEFUNC(_wrap_OBFFParameter_dpar2_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar3=", VALUEFUNC(_wrap_OBFFParameter_dpar3_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar3", VALUEFUNC(_wrap_OBFFParameter_dpar3_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar4=", VALUEFUNC(_wrap_OBFFParameter_dpar4_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar4", VALUEFUNC(_wrap_OBFFParameter_dpar4_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar5=", VALUEFUNC(_wrap_OBFFParameter_dpar5_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar5", VALUEFUNC(_wrap_OBFFParameter_dpar5_get), -1);
  rb_define_method(cOBFFParameter.klass, "clear", VALUEFUNC(_wrap_OBFFParameter_clear), -1);
  cOBFFParameter.mark = 0;
  cOBFFParameter.destroy = (void (*)(void *)) free_OpenBabel_OBFFParameter;
  cOBFFParameter.trackObjects = 0;
  
  cOBFFCalculation.klass = rb_define_class_under(mOpenbabel, "OBFFCalculation", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFCalculation, (void *) &cOBFFCalculation);
  rb_define_alloc_func(cOBFFCalculation.klass, _wrap_OBFFCalculation_allocate);
  rb_define_method(cOBFFCalculation.klass, "initialize", VALUEFUNC(_wrap_new_OBFFCalculation), -1);
  rb_define_method(cOBFFCalculation.klass, "energy=", VALUEFUNC(_wrap_OBFFCalculation_energy_set), -1);
  rb_define_method(cOBFFCalculation.klass, "energy", VALUEFUNC(_wrap_OBFFCalculation_energy_get), -1);
  rb_define_method(cOBFFCalculation.klass, "grada=", VALUEFUNC(_wrap_OBFFCalculation_grada_set), -1);
  rb_define_method(cOBFFCalculation.klass, "grada", VALUEFUNC(_wrap_OBFFCalculation_grada_get), -1);
  rb_define_method(cOBFFCalculation.klass, "gradb=", VALUEFUNC(_wrap_OBFFCalculation_gradb_set), -1);
  rb_define_method(cOBFFCalculation.klass, "gradb", VALUEFUNC(_wrap_OBFFCalculation_gradb_get), -1);
  rb_define_method(cOBFFCalculation.klass, "gradc=", VALUEFUNC(_wrap_OBFFCalculation_gradc_set), -1);
  rb_define_method(cOBFFCalculation.klass, "gradc", VALUEFUNC(_wrap_OBFFCalculation_gradc_get), -1);
  rb_define_method(cOBFFCalculation.klass, "gradd=", VALUEFUNC(_wrap_OBFFCalculation_gradd_set), -1);
  rb_define_method(cOBFFCalculation.klass, "gradd", VALUEFUNC(_wrap_OBFFCalculation_gradd_get), -1);
  rb_define_method(cOBFFCalculation.klass, "a=", VALUEFUNC(_wrap_OBFFCalculation_a_set), -1);
  rb_define_method(cOBFFCalculation.klass, "a", VALUEFUNC(_wrap_OBFFCalculation_a_get), -1);
  rb_define_method(cOBFFCalculation.klass, "b=", VALUEFUNC(_wrap_OBFFCalculation_b_set), -1);
  rb_define_method(cOBFFCalculation.klass, "b", VALUEFUNC(_wrap_OBFFCalculation_b_get), -1);
  rb_define_method(cOBFFCalculation.klass, "c=", VALUEFUNC(_wrap_OBFFCalculation_c_set), -1);
  rb_define_method(cOBFFCalculation.klass, "c", VALUEFUNC(_wrap_OBFFCalculation_c_get), -1);
  rb_define_method(cOBFFCalculation.klass, "d=", VALUEFUNC(_wrap_OBFFCalculation_d_set), -1);
  rb_define_method(cOBFFCalculation.klass, "d", VALUEFUNC(_wrap_OBFFCalculation_d_get), -1);
  rb_define_method(cOBFFCalculation.klass, "Compute", VALUEFUNC(_wrap_OBFFCalculation_Compute), -1);
  rb_define_method(cOBFFCalculation.klass, "GetEnergy", VALUEFUNC(_wrap_OBFFCalculation_GetEnergy), -1);
  rb_define_method(cOBFFCalculation.klass, "GetGradient", VALUEFUNC(_wrap_OBFFCalculation_GetGradient), -1);
  cOBFFCalculation.mark = 0;
  cOBFFCalculation.destroy = (void (*)(void *)) free_OpenBabel_OBFFCalculation;
  cOBFFCalculation.trackObjects = 0;
  
  cOBForceField.klass = rb_define_class_under(mOpenbabel, "OBForceField", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBForceField, (void *) &cOBForceField);
  rb_define_alloc_func(cOBForceField.klass, _wrap_OBForceField_allocate);
  rb_define_method(cOBForceField.klass, "initialize", VALUEFUNC(_wrap_new_OBForceField), -1);
  rb_define_singleton_method(cOBForceField.klass, "Iter", VALUEFUNC(_wrap_OBForceField_Iter), -1);
  rb_define_singleton_method(cOBForceField.klass, "FindDefaultType", VALUEFUNC(_wrap_OBForceField_FindDefaultType), -1);
  rb_define_singleton_method(cOBForceField.klass, "FindType", VALUEFUNC(_wrap_OBForceField_FindType), -1);
  rb_define_singleton_method(cOBForceField.klass, "FindForceField", VALUEFUNC(_wrap_OBForceField_FindForceField), -1);
  rb_define_method(cOBForceField.klass, "GetUnit", VALUEFUNC(_wrap_OBForceField_GetUnit), -1);
  rb_define_method(cOBForceField.klass, "Setup", VALUEFUNC(_wrap_OBForceField_Setup), -1);
  rb_define_method(cOBForceField.klass, "UpdateCoordinates", VALUEFUNC(_wrap_OBForceField_UpdateCoordinates), -1);
  rb_define_method(cOBForceField.klass, "UpdateConformers", VALUEFUNC(_wrap_OBForceField_UpdateConformers), -1);
  rb_define_method(cOBForceField.klass, "OBFFLog", VALUEFUNC(_wrap_OBForceField_OBFFLog), -1);
  rb_define_method(cOBForceField.klass, "Energy", VALUEFUNC(_wrap_OBForceField_Energy), -1);
  rb_define_method(cOBForceField.klass, "E_Bond", VALUEFUNC(_wrap_OBForceField_E_Bond), -1);
  rb_define_method(cOBForceField.klass, "E_Angle", VALUEFUNC(_wrap_OBForceField_E_Angle), -1);
  rb_define_method(cOBForceField.klass, "E_StrBnd", VALUEFUNC(_wrap_OBForceField_E_StrBnd), -1);
  rb_define_method(cOBForceField.klass, "E_Torsion", VALUEFUNC(_wrap_OBForceField_E_Torsion), -1);
  rb_define_method(cOBForceField.klass, "E_OOP", VALUEFUNC(_wrap_OBForceField_E_OOP), -1);
  rb_define_method(cOBForceField.klass, "E_VDW", VALUEFUNC(_wrap_OBForceField_E_VDW), -1);
  rb_define_method(cOBForceField.klass, "E_Electrostatic", VALUEFUNC(_wrap_OBForceField_E_Electrostatic), -1);
  rb_define_method(cOBForceField.klass, "SetLogFile", VALUEFUNC(_wrap_OBForceField_SetLogFile), -1);
  rb_define_method(cOBForceField.klass, "SetLogLevel", VALUEFUNC(_wrap_OBForceField_SetLogLevel), -1);
  rb_define_method(cOBForceField.klass, "GetLogLevel", VALUEFUNC(_wrap_OBForceField_GetLogLevel), -1);
  rb_define_method(cOBForceField.klass, "SystematicRotorSearch", VALUEFUNC(_wrap_OBForceField_SystematicRotorSearch), -1);
  rb_define_method(cOBForceField.klass, "LineSearch", VALUEFUNC(_wrap_OBForceField_LineSearch), -1);
  rb_define_method(cOBForceField.klass, "SteepestDescent", VALUEFUNC(_wrap_OBForceField_SteepestDescent), -1);
  rb_define_method(cOBForceField.klass, "SteepestDescentInitialize", VALUEFUNC(_wrap_OBForceField_SteepestDescentInitialize), -1);
  rb_define_method(cOBForceField.klass, "SteepestDescentTakeNSteps", VALUEFUNC(_wrap_OBForceField_SteepestDescentTakeNSteps), -1);
  rb_define_method(cOBForceField.klass, "ConjugateGradients", VALUEFUNC(_wrap_OBForceField_ConjugateGradients), -1);
  rb_define_method(cOBForceField.klass, "ConjugateGradientsInitialize", VALUEFUNC(_wrap_OBForceField_ConjugateGradientsInitialize), -1);
  rb_define_method(cOBForceField.klass, "ConjugateGradientsTakeNSteps", VALUEFUNC(_wrap_OBForceField_ConjugateGradientsTakeNSteps), -1);
  rb_define_method(cOBForceField.klass, "Validate", VALUEFUNC(_wrap_OBForceField_Validate), -1);
  rb_define_method(cOBForceField.klass, "ValidateGradients", VALUEFUNC(_wrap_OBForceField_ValidateGradients), -1);
  rb_define_method(cOBForceField.klass, "ValidateGradientError", VALUEFUNC(_wrap_OBForceField_ValidateGradientError), -1);
  rb_define_singleton_method(cOBForceField.klass, "VectorLengthDerivative", VALUEFUNC(_wrap_OBForceField_VectorLengthDerivative), -1);
  rb_define_singleton_method(cOBForceField.klass, "VectorAngleDerivative", VALUEFUNC(_wrap_OBForceField_VectorAngleDerivative), -1);
  rb_define_singleton_method(cOBForceField.klass, "VectorTorsionDerivative", VALUEFUNC(_wrap_OBForceField_VectorTorsionDerivative), -1);
  rb_define_method(cOBForceField.klass, "kludge", VALUEFUNC(_wrap_OBForceField_kludge), -1);
  cOBForceField.mark = 0;
  cOBForceField.destroy = (void (*)(void *)) free_OpenBabel_OBForceField;
  cOBForceField.trackObjects = 0;
  
  cOBMolAtomIter.klass = rb_define_class_under(mOpenbabel, "OBMolAtomIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAtomIter, (void *) &cOBMolAtomIter);
  rb_define_alloc_func(cOBMolAtomIter.klass, _wrap_OBMolAtomIter_allocate);
  rb_define_method(cOBMolAtomIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAtomIter), -1);
  rb_define_method(cOBMolAtomIter.klass, "good", VALUEFUNC(_wrap_OBMolAtomIter_good), -1);
  rb_define_method(cOBMolAtomIter.klass, "inc", VALUEFUNC(_wrap_OBMolAtomIter_inc), -1);
  rb_define_method(cOBMolAtomIter.klass, "deref", VALUEFUNC(_wrap_OBMolAtomIter_deref), -1);
  rb_define_method(cOBMolAtomIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAtomIter___ref__), -1);
  rb_define_method(cOBMolAtomIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolAtomIter_Visit_set), -1);
  rb_define_method(cOBMolAtomIter.klass, "Visit", VALUEFUNC(_wrap_OBMolAtomIter_Visit_get), -1);
  rb_define_method(cOBMolAtomIter.klass, "Clear", VALUEFUNC(_wrap_OBMolAtomIter_Clear), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetIdx", VALUEFUNC(_wrap_OBMolAtomIter_SetIdx), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetHyb", VALUEFUNC(_wrap_OBMolAtomIter_SetHyb), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetAtomicNum", VALUEFUNC(_wrap_OBMolAtomIter_SetAtomicNum), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetIsotope", VALUEFUNC(_wrap_OBMolAtomIter_SetIsotope), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetImplicitValence", VALUEFUNC(_wrap_OBMolAtomIter_SetImplicitValence), -1);
  rb_define_method(cOBMolAtomIter.klass, "IncrementImplicitValence", VALUEFUNC(_wrap_OBMolAtomIter_IncrementImplicitValence), -1);
  rb_define_method(cOBMolAtomIter.klass, "DecrementImplicitValence", VALUEFUNC(_wrap_OBMolAtomIter_DecrementImplicitValence), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetFormalCharge", VALUEFUNC(_wrap_OBMolAtomIter_SetFormalCharge), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetSpinMultiplicity", VALUEFUNC(_wrap_OBMolAtomIter_SetSpinMultiplicity), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetType", VALUEFUNC(_wrap_OBMolAtomIter_SetType), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetPartialCharge", VALUEFUNC(_wrap_OBMolAtomIter_SetPartialCharge), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetVector", VALUEFUNC(_wrap_OBMolAtomIter_SetVector), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetCoordPtr", VALUEFUNC(_wrap_OBMolAtomIter_SetCoordPtr), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetResidue", VALUEFUNC(_wrap_OBMolAtomIter_SetResidue), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetParent", VALUEFUNC(_wrap_OBMolAtomIter_SetParent), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetAromatic", VALUEFUNC(_wrap_OBMolAtomIter_SetAromatic), -1);
  rb_define_method(cOBMolAtomIter.klass, "UnsetAromatic", VALUEFUNC(_wrap_OBMolAtomIter_UnsetAromatic), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetClockwiseStereo", VALUEFUNC(_wrap_OBMolAtomIter_SetClockwiseStereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetAntiClockwiseStereo", VALUEFUNC(_wrap_OBMolAtomIter_SetAntiClockwiseStereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetPositiveStereo", VALUEFUNC(_wrap_OBMolAtomIter_SetPositiveStereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetNegativeStereo", VALUEFUNC(_wrap_OBMolAtomIter_SetNegativeStereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "UnsetStereo", VALUEFUNC(_wrap_OBMolAtomIter_UnsetStereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetInRing", VALUEFUNC(_wrap_OBMolAtomIter_SetInRing), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetChiral", VALUEFUNC(_wrap_OBMolAtomIter_SetChiral), -1);
  rb_define_method(cOBMolAtomIter.klass, "ClearCoordPtr", VALUEFUNC(_wrap_OBMolAtomIter_ClearCoordPtr), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetFormalCharge", VALUEFUNC(_wrap_OBMolAtomIter_GetFormalCharge), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetAtomicNum", VALUEFUNC(_wrap_OBMolAtomIter_GetAtomicNum), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetIsotope", VALUEFUNC(_wrap_OBMolAtomIter_GetIsotope), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetSpinMultiplicity", VALUEFUNC(_wrap_OBMolAtomIter_GetSpinMultiplicity), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetAtomicMass", VALUEFUNC(_wrap_OBMolAtomIter_GetAtomicMass), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetExactMass", VALUEFUNC(_wrap_OBMolAtomIter_GetExactMass), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetIdx", VALUEFUNC(_wrap_OBMolAtomIter_GetIdx), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetCoordinateIdx", VALUEFUNC(_wrap_OBMolAtomIter_GetCoordinateIdx), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetCIdx", VALUEFUNC(_wrap_OBMolAtomIter_GetCIdx), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetValence", VALUEFUNC(_wrap_OBMolAtomIter_GetValence), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetHyb", VALUEFUNC(_wrap_OBMolAtomIter_GetHyb), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetImplicitValence", VALUEFUNC(_wrap_OBMolAtomIter_GetImplicitValence), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetHvyValence", VALUEFUNC(_wrap_OBMolAtomIter_GetHvyValence), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetHeteroValence", VALUEFUNC(_wrap_OBMolAtomIter_GetHeteroValence), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetType", VALUEFUNC(_wrap_OBMolAtomIter_GetType), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetX", VALUEFUNC(_wrap_OBMolAtomIter_GetX), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetY", VALUEFUNC(_wrap_OBMolAtomIter_GetY), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetZ", VALUEFUNC(_wrap_OBMolAtomIter_GetZ), -1);
  rb_define_method(cOBMolAtomIter.klass, "x", VALUEFUNC(_wrap_OBMolAtomIter_x), -1);
  rb_define_method(cOBMolAtomIter.klass, "y", VALUEFUNC(_wrap_OBMolAtomIter_y), -1);
  rb_define_method(cOBMolAtomIter.klass, "z", VALUEFUNC(_wrap_OBMolAtomIter_z), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetCoordinate", VALUEFUNC(_wrap_OBMolAtomIter_GetCoordinate), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetVector", VALUEFUNC(_wrap_OBMolAtomIter_GetVector), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetPartialCharge", VALUEFUNC(_wrap_OBMolAtomIter_GetPartialCharge), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetResidue", VALUEFUNC(_wrap_OBMolAtomIter_GetResidue), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetParent", VALUEFUNC(_wrap_OBMolAtomIter_GetParent), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetNewBondVector", VALUEFUNC(_wrap_OBMolAtomIter_GetNewBondVector), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetBond", VALUEFUNC(_wrap_OBMolAtomIter_GetBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetNextAtom", VALUEFUNC(_wrap_OBMolAtomIter_GetNextAtom), -1);
  rb_define_method(cOBMolAtomIter.klass, "BeginBonds", VALUEFUNC(_wrap_OBMolAtomIter_BeginBonds), -1);
  rb_define_method(cOBMolAtomIter.klass, "EndBonds", VALUEFUNC(_wrap_OBMolAtomIter_EndBonds), -1);
  rb_define_method(cOBMolAtomIter.klass, "BeginBond", VALUEFUNC(_wrap_OBMolAtomIter_BeginBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "NextBond", VALUEFUNC(_wrap_OBMolAtomIter_NextBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "BeginNbrAtom", VALUEFUNC(_wrap_OBMolAtomIter_BeginNbrAtom), -1);
  rb_define_method(cOBMolAtomIter.klass, "NextNbrAtom", VALUEFUNC(_wrap_OBMolAtomIter_NextNbrAtom), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetDistance", VALUEFUNC(_wrap_OBMolAtomIter_GetDistance), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetAngle", VALUEFUNC(_wrap_OBMolAtomIter_GetAngle), -1);
  rb_define_method(cOBMolAtomIter.klass, "NewResidue", VALUEFUNC(_wrap_OBMolAtomIter_NewResidue), -1);
  rb_define_method(cOBMolAtomIter.klass, "AddResidue", VALUEFUNC(_wrap_OBMolAtomIter_AddResidue), -1);
  rb_define_method(cOBMolAtomIter.klass, "DeleteResidue", VALUEFUNC(_wrap_OBMolAtomIter_DeleteResidue), -1);
  rb_define_method(cOBMolAtomIter.klass, "AddBond", VALUEFUNC(_wrap_OBMolAtomIter_AddBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "InsertBond", VALUEFUNC(_wrap_OBMolAtomIter_InsertBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "DeleteBond", VALUEFUNC(_wrap_OBMolAtomIter_DeleteBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "ClearBond", VALUEFUNC(_wrap_OBMolAtomIter_ClearBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "HtoMethyl", VALUEFUNC(_wrap_OBMolAtomIter_HtoMethyl), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetHybAndGeom", VALUEFUNC(_wrap_OBMolAtomIter_SetHybAndGeom), -1);
  rb_define_method(cOBMolAtomIter.klass, "ForceNoH", VALUEFUNC(_wrap_OBMolAtomIter_ForceNoH), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasNoHForced", VALUEFUNC(_wrap_OBMolAtomIter_HasNoHForced), -1);
  rb_define_method(cOBMolAtomIter.klass, "CountFreeOxygens", VALUEFUNC(_wrap_OBMolAtomIter_CountFreeOxygens), -1);
  rb_define_method(cOBMolAtomIter.klass, "ImplicitHydrogenCount", VALUEFUNC(_wrap_OBMolAtomIter_ImplicitHydrogenCount), -1);
  rb_define_method(cOBMolAtomIter.klass, "ExplicitHydrogenCount", VALUEFUNC(_wrap_OBMolAtomIter_ExplicitHydrogenCount), -1);
  rb_define_method(cOBMolAtomIter.klass, "MemberOfRingCount", VALUEFUNC(_wrap_OBMolAtomIter_MemberOfRingCount), -1);
  rb_define_method(cOBMolAtomIter.klass, "MemberOfRingSize", VALUEFUNC(_wrap_OBMolAtomIter_MemberOfRingSize), -1);
  rb_define_method(cOBMolAtomIter.klass, "CountRingBonds", VALUEFUNC(_wrap_OBMolAtomIter_CountRingBonds), -1);
  rb_define_method(cOBMolAtomIter.klass, "SmallestBondAngle", VALUEFUNC(_wrap_OBMolAtomIter_SmallestBondAngle), -1);
  rb_define_method(cOBMolAtomIter.klass, "AverageBondAngle", VALUEFUNC(_wrap_OBMolAtomIter_AverageBondAngle), -1);
  rb_define_method(cOBMolAtomIter.klass, "BOSum", VALUEFUNC(_wrap_OBMolAtomIter_BOSum), -1);
  rb_define_method(cOBMolAtomIter.klass, "KBOSum", VALUEFUNC(_wrap_OBMolAtomIter_KBOSum), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasResidue", VALUEFUNC(_wrap_OBMolAtomIter_HasResidue), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsHydrogen", VALUEFUNC(_wrap_OBMolAtomIter_IsHydrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsCarbon", VALUEFUNC(_wrap_OBMolAtomIter_IsCarbon), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsNitrogen", VALUEFUNC(_wrap_OBMolAtomIter_IsNitrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsOxygen", VALUEFUNC(_wrap_OBMolAtomIter_IsOxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsSulfur", VALUEFUNC(_wrap_OBMolAtomIter_IsSulfur), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsPhosphorus", VALUEFUNC(_wrap_OBMolAtomIter_IsPhosphorus), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsAromatic", VALUEFUNC(_wrap_OBMolAtomIter_IsAromatic), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsInRing", VALUEFUNC(_wrap_OBMolAtomIter_IsInRing), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsInRingSize", VALUEFUNC(_wrap_OBMolAtomIter_IsInRingSize), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsHeteroatom", VALUEFUNC(_wrap_OBMolAtomIter_IsHeteroatom), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsNotCorH", VALUEFUNC(_wrap_OBMolAtomIter_IsNotCorH), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsConnected", VALUEFUNC(_wrap_OBMolAtomIter_IsConnected), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsOneThree", VALUEFUNC(_wrap_OBMolAtomIter_IsOneThree), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsOneFour", VALUEFUNC(_wrap_OBMolAtomIter_IsOneFour), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsCarboxylOxygen", VALUEFUNC(_wrap_OBMolAtomIter_IsCarboxylOxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsPhosphateOxygen", VALUEFUNC(_wrap_OBMolAtomIter_IsPhosphateOxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsSulfateOxygen", VALUEFUNC(_wrap_OBMolAtomIter_IsSulfateOxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsNitroOxygen", VALUEFUNC(_wrap_OBMolAtomIter_IsNitroOxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsAmideNitrogen", VALUEFUNC(_wrap_OBMolAtomIter_IsAmideNitrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsPolarHydrogen", VALUEFUNC(_wrap_OBMolAtomIter_IsPolarHydrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsNonPolarHydrogen", VALUEFUNC(_wrap_OBMolAtomIter_IsNonPolarHydrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsAromaticNOxide", VALUEFUNC(_wrap_OBMolAtomIter_IsAromaticNOxide), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsChiral", VALUEFUNC(_wrap_OBMolAtomIter_IsChiral), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsAxial", VALUEFUNC(_wrap_OBMolAtomIter_IsAxial), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsClockwise", VALUEFUNC(_wrap_OBMolAtomIter_IsClockwise), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsAntiClockwise", VALUEFUNC(_wrap_OBMolAtomIter_IsAntiClockwise), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsPositiveStereo", VALUEFUNC(_wrap_OBMolAtomIter_IsPositiveStereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsNegativeStereo", VALUEFUNC(_wrap_OBMolAtomIter_IsNegativeStereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasChiralitySpecified", VALUEFUNC(_wrap_OBMolAtomIter_HasChiralitySpecified), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasChiralVolume", VALUEFUNC(_wrap_OBMolAtomIter_HasChiralVolume), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsHbondAcceptor", VALUEFUNC(_wrap_OBMolAtomIter_IsHbondAcceptor), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsHbondDonor", VALUEFUNC(_wrap_OBMolAtomIter_IsHbondDonor), -1);
  rb_define_method(cOBMolAtomIter.klass, "IsHbondDonorH", VALUEFUNC(_wrap_OBMolAtomIter_IsHbondDonorH), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasAlphaBetaUnsat", VALUEFUNC(_wrap_OBMolAtomIter_HasAlphaBetaUnsat), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasBondOfOrder", VALUEFUNC(_wrap_OBMolAtomIter_HasBondOfOrder), -1);
  rb_define_method(cOBMolAtomIter.klass, "CountBondsOfOrder", VALUEFUNC(_wrap_OBMolAtomIter_CountBondsOfOrder), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasNonSingleBond", VALUEFUNC(_wrap_OBMolAtomIter_HasNonSingleBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasSingleBond", VALUEFUNC(_wrap_OBMolAtomIter_HasSingleBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasDoubleBond", VALUEFUNC(_wrap_OBMolAtomIter_HasDoubleBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasAromaticBond", VALUEFUNC(_wrap_OBMolAtomIter_HasAromaticBond), -1);
  rb_define_method(cOBMolAtomIter.klass, "MatchesSMARTS", VALUEFUNC(_wrap_OBMolAtomIter_MatchesSMARTS), -1);
  rb_define_method(cOBMolAtomIter.klass, "DoTransformations", VALUEFUNC(_wrap_OBMolAtomIter_DoTransformations), -1);
  rb_define_method(cOBMolAtomIter.klass, "ClassDescription", VALUEFUNC(_wrap_OBMolAtomIter_ClassDescription), -1);
  rb_define_method(cOBMolAtomIter.klass, "HasData", VALUEFUNC(_wrap_OBMolAtomIter_HasData), -1);
  rb_define_method(cOBMolAtomIter.klass, "DeleteData", VALUEFUNC(_wrap_OBMolAtomIter_DeleteData), -1);
  rb_define_method(cOBMolAtomIter.klass, "SetData", VALUEFUNC(_wrap_OBMolAtomIter_SetData), -1);
  rb_define_method(cOBMolAtomIter.klass, "DataSize", VALUEFUNC(_wrap_OBMolAtomIter_DataSize), -1);
  rb_define_method(cOBMolAtomIter.klass, "GetData", VALUEFUNC(_wrap_OBMolAtomIter_GetData), -1);
  rb_define_method(cOBMolAtomIter.klass, "BeginData", VALUEFUNC(_wrap_OBMolAtomIter_BeginData), -1);
  rb_define_method(cOBMolAtomIter.klass, "EndData", VALUEFUNC(_wrap_OBMolAtomIter_EndData), -1);
  cOBMolAtomIter.mark = 0;
  cOBMolAtomIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAtomIter;
  cOBMolAtomIter.trackObjects = 0;
  
  cOBMolAtomDFSIter.klass = rb_define_class_under(mOpenbabel, "OBMolAtomDFSIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, (void *) &cOBMolAtomDFSIter);
  rb_define_alloc_func(cOBMolAtomDFSIter.klass, _wrap_OBMolAtomDFSIter_allocate);
  rb_define_method(cOBMolAtomDFSIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAtomDFSIter), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "good", VALUEFUNC(_wrap_OBMolAtomDFSIter_good), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "inc", VALUEFUNC(_wrap_OBMolAtomDFSIter_inc), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "deref", VALUEFUNC(_wrap_OBMolAtomDFSIter_deref), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAtomDFSIter___ref__), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "next", VALUEFUNC(_wrap_OBMolAtomDFSIter_next), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolAtomDFSIter_Visit_set), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "Visit", VALUEFUNC(_wrap_OBMolAtomDFSIter_Visit_get), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "Clear", VALUEFUNC(_wrap_OBMolAtomDFSIter_Clear), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetIdx", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetIdx), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetHyb", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetHyb), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetAtomicNum", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetAtomicNum), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetIsotope", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetIsotope), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetImplicitValence", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetImplicitValence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IncrementImplicitValence", VALUEFUNC(_wrap_OBMolAtomDFSIter_IncrementImplicitValence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "DecrementImplicitValence", VALUEFUNC(_wrap_OBMolAtomDFSIter_DecrementImplicitValence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetFormalCharge", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetFormalCharge), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetSpinMultiplicity", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetSpinMultiplicity), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetType", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetType), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetPartialCharge", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetPartialCharge), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetVector", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetVector), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetCoordPtr", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetCoordPtr), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetResidue", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetResidue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetParent", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetParent), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetAromatic", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetAromatic), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "UnsetAromatic", VALUEFUNC(_wrap_OBMolAtomDFSIter_UnsetAromatic), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetClockwiseStereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetClockwiseStereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetAntiClockwiseStereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetAntiClockwiseStereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetPositiveStereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetPositiveStereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetNegativeStereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetNegativeStereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "UnsetStereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_UnsetStereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetInRing", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetInRing), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetChiral", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetChiral), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "ClearCoordPtr", VALUEFUNC(_wrap_OBMolAtomDFSIter_ClearCoordPtr), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetFormalCharge", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetFormalCharge), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetAtomicNum", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetAtomicNum), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetIsotope", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetIsotope), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetSpinMultiplicity", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetSpinMultiplicity), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetAtomicMass", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetAtomicMass), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetExactMass", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetExactMass), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetIdx", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetIdx), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetCoordinateIdx", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetCoordinateIdx), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetCIdx", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetCIdx), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetValence", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetValence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetHyb", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetHyb), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetImplicitValence", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetImplicitValence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetHvyValence", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetHvyValence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetHeteroValence", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetHeteroValence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetType", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetType), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetX", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetX), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetY", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetY), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetZ", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetZ), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "x", VALUEFUNC(_wrap_OBMolAtomDFSIter_x), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "y", VALUEFUNC(_wrap_OBMolAtomDFSIter_y), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "z", VALUEFUNC(_wrap_OBMolAtomDFSIter_z), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetCoordinate", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetCoordinate), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetVector", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetVector), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetPartialCharge", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetPartialCharge), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetResidue", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetResidue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetParent", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetParent), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetNewBondVector", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetNewBondVector), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetNextAtom", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetNextAtom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "BeginBonds", VALUEFUNC(_wrap_OBMolAtomDFSIter_BeginBonds), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "EndBonds", VALUEFUNC(_wrap_OBMolAtomDFSIter_EndBonds), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "BeginBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_BeginBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "NextBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_NextBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "BeginNbrAtom", VALUEFUNC(_wrap_OBMolAtomDFSIter_BeginNbrAtom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "NextNbrAtom", VALUEFUNC(_wrap_OBMolAtomDFSIter_NextNbrAtom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetDistance", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetDistance), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetAngle", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetAngle), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "NewResidue", VALUEFUNC(_wrap_OBMolAtomDFSIter_NewResidue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "AddResidue", VALUEFUNC(_wrap_OBMolAtomDFSIter_AddResidue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "DeleteResidue", VALUEFUNC(_wrap_OBMolAtomDFSIter_DeleteResidue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "AddBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_AddBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "InsertBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_InsertBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "DeleteBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_DeleteBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "ClearBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_ClearBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HtoMethyl", VALUEFUNC(_wrap_OBMolAtomDFSIter_HtoMethyl), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetHybAndGeom", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetHybAndGeom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "ForceNoH", VALUEFUNC(_wrap_OBMolAtomDFSIter_ForceNoH), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasNoHForced", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasNoHForced), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "CountFreeOxygens", VALUEFUNC(_wrap_OBMolAtomDFSIter_CountFreeOxygens), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "ImplicitHydrogenCount", VALUEFUNC(_wrap_OBMolAtomDFSIter_ImplicitHydrogenCount), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "ExplicitHydrogenCount", VALUEFUNC(_wrap_OBMolAtomDFSIter_ExplicitHydrogenCount), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "MemberOfRingCount", VALUEFUNC(_wrap_OBMolAtomDFSIter_MemberOfRingCount), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "MemberOfRingSize", VALUEFUNC(_wrap_OBMolAtomDFSIter_MemberOfRingSize), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "CountRingBonds", VALUEFUNC(_wrap_OBMolAtomDFSIter_CountRingBonds), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SmallestBondAngle", VALUEFUNC(_wrap_OBMolAtomDFSIter_SmallestBondAngle), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "AverageBondAngle", VALUEFUNC(_wrap_OBMolAtomDFSIter_AverageBondAngle), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "BOSum", VALUEFUNC(_wrap_OBMolAtomDFSIter_BOSum), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "KBOSum", VALUEFUNC(_wrap_OBMolAtomDFSIter_KBOSum), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasResidue", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasResidue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsHydrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsHydrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsCarbon", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsCarbon), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsNitrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsNitrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsOxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsOxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsSulfur", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsSulfur), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsPhosphorus", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsPhosphorus), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsAromatic", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsAromatic), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsInRing", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsInRing), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsInRingSize", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsInRingSize), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsHeteroatom", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsHeteroatom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsNotCorH", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsNotCorH), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsConnected", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsConnected), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsOneThree", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsOneThree), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsOneFour", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsOneFour), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsCarboxylOxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsCarboxylOxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsPhosphateOxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsPhosphateOxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsSulfateOxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsSulfateOxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsNitroOxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsNitroOxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsAmideNitrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsAmideNitrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsPolarHydrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsPolarHydrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsNonPolarHydrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsNonPolarHydrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsAromaticNOxide", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsAromaticNOxide), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsChiral", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsChiral), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsAxial", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsAxial), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsClockwise", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsClockwise), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsAntiClockwise", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsAntiClockwise), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsPositiveStereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsPositiveStereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsNegativeStereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsNegativeStereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasChiralitySpecified", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasChiralitySpecified), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasChiralVolume", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasChiralVolume), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsHbondAcceptor", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsHbondAcceptor), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsHbondDonor", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsHbondDonor), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "IsHbondDonorH", VALUEFUNC(_wrap_OBMolAtomDFSIter_IsHbondDonorH), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasAlphaBetaUnsat", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasAlphaBetaUnsat), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasBondOfOrder", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasBondOfOrder), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "CountBondsOfOrder", VALUEFUNC(_wrap_OBMolAtomDFSIter_CountBondsOfOrder), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasNonSingleBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasNonSingleBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasSingleBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasSingleBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasDoubleBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasDoubleBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasAromaticBond", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasAromaticBond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "MatchesSMARTS", VALUEFUNC(_wrap_OBMolAtomDFSIter_MatchesSMARTS), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "DoTransformations", VALUEFUNC(_wrap_OBMolAtomDFSIter_DoTransformations), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "ClassDescription", VALUEFUNC(_wrap_OBMolAtomDFSIter_ClassDescription), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "HasData", VALUEFUNC(_wrap_OBMolAtomDFSIter_HasData), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "DeleteData", VALUEFUNC(_wrap_OBMolAtomDFSIter_DeleteData), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "SetData", VALUEFUNC(_wrap_OBMolAtomDFSIter_SetData), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "DataSize", VALUEFUNC(_wrap_OBMolAtomDFSIter_DataSize), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "GetData", VALUEFUNC(_wrap_OBMolAtomDFSIter_GetData), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "BeginData", VALUEFUNC(_wrap_OBMolAtomDFSIter_BeginData), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "EndData", VALUEFUNC(_wrap_OBMolAtomDFSIter_EndData), -1);
  cOBMolAtomDFSIter.mark = 0;
  cOBMolAtomDFSIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAtomDFSIter;
  cOBMolAtomDFSIter.trackObjects = 0;
  
  cOBMolAtomBFSIter.klass = rb_define_class_under(mOpenbabel, "OBMolAtomBFSIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, (void *) &cOBMolAtomBFSIter);
  rb_define_alloc_func(cOBMolAtomBFSIter.klass, _wrap_OBMolAtomBFSIter_allocate);
  rb_define_method(cOBMolAtomBFSIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAtomBFSIter), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "good", VALUEFUNC(_wrap_OBMolAtomBFSIter_good), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "inc", VALUEFUNC(_wrap_OBMolAtomBFSIter_inc), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "deref", VALUEFUNC(_wrap_OBMolAtomBFSIter_deref), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAtomBFSIter___ref__), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolAtomBFSIter_Visit_set), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "Visit", VALUEFUNC(_wrap_OBMolAtomBFSIter_Visit_get), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "Clear", VALUEFUNC(_wrap_OBMolAtomBFSIter_Clear), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetIdx", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetIdx), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetHyb", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetHyb), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetAtomicNum", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetAtomicNum), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetIsotope", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetIsotope), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetImplicitValence", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetImplicitValence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IncrementImplicitValence", VALUEFUNC(_wrap_OBMolAtomBFSIter_IncrementImplicitValence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "DecrementImplicitValence", VALUEFUNC(_wrap_OBMolAtomBFSIter_DecrementImplicitValence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetFormalCharge", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetFormalCharge), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetSpinMultiplicity", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetSpinMultiplicity), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetType", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetType), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetPartialCharge", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetPartialCharge), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetVector", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetVector), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetCoordPtr", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetCoordPtr), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetResidue", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetResidue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetParent", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetParent), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetAromatic", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetAromatic), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "UnsetAromatic", VALUEFUNC(_wrap_OBMolAtomBFSIter_UnsetAromatic), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetClockwiseStereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetClockwiseStereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetAntiClockwiseStereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetAntiClockwiseStereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetPositiveStereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetPositiveStereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetNegativeStereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetNegativeStereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "UnsetStereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_UnsetStereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetInRing", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetInRing), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetChiral", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetChiral), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "ClearCoordPtr", VALUEFUNC(_wrap_OBMolAtomBFSIter_ClearCoordPtr), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetFormalCharge", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetFormalCharge), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetAtomicNum", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetAtomicNum), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetIsotope", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetIsotope), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetSpinMultiplicity", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetSpinMultiplicity), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetAtomicMass", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetAtomicMass), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetExactMass", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetExactMass), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetIdx", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetIdx), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetCoordinateIdx", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetCoordinateIdx), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetCIdx", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetCIdx), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetValence", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetValence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetHyb", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetHyb), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetImplicitValence", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetImplicitValence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetHvyValence", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetHvyValence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetHeteroValence", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetHeteroValence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetType", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetType), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetX", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetX), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetY", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetY), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetZ", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetZ), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "x", VALUEFUNC(_wrap_OBMolAtomBFSIter_x), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "y", VALUEFUNC(_wrap_OBMolAtomBFSIter_y), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "z", VALUEFUNC(_wrap_OBMolAtomBFSIter_z), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetCoordinate", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetCoordinate), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetVector", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetVector), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetPartialCharge", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetPartialCharge), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetResidue", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetResidue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetParent", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetParent), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetNewBondVector", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetNewBondVector), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetNextAtom", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetNextAtom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "BeginBonds", VALUEFUNC(_wrap_OBMolAtomBFSIter_BeginBonds), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "EndBonds", VALUEFUNC(_wrap_OBMolAtomBFSIter_EndBonds), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "BeginBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_BeginBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "NextBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_NextBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "BeginNbrAtom", VALUEFUNC(_wrap_OBMolAtomBFSIter_BeginNbrAtom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "NextNbrAtom", VALUEFUNC(_wrap_OBMolAtomBFSIter_NextNbrAtom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetDistance", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetDistance), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetAngle", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetAngle), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "NewResidue", VALUEFUNC(_wrap_OBMolAtomBFSIter_NewResidue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "AddResidue", VALUEFUNC(_wrap_OBMolAtomBFSIter_AddResidue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "DeleteResidue", VALUEFUNC(_wrap_OBMolAtomBFSIter_DeleteResidue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "AddBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_AddBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "InsertBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_InsertBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "DeleteBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_DeleteBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "ClearBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_ClearBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HtoMethyl", VALUEFUNC(_wrap_OBMolAtomBFSIter_HtoMethyl), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetHybAndGeom", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetHybAndGeom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "ForceNoH", VALUEFUNC(_wrap_OBMolAtomBFSIter_ForceNoH), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasNoHForced", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasNoHForced), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "CountFreeOxygens", VALUEFUNC(_wrap_OBMolAtomBFSIter_CountFreeOxygens), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "ImplicitHydrogenCount", VALUEFUNC(_wrap_OBMolAtomBFSIter_ImplicitHydrogenCount), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "ExplicitHydrogenCount", VALUEFUNC(_wrap_OBMolAtomBFSIter_ExplicitHydrogenCount), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "MemberOfRingCount", VALUEFUNC(_wrap_OBMolAtomBFSIter_MemberOfRingCount), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "MemberOfRingSize", VALUEFUNC(_wrap_OBMolAtomBFSIter_MemberOfRingSize), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "CountRingBonds", VALUEFUNC(_wrap_OBMolAtomBFSIter_CountRingBonds), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SmallestBondAngle", VALUEFUNC(_wrap_OBMolAtomBFSIter_SmallestBondAngle), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "AverageBondAngle", VALUEFUNC(_wrap_OBMolAtomBFSIter_AverageBondAngle), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "BOSum", VALUEFUNC(_wrap_OBMolAtomBFSIter_BOSum), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "KBOSum", VALUEFUNC(_wrap_OBMolAtomBFSIter_KBOSum), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasResidue", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasResidue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsHydrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsHydrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsCarbon", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsCarbon), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsNitrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsNitrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsOxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsOxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsSulfur", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsSulfur), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsPhosphorus", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsPhosphorus), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsAromatic", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsAromatic), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsInRing", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsInRing), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsInRingSize", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsInRingSize), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsHeteroatom", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsHeteroatom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsNotCorH", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsNotCorH), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsConnected", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsConnected), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsOneThree", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsOneThree), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsOneFour", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsOneFour), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsCarboxylOxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsCarboxylOxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsPhosphateOxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsPhosphateOxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsSulfateOxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsSulfateOxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsNitroOxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsNitroOxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsAmideNitrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsAmideNitrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsPolarHydrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsPolarHydrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsNonPolarHydrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsNonPolarHydrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsAromaticNOxide", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsAromaticNOxide), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsChiral", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsChiral), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsAxial", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsAxial), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsClockwise", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsClockwise), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsAntiClockwise", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsAntiClockwise), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsPositiveStereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsPositiveStereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsNegativeStereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsNegativeStereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasChiralitySpecified", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasChiralitySpecified), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasChiralVolume", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasChiralVolume), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsHbondAcceptor", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsHbondAcceptor), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsHbondDonor", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsHbondDonor), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "IsHbondDonorH", VALUEFUNC(_wrap_OBMolAtomBFSIter_IsHbondDonorH), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasAlphaBetaUnsat", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasAlphaBetaUnsat), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasBondOfOrder", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasBondOfOrder), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "CountBondsOfOrder", VALUEFUNC(_wrap_OBMolAtomBFSIter_CountBondsOfOrder), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasNonSingleBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasNonSingleBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasSingleBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasSingleBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasDoubleBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasDoubleBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasAromaticBond", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasAromaticBond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "MatchesSMARTS", VALUEFUNC(_wrap_OBMolAtomBFSIter_MatchesSMARTS), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "DoTransformations", VALUEFUNC(_wrap_OBMolAtomBFSIter_DoTransformations), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "ClassDescription", VALUEFUNC(_wrap_OBMolAtomBFSIter_ClassDescription), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "HasData", VALUEFUNC(_wrap_OBMolAtomBFSIter_HasData), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "DeleteData", VALUEFUNC(_wrap_OBMolAtomBFSIter_DeleteData), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "SetData", VALUEFUNC(_wrap_OBMolAtomBFSIter_SetData), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "DataSize", VALUEFUNC(_wrap_OBMolAtomBFSIter_DataSize), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "GetData", VALUEFUNC(_wrap_OBMolAtomBFSIter_GetData), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "BeginData", VALUEFUNC(_wrap_OBMolAtomBFSIter_BeginData), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "EndData", VALUEFUNC(_wrap_OBMolAtomBFSIter_EndData), -1);
  cOBMolAtomBFSIter.mark = 0;
  cOBMolAtomBFSIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAtomBFSIter;
  cOBMolAtomBFSIter.trackObjects = 0;
  
  cOBMolBondIter.klass = rb_define_class_under(mOpenbabel, "OBMolBondIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolBondIter, (void *) &cOBMolBondIter);
  rb_define_alloc_func(cOBMolBondIter.klass, _wrap_OBMolBondIter_allocate);
  rb_define_method(cOBMolBondIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolBondIter), -1);
  rb_define_method(cOBMolBondIter.klass, "good", VALUEFUNC(_wrap_OBMolBondIter_good), -1);
  rb_define_method(cOBMolBondIter.klass, "inc", VALUEFUNC(_wrap_OBMolBondIter_inc), -1);
  rb_define_method(cOBMolBondIter.klass, "deref", VALUEFUNC(_wrap_OBMolBondIter_deref), -1);
  rb_define_method(cOBMolBondIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolBondIter___ref__), -1);
  rb_define_method(cOBMolBondIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolBondIter_Visit_set), -1);
  rb_define_method(cOBMolBondIter.klass, "Visit", VALUEFUNC(_wrap_OBMolBondIter_Visit_get), -1);
  rb_define_method(cOBMolBondIter.klass, "SetIdx", VALUEFUNC(_wrap_OBMolBondIter_SetIdx), -1);
  rb_define_method(cOBMolBondIter.klass, "SetBO", VALUEFUNC(_wrap_OBMolBondIter_SetBO), -1);
  rb_define_method(cOBMolBondIter.klass, "SetBondOrder", VALUEFUNC(_wrap_OBMolBondIter_SetBondOrder), -1);
  rb_define_method(cOBMolBondIter.klass, "SetBegin", VALUEFUNC(_wrap_OBMolBondIter_SetBegin), -1);
  rb_define_method(cOBMolBondIter.klass, "SetEnd", VALUEFUNC(_wrap_OBMolBondIter_SetEnd), -1);
  rb_define_method(cOBMolBondIter.klass, "SetParent", VALUEFUNC(_wrap_OBMolBondIter_SetParent), -1);
  rb_define_method(cOBMolBondIter.klass, "SetLength", VALUEFUNC(_wrap_OBMolBondIter_SetLength), -1);
  rb_define_method(cOBMolBondIter.klass, "Set", VALUEFUNC(_wrap_OBMolBondIter_Set), -1);
  rb_define_method(cOBMolBondIter.klass, "SetKSingle", VALUEFUNC(_wrap_OBMolBondIter_SetKSingle), -1);
  rb_define_method(cOBMolBondIter.klass, "SetKDouble", VALUEFUNC(_wrap_OBMolBondIter_SetKDouble), -1);
  rb_define_method(cOBMolBondIter.klass, "SetKTriple", VALUEFUNC(_wrap_OBMolBondIter_SetKTriple), -1);
  rb_define_method(cOBMolBondIter.klass, "SetAromatic", VALUEFUNC(_wrap_OBMolBondIter_SetAromatic), -1);
  rb_define_method(cOBMolBondIter.klass, "SetHash", VALUEFUNC(_wrap_OBMolBondIter_SetHash), -1);
  rb_define_method(cOBMolBondIter.klass, "SetWedge", VALUEFUNC(_wrap_OBMolBondIter_SetWedge), -1);
  rb_define_method(cOBMolBondIter.klass, "SetUp", VALUEFUNC(_wrap_OBMolBondIter_SetUp), -1);
  rb_define_method(cOBMolBondIter.klass, "SetDown", VALUEFUNC(_wrap_OBMolBondIter_SetDown), -1);
  rb_define_method(cOBMolBondIter.klass, "SetInRing", VALUEFUNC(_wrap_OBMolBondIter_SetInRing), -1);
  rb_define_method(cOBMolBondIter.klass, "SetClosure", VALUEFUNC(_wrap_OBMolBondIter_SetClosure), -1);
  rb_define_method(cOBMolBondIter.klass, "UnsetHash", VALUEFUNC(_wrap_OBMolBondIter_UnsetHash), -1);
  rb_define_method(cOBMolBondIter.klass, "UnsetWedge", VALUEFUNC(_wrap_OBMolBondIter_UnsetWedge), -1);
  rb_define_method(cOBMolBondIter.klass, "UnsetUp", VALUEFUNC(_wrap_OBMolBondIter_UnsetUp), -1);
  rb_define_method(cOBMolBondIter.klass, "UnsetDown", VALUEFUNC(_wrap_OBMolBondIter_UnsetDown), -1);
  rb_define_method(cOBMolBondIter.klass, "UnsetAromatic", VALUEFUNC(_wrap_OBMolBondIter_UnsetAromatic), -1);
  rb_define_method(cOBMolBondIter.klass, "UnsetKekule", VALUEFUNC(_wrap_OBMolBondIter_UnsetKekule), -1);
  rb_define_method(cOBMolBondIter.klass, "GetIdx", VALUEFUNC(_wrap_OBMolBondIter_GetIdx), -1);
  rb_define_method(cOBMolBondIter.klass, "GetBO", VALUEFUNC(_wrap_OBMolBondIter_GetBO), -1);
  rb_define_method(cOBMolBondIter.klass, "GetBondOrder", VALUEFUNC(_wrap_OBMolBondIter_GetBondOrder), -1);
  rb_define_method(cOBMolBondIter.klass, "GetFlags", VALUEFUNC(_wrap_OBMolBondIter_GetFlags), -1);
  rb_define_method(cOBMolBondIter.klass, "GetBeginAtomIdx", VALUEFUNC(_wrap_OBMolBondIter_GetBeginAtomIdx), -1);
  rb_define_method(cOBMolBondIter.klass, "GetEndAtomIdx", VALUEFUNC(_wrap_OBMolBondIter_GetEndAtomIdx), -1);
  rb_define_method(cOBMolBondIter.klass, "GetBeginAtom", VALUEFUNC(_wrap_OBMolBondIter_GetBeginAtom), -1);
  rb_define_method(cOBMolBondIter.klass, "GetEndAtom", VALUEFUNC(_wrap_OBMolBondIter_GetEndAtom), -1);
  rb_define_method(cOBMolBondIter.klass, "GetNbrAtom", VALUEFUNC(_wrap_OBMolBondIter_GetNbrAtom), -1);
  rb_define_method(cOBMolBondIter.klass, "GetParent", VALUEFUNC(_wrap_OBMolBondIter_GetParent), -1);
  rb_define_method(cOBMolBondIter.klass, "GetEquibLength", VALUEFUNC(_wrap_OBMolBondIter_GetEquibLength), -1);
  rb_define_method(cOBMolBondIter.klass, "GetLength", VALUEFUNC(_wrap_OBMolBondIter_GetLength), -1);
  rb_define_method(cOBMolBondIter.klass, "GetNbrAtomIdx", VALUEFUNC(_wrap_OBMolBondIter_GetNbrAtomIdx), -1);
  rb_define_method(cOBMolBondIter.klass, "IsAromatic", VALUEFUNC(_wrap_OBMolBondIter_IsAromatic), -1);
  rb_define_method(cOBMolBondIter.klass, "IsInRing", VALUEFUNC(_wrap_OBMolBondIter_IsInRing), -1);
  rb_define_method(cOBMolBondIter.klass, "IsRotor", VALUEFUNC(_wrap_OBMolBondIter_IsRotor), -1);
  rb_define_method(cOBMolBondIter.klass, "IsAmide", VALUEFUNC(_wrap_OBMolBondIter_IsAmide), -1);
  rb_define_method(cOBMolBondIter.klass, "IsPrimaryAmide", VALUEFUNC(_wrap_OBMolBondIter_IsPrimaryAmide), -1);
  rb_define_method(cOBMolBondIter.klass, "IsSecondaryAmide", VALUEFUNC(_wrap_OBMolBondIter_IsSecondaryAmide), -1);
  rb_define_method(cOBMolBondIter.klass, "IsEster", VALUEFUNC(_wrap_OBMolBondIter_IsEster), -1);
  rb_define_method(cOBMolBondIter.klass, "IsCarbonyl", VALUEFUNC(_wrap_OBMolBondIter_IsCarbonyl), -1);
  rb_define_method(cOBMolBondIter.klass, "IsSingle", VALUEFUNC(_wrap_OBMolBondIter_IsSingle), -1);
  rb_define_method(cOBMolBondIter.klass, "IsDouble", VALUEFUNC(_wrap_OBMolBondIter_IsDouble), -1);
  rb_define_method(cOBMolBondIter.klass, "IsTriple", VALUEFUNC(_wrap_OBMolBondIter_IsTriple), -1);
  rb_define_method(cOBMolBondIter.klass, "IsKSingle", VALUEFUNC(_wrap_OBMolBondIter_IsKSingle), -1);
  rb_define_method(cOBMolBondIter.klass, "IsKDouble", VALUEFUNC(_wrap_OBMolBondIter_IsKDouble), -1);
  rb_define_method(cOBMolBondIter.klass, "IsKTriple", VALUEFUNC(_wrap_OBMolBondIter_IsKTriple), -1);
  rb_define_method(cOBMolBondIter.klass, "IsClosure", VALUEFUNC(_wrap_OBMolBondIter_IsClosure), -1);
  rb_define_method(cOBMolBondIter.klass, "IsUp", VALUEFUNC(_wrap_OBMolBondIter_IsUp), -1);
  rb_define_method(cOBMolBondIter.klass, "IsDown", VALUEFUNC(_wrap_OBMolBondIter_IsDown), -1);
  rb_define_method(cOBMolBondIter.klass, "IsWedge", VALUEFUNC(_wrap_OBMolBondIter_IsWedge), -1);
  rb_define_method(cOBMolBondIter.klass, "IsHash", VALUEFUNC(_wrap_OBMolBondIter_IsHash), -1);
  rb_define_method(cOBMolBondIter.klass, "IsDoubleBondGeometry", VALUEFUNC(_wrap_OBMolBondIter_IsDoubleBondGeometry), -1);
  rb_define_method(cOBMolBondIter.klass, "Clear", VALUEFUNC(_wrap_OBMolBondIter_Clear), -1);
  rb_define_method(cOBMolBondIter.klass, "DoTransformations", VALUEFUNC(_wrap_OBMolBondIter_DoTransformations), -1);
  rb_define_method(cOBMolBondIter.klass, "ClassDescription", VALUEFUNC(_wrap_OBMolBondIter_ClassDescription), -1);
  rb_define_method(cOBMolBondIter.klass, "HasData", VALUEFUNC(_wrap_OBMolBondIter_HasData), -1);
  rb_define_method(cOBMolBondIter.klass, "DeleteData", VALUEFUNC(_wrap_OBMolBondIter_DeleteData), -1);
  rb_define_method(cOBMolBondIter.klass, "SetData", VALUEFUNC(_wrap_OBMolBondIter_SetData), -1);
  rb_define_method(cOBMolBondIter.klass, "DataSize", VALUEFUNC(_wrap_OBMolBondIter_DataSize), -1);
  rb_define_method(cOBMolBondIter.klass, "GetData", VALUEFUNC(_wrap_OBMolBondIter_GetData), -1);
  rb_define_method(cOBMolBondIter.klass, "BeginData", VALUEFUNC(_wrap_OBMolBondIter_BeginData), -1);
  rb_define_method(cOBMolBondIter.klass, "EndData", VALUEFUNC(_wrap_OBMolBondIter_EndData), -1);
  cOBMolBondIter.mark = 0;
  cOBMolBondIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolBondIter;
  cOBMolBondIter.trackObjects = 0;
  
  cOBAtomAtomIter.klass = rb_define_class_under(mOpenbabel, "OBAtomAtomIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAtomAtomIter, (void *) &cOBAtomAtomIter);
  rb_define_alloc_func(cOBAtomAtomIter.klass, _wrap_OBAtomAtomIter_allocate);
  rb_define_method(cOBAtomAtomIter.klass, "initialize", VALUEFUNC(_wrap_new_OBAtomAtomIter), -1);
  rb_define_method(cOBAtomAtomIter.klass, "good", VALUEFUNC(_wrap_OBAtomAtomIter_good), -1);
  rb_define_method(cOBAtomAtomIter.klass, "inc", VALUEFUNC(_wrap_OBAtomAtomIter_inc), -1);
  rb_define_method(cOBAtomAtomIter.klass, "deref", VALUEFUNC(_wrap_OBAtomAtomIter_deref), -1);
  rb_define_method(cOBAtomAtomIter.klass, "__ref__", VALUEFUNC(_wrap_OBAtomAtomIter___ref__), -1);
  rb_define_method(cOBAtomAtomIter.klass, "Visit=", VALUEFUNC(_wrap_OBAtomAtomIter_Visit_set), -1);
  rb_define_method(cOBAtomAtomIter.klass, "Visit", VALUEFUNC(_wrap_OBAtomAtomIter_Visit_get), -1);
  rb_define_method(cOBAtomAtomIter.klass, "Clear", VALUEFUNC(_wrap_OBAtomAtomIter_Clear), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetIdx", VALUEFUNC(_wrap_OBAtomAtomIter_SetIdx), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetHyb", VALUEFUNC(_wrap_OBAtomAtomIter_SetHyb), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetAtomicNum", VALUEFUNC(_wrap_OBAtomAtomIter_SetAtomicNum), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetIsotope", VALUEFUNC(_wrap_OBAtomAtomIter_SetIsotope), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetImplicitValence", VALUEFUNC(_wrap_OBAtomAtomIter_SetImplicitValence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IncrementImplicitValence", VALUEFUNC(_wrap_OBAtomAtomIter_IncrementImplicitValence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "DecrementImplicitValence", VALUEFUNC(_wrap_OBAtomAtomIter_DecrementImplicitValence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetFormalCharge", VALUEFUNC(_wrap_OBAtomAtomIter_SetFormalCharge), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetSpinMultiplicity", VALUEFUNC(_wrap_OBAtomAtomIter_SetSpinMultiplicity), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetType", VALUEFUNC(_wrap_OBAtomAtomIter_SetType), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetPartialCharge", VALUEFUNC(_wrap_OBAtomAtomIter_SetPartialCharge), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetVector", VALUEFUNC(_wrap_OBAtomAtomIter_SetVector), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetCoordPtr", VALUEFUNC(_wrap_OBAtomAtomIter_SetCoordPtr), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetResidue", VALUEFUNC(_wrap_OBAtomAtomIter_SetResidue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetParent", VALUEFUNC(_wrap_OBAtomAtomIter_SetParent), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetAromatic", VALUEFUNC(_wrap_OBAtomAtomIter_SetAromatic), -1);
  rb_define_method(cOBAtomAtomIter.klass, "UnsetAromatic", VALUEFUNC(_wrap_OBAtomAtomIter_UnsetAromatic), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetClockwiseStereo", VALUEFUNC(_wrap_OBAtomAtomIter_SetClockwiseStereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetAntiClockwiseStereo", VALUEFUNC(_wrap_OBAtomAtomIter_SetAntiClockwiseStereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetPositiveStereo", VALUEFUNC(_wrap_OBAtomAtomIter_SetPositiveStereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetNegativeStereo", VALUEFUNC(_wrap_OBAtomAtomIter_SetNegativeStereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "UnsetStereo", VALUEFUNC(_wrap_OBAtomAtomIter_UnsetStereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetInRing", VALUEFUNC(_wrap_OBAtomAtomIter_SetInRing), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetChiral", VALUEFUNC(_wrap_OBAtomAtomIter_SetChiral), -1);
  rb_define_method(cOBAtomAtomIter.klass, "ClearCoordPtr", VALUEFUNC(_wrap_OBAtomAtomIter_ClearCoordPtr), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetFormalCharge", VALUEFUNC(_wrap_OBAtomAtomIter_GetFormalCharge), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetAtomicNum", VALUEFUNC(_wrap_OBAtomAtomIter_GetAtomicNum), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetIsotope", VALUEFUNC(_wrap_OBAtomAtomIter_GetIsotope), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetSpinMultiplicity", VALUEFUNC(_wrap_OBAtomAtomIter_GetSpinMultiplicity), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetAtomicMass", VALUEFUNC(_wrap_OBAtomAtomIter_GetAtomicMass), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetExactMass", VALUEFUNC(_wrap_OBAtomAtomIter_GetExactMass), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetIdx", VALUEFUNC(_wrap_OBAtomAtomIter_GetIdx), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetCoordinateIdx", VALUEFUNC(_wrap_OBAtomAtomIter_GetCoordinateIdx), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetCIdx", VALUEFUNC(_wrap_OBAtomAtomIter_GetCIdx), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetValence", VALUEFUNC(_wrap_OBAtomAtomIter_GetValence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetHyb", VALUEFUNC(_wrap_OBAtomAtomIter_GetHyb), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetImplicitValence", VALUEFUNC(_wrap_OBAtomAtomIter_GetImplicitValence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetHvyValence", VALUEFUNC(_wrap_OBAtomAtomIter_GetHvyValence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetHeteroValence", VALUEFUNC(_wrap_OBAtomAtomIter_GetHeteroValence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetType", VALUEFUNC(_wrap_OBAtomAtomIter_GetType), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetX", VALUEFUNC(_wrap_OBAtomAtomIter_GetX), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetY", VALUEFUNC(_wrap_OBAtomAtomIter_GetY), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetZ", VALUEFUNC(_wrap_OBAtomAtomIter_GetZ), -1);
  rb_define_method(cOBAtomAtomIter.klass, "x", VALUEFUNC(_wrap_OBAtomAtomIter_x), -1);
  rb_define_method(cOBAtomAtomIter.klass, "y", VALUEFUNC(_wrap_OBAtomAtomIter_y), -1);
  rb_define_method(cOBAtomAtomIter.klass, "z", VALUEFUNC(_wrap_OBAtomAtomIter_z), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetCoordinate", VALUEFUNC(_wrap_OBAtomAtomIter_GetCoordinate), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetVector", VALUEFUNC(_wrap_OBAtomAtomIter_GetVector), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetPartialCharge", VALUEFUNC(_wrap_OBAtomAtomIter_GetPartialCharge), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetResidue", VALUEFUNC(_wrap_OBAtomAtomIter_GetResidue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetParent", VALUEFUNC(_wrap_OBAtomAtomIter_GetParent), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetNewBondVector", VALUEFUNC(_wrap_OBAtomAtomIter_GetNewBondVector), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetBond", VALUEFUNC(_wrap_OBAtomAtomIter_GetBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetNextAtom", VALUEFUNC(_wrap_OBAtomAtomIter_GetNextAtom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "BeginBonds", VALUEFUNC(_wrap_OBAtomAtomIter_BeginBonds), -1);
  rb_define_method(cOBAtomAtomIter.klass, "EndBonds", VALUEFUNC(_wrap_OBAtomAtomIter_EndBonds), -1);
  rb_define_method(cOBAtomAtomIter.klass, "BeginBond", VALUEFUNC(_wrap_OBAtomAtomIter_BeginBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "NextBond", VALUEFUNC(_wrap_OBAtomAtomIter_NextBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "BeginNbrAtom", VALUEFUNC(_wrap_OBAtomAtomIter_BeginNbrAtom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "NextNbrAtom", VALUEFUNC(_wrap_OBAtomAtomIter_NextNbrAtom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetDistance", VALUEFUNC(_wrap_OBAtomAtomIter_GetDistance), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetAngle", VALUEFUNC(_wrap_OBAtomAtomIter_GetAngle), -1);
  rb_define_method(cOBAtomAtomIter.klass, "NewResidue", VALUEFUNC(_wrap_OBAtomAtomIter_NewResidue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "AddResidue", VALUEFUNC(_wrap_OBAtomAtomIter_AddResidue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "DeleteResidue", VALUEFUNC(_wrap_OBAtomAtomIter_DeleteResidue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "AddBond", VALUEFUNC(_wrap_OBAtomAtomIter_AddBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "InsertBond", VALUEFUNC(_wrap_OBAtomAtomIter_InsertBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "DeleteBond", VALUEFUNC(_wrap_OBAtomAtomIter_DeleteBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "ClearBond", VALUEFUNC(_wrap_OBAtomAtomIter_ClearBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HtoMethyl", VALUEFUNC(_wrap_OBAtomAtomIter_HtoMethyl), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetHybAndGeom", VALUEFUNC(_wrap_OBAtomAtomIter_SetHybAndGeom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "ForceNoH", VALUEFUNC(_wrap_OBAtomAtomIter_ForceNoH), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasNoHForced", VALUEFUNC(_wrap_OBAtomAtomIter_HasNoHForced), -1);
  rb_define_method(cOBAtomAtomIter.klass, "CountFreeOxygens", VALUEFUNC(_wrap_OBAtomAtomIter_CountFreeOxygens), -1);
  rb_define_method(cOBAtomAtomIter.klass, "ImplicitHydrogenCount", VALUEFUNC(_wrap_OBAtomAtomIter_ImplicitHydrogenCount), -1);
  rb_define_method(cOBAtomAtomIter.klass, "ExplicitHydrogenCount", VALUEFUNC(_wrap_OBAtomAtomIter_ExplicitHydrogenCount), -1);
  rb_define_method(cOBAtomAtomIter.klass, "MemberOfRingCount", VALUEFUNC(_wrap_OBAtomAtomIter_MemberOfRingCount), -1);
  rb_define_method(cOBAtomAtomIter.klass, "MemberOfRingSize", VALUEFUNC(_wrap_OBAtomAtomIter_MemberOfRingSize), -1);
  rb_define_method(cOBAtomAtomIter.klass, "CountRingBonds", VALUEFUNC(_wrap_OBAtomAtomIter_CountRingBonds), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SmallestBondAngle", VALUEFUNC(_wrap_OBAtomAtomIter_SmallestBondAngle), -1);
  rb_define_method(cOBAtomAtomIter.klass, "AverageBondAngle", VALUEFUNC(_wrap_OBAtomAtomIter_AverageBondAngle), -1);
  rb_define_method(cOBAtomAtomIter.klass, "BOSum", VALUEFUNC(_wrap_OBAtomAtomIter_BOSum), -1);
  rb_define_method(cOBAtomAtomIter.klass, "KBOSum", VALUEFUNC(_wrap_OBAtomAtomIter_KBOSum), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasResidue", VALUEFUNC(_wrap_OBAtomAtomIter_HasResidue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsHydrogen", VALUEFUNC(_wrap_OBAtomAtomIter_IsHydrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsCarbon", VALUEFUNC(_wrap_OBAtomAtomIter_IsCarbon), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsNitrogen", VALUEFUNC(_wrap_OBAtomAtomIter_IsNitrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsOxygen", VALUEFUNC(_wrap_OBAtomAtomIter_IsOxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsSulfur", VALUEFUNC(_wrap_OBAtomAtomIter_IsSulfur), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsPhosphorus", VALUEFUNC(_wrap_OBAtomAtomIter_IsPhosphorus), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsAromatic", VALUEFUNC(_wrap_OBAtomAtomIter_IsAromatic), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsInRing", VALUEFUNC(_wrap_OBAtomAtomIter_IsInRing), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsInRingSize", VALUEFUNC(_wrap_OBAtomAtomIter_IsInRingSize), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsHeteroatom", VALUEFUNC(_wrap_OBAtomAtomIter_IsHeteroatom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsNotCorH", VALUEFUNC(_wrap_OBAtomAtomIter_IsNotCorH), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsConnected", VALUEFUNC(_wrap_OBAtomAtomIter_IsConnected), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsOneThree", VALUEFUNC(_wrap_OBAtomAtomIter_IsOneThree), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsOneFour", VALUEFUNC(_wrap_OBAtomAtomIter_IsOneFour), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsCarboxylOxygen", VALUEFUNC(_wrap_OBAtomAtomIter_IsCarboxylOxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsPhosphateOxygen", VALUEFUNC(_wrap_OBAtomAtomIter_IsPhosphateOxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsSulfateOxygen", VALUEFUNC(_wrap_OBAtomAtomIter_IsSulfateOxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsNitroOxygen", VALUEFUNC(_wrap_OBAtomAtomIter_IsNitroOxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsAmideNitrogen", VALUEFUNC(_wrap_OBAtomAtomIter_IsAmideNitrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsPolarHydrogen", VALUEFUNC(_wrap_OBAtomAtomIter_IsPolarHydrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsNonPolarHydrogen", VALUEFUNC(_wrap_OBAtomAtomIter_IsNonPolarHydrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsAromaticNOxide", VALUEFUNC(_wrap_OBAtomAtomIter_IsAromaticNOxide), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsChiral", VALUEFUNC(_wrap_OBAtomAtomIter_IsChiral), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsAxial", VALUEFUNC(_wrap_OBAtomAtomIter_IsAxial), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsClockwise", VALUEFUNC(_wrap_OBAtomAtomIter_IsClockwise), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsAntiClockwise", VALUEFUNC(_wrap_OBAtomAtomIter_IsAntiClockwise), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsPositiveStereo", VALUEFUNC(_wrap_OBAtomAtomIter_IsPositiveStereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsNegativeStereo", VALUEFUNC(_wrap_OBAtomAtomIter_IsNegativeStereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasChiralitySpecified", VALUEFUNC(_wrap_OBAtomAtomIter_HasChiralitySpecified), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasChiralVolume", VALUEFUNC(_wrap_OBAtomAtomIter_HasChiralVolume), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsHbondAcceptor", VALUEFUNC(_wrap_OBAtomAtomIter_IsHbondAcceptor), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsHbondDonor", VALUEFUNC(_wrap_OBAtomAtomIter_IsHbondDonor), -1);
  rb_define_method(cOBAtomAtomIter.klass, "IsHbondDonorH", VALUEFUNC(_wrap_OBAtomAtomIter_IsHbondDonorH), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasAlphaBetaUnsat", VALUEFUNC(_wrap_OBAtomAtomIter_HasAlphaBetaUnsat), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasBondOfOrder", VALUEFUNC(_wrap_OBAtomAtomIter_HasBondOfOrder), -1);
  rb_define_method(cOBAtomAtomIter.klass, "CountBondsOfOrder", VALUEFUNC(_wrap_OBAtomAtomIter_CountBondsOfOrder), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasNonSingleBond", VALUEFUNC(_wrap_OBAtomAtomIter_HasNonSingleBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasSingleBond", VALUEFUNC(_wrap_OBAtomAtomIter_HasSingleBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasDoubleBond", VALUEFUNC(_wrap_OBAtomAtomIter_HasDoubleBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasAromaticBond", VALUEFUNC(_wrap_OBAtomAtomIter_HasAromaticBond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "MatchesSMARTS", VALUEFUNC(_wrap_OBAtomAtomIter_MatchesSMARTS), -1);
  rb_define_method(cOBAtomAtomIter.klass, "DoTransformations", VALUEFUNC(_wrap_OBAtomAtomIter_DoTransformations), -1);
  rb_define_method(cOBAtomAtomIter.klass, "ClassDescription", VALUEFUNC(_wrap_OBAtomAtomIter_ClassDescription), -1);
  rb_define_method(cOBAtomAtomIter.klass, "HasData", VALUEFUNC(_wrap_OBAtomAtomIter_HasData), -1);
  rb_define_method(cOBAtomAtomIter.klass, "DeleteData", VALUEFUNC(_wrap_OBAtomAtomIter_DeleteData), -1);
  rb_define_method(cOBAtomAtomIter.klass, "SetData", VALUEFUNC(_wrap_OBAtomAtomIter_SetData), -1);
  rb_define_method(cOBAtomAtomIter.klass, "DataSize", VALUEFUNC(_wrap_OBAtomAtomIter_DataSize), -1);
  rb_define_method(cOBAtomAtomIter.klass, "GetData", VALUEFUNC(_wrap_OBAtomAtomIter_GetData), -1);
  rb_define_method(cOBAtomAtomIter.klass, "BeginData", VALUEFUNC(_wrap_OBAtomAtomIter_BeginData), -1);
  rb_define_method(cOBAtomAtomIter.klass, "EndData", VALUEFUNC(_wrap_OBAtomAtomIter_EndData), -1);
  cOBAtomAtomIter.mark = 0;
  cOBAtomAtomIter.destroy = (void (*)(void *)) free_OpenBabel_OBAtomAtomIter;
  cOBAtomAtomIter.trackObjects = 0;
  
  cOBAtomBondIter.klass = rb_define_class_under(mOpenbabel, "OBAtomBondIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAtomBondIter, (void *) &cOBAtomBondIter);
  rb_define_alloc_func(cOBAtomBondIter.klass, _wrap_OBAtomBondIter_allocate);
  rb_define_method(cOBAtomBondIter.klass, "initialize", VALUEFUNC(_wrap_new_OBAtomBondIter), -1);
  rb_define_method(cOBAtomBondIter.klass, "good", VALUEFUNC(_wrap_OBAtomBondIter_good), -1);
  rb_define_method(cOBAtomBondIter.klass, "inc", VALUEFUNC(_wrap_OBAtomBondIter_inc), -1);
  rb_define_method(cOBAtomBondIter.klass, "deref", VALUEFUNC(_wrap_OBAtomBondIter_deref), -1);
  rb_define_method(cOBAtomBondIter.klass, "__ref__", VALUEFUNC(_wrap_OBAtomBondIter___ref__), -1);
  rb_define_method(cOBAtomBondIter.klass, "Visit=", VALUEFUNC(_wrap_OBAtomBondIter_Visit_set), -1);
  rb_define_method(cOBAtomBondIter.klass, "Visit", VALUEFUNC(_wrap_OBAtomBondIter_Visit_get), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetIdx", VALUEFUNC(_wrap_OBAtomBondIter_SetIdx), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetBO", VALUEFUNC(_wrap_OBAtomBondIter_SetBO), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetBondOrder", VALUEFUNC(_wrap_OBAtomBondIter_SetBondOrder), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetBegin", VALUEFUNC(_wrap_OBAtomBondIter_SetBegin), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetEnd", VALUEFUNC(_wrap_OBAtomBondIter_SetEnd), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetParent", VALUEFUNC(_wrap_OBAtomBondIter_SetParent), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetLength", VALUEFUNC(_wrap_OBAtomBondIter_SetLength), -1);
  rb_define_method(cOBAtomBondIter.klass, "Set", VALUEFUNC(_wrap_OBAtomBondIter_Set), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetKSingle", VALUEFUNC(_wrap_OBAtomBondIter_SetKSingle), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetKDouble", VALUEFUNC(_wrap_OBAtomBondIter_SetKDouble), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetKTriple", VALUEFUNC(_wrap_OBAtomBondIter_SetKTriple), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetAromatic", VALUEFUNC(_wrap_OBAtomBondIter_SetAromatic), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetHash", VALUEFUNC(_wrap_OBAtomBondIter_SetHash), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetWedge", VALUEFUNC(_wrap_OBAtomBondIter_SetWedge), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetUp", VALUEFUNC(_wrap_OBAtomBondIter_SetUp), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetDown", VALUEFUNC(_wrap_OBAtomBondIter_SetDown), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetInRing", VALUEFUNC(_wrap_OBAtomBondIter_SetInRing), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetClosure", VALUEFUNC(_wrap_OBAtomBondIter_SetClosure), -1);
  rb_define_method(cOBAtomBondIter.klass, "UnsetHash", VALUEFUNC(_wrap_OBAtomBondIter_UnsetHash), -1);
  rb_define_method(cOBAtomBondIter.klass, "UnsetWedge", VALUEFUNC(_wrap_OBAtomBondIter_UnsetWedge), -1);
  rb_define_method(cOBAtomBondIter.klass, "UnsetUp", VALUEFUNC(_wrap_OBAtomBondIter_UnsetUp), -1);
  rb_define_method(cOBAtomBondIter.klass, "UnsetDown", VALUEFUNC(_wrap_OBAtomBondIter_UnsetDown), -1);
  rb_define_method(cOBAtomBondIter.klass, "UnsetAromatic", VALUEFUNC(_wrap_OBAtomBondIter_UnsetAromatic), -1);
  rb_define_method(cOBAtomBondIter.klass, "UnsetKekule", VALUEFUNC(_wrap_OBAtomBondIter_UnsetKekule), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetIdx", VALUEFUNC(_wrap_OBAtomBondIter_GetIdx), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetBO", VALUEFUNC(_wrap_OBAtomBondIter_GetBO), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetBondOrder", VALUEFUNC(_wrap_OBAtomBondIter_GetBondOrder), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetFlags", VALUEFUNC(_wrap_OBAtomBondIter_GetFlags), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetBeginAtomIdx", VALUEFUNC(_wrap_OBAtomBondIter_GetBeginAtomIdx), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetEndAtomIdx", VALUEFUNC(_wrap_OBAtomBondIter_GetEndAtomIdx), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetBeginAtom", VALUEFUNC(_wrap_OBAtomBondIter_GetBeginAtom), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetEndAtom", VALUEFUNC(_wrap_OBAtomBondIter_GetEndAtom), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetNbrAtom", VALUEFUNC(_wrap_OBAtomBondIter_GetNbrAtom), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetParent", VALUEFUNC(_wrap_OBAtomBondIter_GetParent), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetEquibLength", VALUEFUNC(_wrap_OBAtomBondIter_GetEquibLength), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetLength", VALUEFUNC(_wrap_OBAtomBondIter_GetLength), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetNbrAtomIdx", VALUEFUNC(_wrap_OBAtomBondIter_GetNbrAtomIdx), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsAromatic", VALUEFUNC(_wrap_OBAtomBondIter_IsAromatic), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsInRing", VALUEFUNC(_wrap_OBAtomBondIter_IsInRing), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsRotor", VALUEFUNC(_wrap_OBAtomBondIter_IsRotor), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsAmide", VALUEFUNC(_wrap_OBAtomBondIter_IsAmide), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsPrimaryAmide", VALUEFUNC(_wrap_OBAtomBondIter_IsPrimaryAmide), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsSecondaryAmide", VALUEFUNC(_wrap_OBAtomBondIter_IsSecondaryAmide), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsEster", VALUEFUNC(_wrap_OBAtomBondIter_IsEster), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsCarbonyl", VALUEFUNC(_wrap_OBAtomBondIter_IsCarbonyl), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsSingle", VALUEFUNC(_wrap_OBAtomBondIter_IsSingle), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsDouble", VALUEFUNC(_wrap_OBAtomBondIter_IsDouble), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsTriple", VALUEFUNC(_wrap_OBAtomBondIter_IsTriple), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsKSingle", VALUEFUNC(_wrap_OBAtomBondIter_IsKSingle), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsKDouble", VALUEFUNC(_wrap_OBAtomBondIter_IsKDouble), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsKTriple", VALUEFUNC(_wrap_OBAtomBondIter_IsKTriple), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsClosure", VALUEFUNC(_wrap_OBAtomBondIter_IsClosure), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsUp", VALUEFUNC(_wrap_OBAtomBondIter_IsUp), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsDown", VALUEFUNC(_wrap_OBAtomBondIter_IsDown), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsWedge", VALUEFUNC(_wrap_OBAtomBondIter_IsWedge), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsHash", VALUEFUNC(_wrap_OBAtomBondIter_IsHash), -1);
  rb_define_method(cOBAtomBondIter.klass, "IsDoubleBondGeometry", VALUEFUNC(_wrap_OBAtomBondIter_IsDoubleBondGeometry), -1);
  rb_define_method(cOBAtomBondIter.klass, "Clear", VALUEFUNC(_wrap_OBAtomBondIter_Clear), -1);
  rb_define_method(cOBAtomBondIter.klass, "DoTransformations", VALUEFUNC(_wrap_OBAtomBondIter_DoTransformations), -1);
  rb_define_method(cOBAtomBondIter.klass, "ClassDescription", VALUEFUNC(_wrap_OBAtomBondIter_ClassDescription), -1);
  rb_define_method(cOBAtomBondIter.klass, "HasData", VALUEFUNC(_wrap_OBAtomBondIter_HasData), -1);
  rb_define_method(cOBAtomBondIter.klass, "DeleteData", VALUEFUNC(_wrap_OBAtomBondIter_DeleteData), -1);
  rb_define_method(cOBAtomBondIter.klass, "SetData", VALUEFUNC(_wrap_OBAtomBondIter_SetData), -1);
  rb_define_method(cOBAtomBondIter.klass, "DataSize", VALUEFUNC(_wrap_OBAtomBondIter_DataSize), -1);
  rb_define_method(cOBAtomBondIter.klass, "GetData", VALUEFUNC(_wrap_OBAtomBondIter_GetData), -1);
  rb_define_method(cOBAtomBondIter.klass, "BeginData", VALUEFUNC(_wrap_OBAtomBondIter_BeginData), -1);
  rb_define_method(cOBAtomBondIter.klass, "EndData", VALUEFUNC(_wrap_OBAtomBondIter_EndData), -1);
  cOBAtomBondIter.mark = 0;
  cOBAtomBondIter.destroy = (void (*)(void *)) free_OpenBabel_OBAtomBondIter;
  cOBAtomBondIter.trackObjects = 0;
  
  cOBResidueIter.klass = rb_define_class_under(mOpenbabel, "OBResidueIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidueIter, (void *) &cOBResidueIter);
  rb_define_alloc_func(cOBResidueIter.klass, _wrap_OBResidueIter_allocate);
  rb_define_method(cOBResidueIter.klass, "initialize", VALUEFUNC(_wrap_new_OBResidueIter), -1);
  rb_define_method(cOBResidueIter.klass, "good", VALUEFUNC(_wrap_OBResidueIter_good), -1);
  rb_define_method(cOBResidueIter.klass, "inc", VALUEFUNC(_wrap_OBResidueIter_inc), -1);
  rb_define_method(cOBResidueIter.klass, "deref", VALUEFUNC(_wrap_OBResidueIter_deref), -1);
  rb_define_method(cOBResidueIter.klass, "__ref__", VALUEFUNC(_wrap_OBResidueIter___ref__), -1);
  rb_define_method(cOBResidueIter.klass, "AddAtom", VALUEFUNC(_wrap_OBResidueIter_AddAtom), -1);
  rb_define_method(cOBResidueIter.klass, "InsertAtom", VALUEFUNC(_wrap_OBResidueIter_InsertAtom), -1);
  rb_define_method(cOBResidueIter.klass, "RemoveAtom", VALUEFUNC(_wrap_OBResidueIter_RemoveAtom), -1);
  rb_define_method(cOBResidueIter.klass, "Clear", VALUEFUNC(_wrap_OBResidueIter_Clear), -1);
  rb_define_method(cOBResidueIter.klass, "SetName", VALUEFUNC(_wrap_OBResidueIter_SetName), -1);
  rb_define_method(cOBResidueIter.klass, "SetNum", VALUEFUNC(_wrap_OBResidueIter_SetNum), -1);
  rb_define_method(cOBResidueIter.klass, "SetChain", VALUEFUNC(_wrap_OBResidueIter_SetChain), -1);
  rb_define_method(cOBResidueIter.klass, "SetChainNum", VALUEFUNC(_wrap_OBResidueIter_SetChainNum), -1);
  rb_define_method(cOBResidueIter.klass, "SetIdx", VALUEFUNC(_wrap_OBResidueIter_SetIdx), -1);
  rb_define_method(cOBResidueIter.klass, "SetAtomID", VALUEFUNC(_wrap_OBResidueIter_SetAtomID), -1);
  rb_define_method(cOBResidueIter.klass, "SetHetAtom", VALUEFUNC(_wrap_OBResidueIter_SetHetAtom), -1);
  rb_define_method(cOBResidueIter.klass, "SetSerialNum", VALUEFUNC(_wrap_OBResidueIter_SetSerialNum), -1);
  rb_define_method(cOBResidueIter.klass, "GetName", VALUEFUNC(_wrap_OBResidueIter_GetName), -1);
  rb_define_method(cOBResidueIter.klass, "GetNum", VALUEFUNC(_wrap_OBResidueIter_GetNum), -1);
  rb_define_method(cOBResidueIter.klass, "GetNumAtoms", VALUEFUNC(_wrap_OBResidueIter_GetNumAtoms), -1);
  rb_define_method(cOBResidueIter.klass, "GetChain", VALUEFUNC(_wrap_OBResidueIter_GetChain), -1);
  rb_define_method(cOBResidueIter.klass, "GetChainNum", VALUEFUNC(_wrap_OBResidueIter_GetChainNum), -1);
  rb_define_method(cOBResidueIter.klass, "GetIdx", VALUEFUNC(_wrap_OBResidueIter_GetIdx), -1);
  rb_define_method(cOBResidueIter.klass, "GetResKey", VALUEFUNC(_wrap_OBResidueIter_GetResKey), -1);
  rb_define_method(cOBResidueIter.klass, "GetAtoms", VALUEFUNC(_wrap_OBResidueIter_GetAtoms), -1);
  rb_define_method(cOBResidueIter.klass, "GetBonds", VALUEFUNC(_wrap_OBResidueIter_GetBonds), -1);
  rb_define_method(cOBResidueIter.klass, "GetAtomID", VALUEFUNC(_wrap_OBResidueIter_GetAtomID), -1);
  rb_define_method(cOBResidueIter.klass, "GetSerialNum", VALUEFUNC(_wrap_OBResidueIter_GetSerialNum), -1);
  rb_define_method(cOBResidueIter.klass, "GetAminoAcidProperty", VALUEFUNC(_wrap_OBResidueIter_GetAminoAcidProperty), -1);
  rb_define_method(cOBResidueIter.klass, "GetAtomProperty", VALUEFUNC(_wrap_OBResidueIter_GetAtomProperty), -1);
  rb_define_method(cOBResidueIter.klass, "GetResidueProperty", VALUEFUNC(_wrap_OBResidueIter_GetResidueProperty), -1);
  rb_define_method(cOBResidueIter.klass, "IsHetAtom", VALUEFUNC(_wrap_OBResidueIter_IsHetAtom), -1);
  rb_define_method(cOBResidueIter.klass, "IsResidueType", VALUEFUNC(_wrap_OBResidueIter_IsResidueType), -1);
  rb_define_method(cOBResidueIter.klass, "BeginAtoms", VALUEFUNC(_wrap_OBResidueIter_BeginAtoms), -1);
  rb_define_method(cOBResidueIter.klass, "EndAtoms", VALUEFUNC(_wrap_OBResidueIter_EndAtoms), -1);
  rb_define_method(cOBResidueIter.klass, "BeginAtom", VALUEFUNC(_wrap_OBResidueIter_BeginAtom), -1);
  rb_define_method(cOBResidueIter.klass, "NextAtom", VALUEFUNC(_wrap_OBResidueIter_NextAtom), -1);
  rb_define_method(cOBResidueIter.klass, "DoTransformations", VALUEFUNC(_wrap_OBResidueIter_DoTransformations), -1);
  rb_define_method(cOBResidueIter.klass, "ClassDescription", VALUEFUNC(_wrap_OBResidueIter_ClassDescription), -1);
  rb_define_method(cOBResidueIter.klass, "HasData", VALUEFUNC(_wrap_OBResidueIter_HasData), -1);
  rb_define_method(cOBResidueIter.klass, "DeleteData", VALUEFUNC(_wrap_OBResidueIter_DeleteData), -1);
  rb_define_method(cOBResidueIter.klass, "SetData", VALUEFUNC(_wrap_OBResidueIter_SetData), -1);
  rb_define_method(cOBResidueIter.klass, "DataSize", VALUEFUNC(_wrap_OBResidueIter_DataSize), -1);
  rb_define_method(cOBResidueIter.klass, "GetData", VALUEFUNC(_wrap_OBResidueIter_GetData), -1);
  rb_define_method(cOBResidueIter.klass, "BeginData", VALUEFUNC(_wrap_OBResidueIter_BeginData), -1);
  rb_define_method(cOBResidueIter.klass, "EndData", VALUEFUNC(_wrap_OBResidueIter_EndData), -1);
  cOBResidueIter.mark = 0;
  cOBResidueIter.destroy = (void (*)(void *)) free_OpenBabel_OBResidueIter;
  cOBResidueIter.trackObjects = 0;
  
  cOBResidueAtomIter.klass = rb_define_class_under(mOpenbabel, "OBResidueAtomIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidueAtomIter, (void *) &cOBResidueAtomIter);
  rb_define_alloc_func(cOBResidueAtomIter.klass, _wrap_OBResidueAtomIter_allocate);
  rb_define_method(cOBResidueAtomIter.klass, "initialize", VALUEFUNC(_wrap_new_OBResidueAtomIter), -1);
  rb_define_method(cOBResidueAtomIter.klass, "good", VALUEFUNC(_wrap_OBResidueAtomIter_good), -1);
  rb_define_method(cOBResidueAtomIter.klass, "inc", VALUEFUNC(_wrap_OBResidueAtomIter_inc), -1);
  rb_define_method(cOBResidueAtomIter.klass, "deref", VALUEFUNC(_wrap_OBResidueAtomIter_deref), -1);
  rb_define_method(cOBResidueAtomIter.klass, "__ref__", VALUEFUNC(_wrap_OBResidueAtomIter___ref__), -1);
  rb_define_method(cOBResidueAtomIter.klass, "Visit=", VALUEFUNC(_wrap_OBResidueAtomIter_Visit_set), -1);
  rb_define_method(cOBResidueAtomIter.klass, "Visit", VALUEFUNC(_wrap_OBResidueAtomIter_Visit_get), -1);
  rb_define_method(cOBResidueAtomIter.klass, "Clear", VALUEFUNC(_wrap_OBResidueAtomIter_Clear), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetIdx", VALUEFUNC(_wrap_OBResidueAtomIter_SetIdx), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetHyb", VALUEFUNC(_wrap_OBResidueAtomIter_SetHyb), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetAtomicNum", VALUEFUNC(_wrap_OBResidueAtomIter_SetAtomicNum), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetIsotope", VALUEFUNC(_wrap_OBResidueAtomIter_SetIsotope), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetImplicitValence", VALUEFUNC(_wrap_OBResidueAtomIter_SetImplicitValence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IncrementImplicitValence", VALUEFUNC(_wrap_OBResidueAtomIter_IncrementImplicitValence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "DecrementImplicitValence", VALUEFUNC(_wrap_OBResidueAtomIter_DecrementImplicitValence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetFormalCharge", VALUEFUNC(_wrap_OBResidueAtomIter_SetFormalCharge), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetSpinMultiplicity", VALUEFUNC(_wrap_OBResidueAtomIter_SetSpinMultiplicity), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetType", VALUEFUNC(_wrap_OBResidueAtomIter_SetType), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetPartialCharge", VALUEFUNC(_wrap_OBResidueAtomIter_SetPartialCharge), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetVector", VALUEFUNC(_wrap_OBResidueAtomIter_SetVector), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetCoordPtr", VALUEFUNC(_wrap_OBResidueAtomIter_SetCoordPtr), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetResidue", VALUEFUNC(_wrap_OBResidueAtomIter_SetResidue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetParent", VALUEFUNC(_wrap_OBResidueAtomIter_SetParent), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetAromatic", VALUEFUNC(_wrap_OBResidueAtomIter_SetAromatic), -1);
  rb_define_method(cOBResidueAtomIter.klass, "UnsetAromatic", VALUEFUNC(_wrap_OBResidueAtomIter_UnsetAromatic), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetClockwiseStereo", VALUEFUNC(_wrap_OBResidueAtomIter_SetClockwiseStereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetAntiClockwiseStereo", VALUEFUNC(_wrap_OBResidueAtomIter_SetAntiClockwiseStereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetPositiveStereo", VALUEFUNC(_wrap_OBResidueAtomIter_SetPositiveStereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetNegativeStereo", VALUEFUNC(_wrap_OBResidueAtomIter_SetNegativeStereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "UnsetStereo", VALUEFUNC(_wrap_OBResidueAtomIter_UnsetStereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetInRing", VALUEFUNC(_wrap_OBResidueAtomIter_SetInRing), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetChiral", VALUEFUNC(_wrap_OBResidueAtomIter_SetChiral), -1);
  rb_define_method(cOBResidueAtomIter.klass, "ClearCoordPtr", VALUEFUNC(_wrap_OBResidueAtomIter_ClearCoordPtr), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetFormalCharge", VALUEFUNC(_wrap_OBResidueAtomIter_GetFormalCharge), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetAtomicNum", VALUEFUNC(_wrap_OBResidueAtomIter_GetAtomicNum), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetIsotope", VALUEFUNC(_wrap_OBResidueAtomIter_GetIsotope), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetSpinMultiplicity", VALUEFUNC(_wrap_OBResidueAtomIter_GetSpinMultiplicity), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetAtomicMass", VALUEFUNC(_wrap_OBResidueAtomIter_GetAtomicMass), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetExactMass", VALUEFUNC(_wrap_OBResidueAtomIter_GetExactMass), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetIdx", VALUEFUNC(_wrap_OBResidueAtomIter_GetIdx), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetCoordinateIdx", VALUEFUNC(_wrap_OBResidueAtomIter_GetCoordinateIdx), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetCIdx", VALUEFUNC(_wrap_OBResidueAtomIter_GetCIdx), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetValence", VALUEFUNC(_wrap_OBResidueAtomIter_GetValence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetHyb", VALUEFUNC(_wrap_OBResidueAtomIter_GetHyb), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetImplicitValence", VALUEFUNC(_wrap_OBResidueAtomIter_GetImplicitValence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetHvyValence", VALUEFUNC(_wrap_OBResidueAtomIter_GetHvyValence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetHeteroValence", VALUEFUNC(_wrap_OBResidueAtomIter_GetHeteroValence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetType", VALUEFUNC(_wrap_OBResidueAtomIter_GetType), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetX", VALUEFUNC(_wrap_OBResidueAtomIter_GetX), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetY", VALUEFUNC(_wrap_OBResidueAtomIter_GetY), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetZ", VALUEFUNC(_wrap_OBResidueAtomIter_GetZ), -1);
  rb_define_method(cOBResidueAtomIter.klass, "x", VALUEFUNC(_wrap_OBResidueAtomIter_x), -1);
  rb_define_method(cOBResidueAtomIter.klass, "y", VALUEFUNC(_wrap_OBResidueAtomIter_y), -1);
  rb_define_method(cOBResidueAtomIter.klass, "z", VALUEFUNC(_wrap_OBResidueAtomIter_z), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetCoordinate", VALUEFUNC(_wrap_OBResidueAtomIter_GetCoordinate), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetVector", VALUEFUNC(_wrap_OBResidueAtomIter_GetVector), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetPartialCharge", VALUEFUNC(_wrap_OBResidueAtomIter_GetPartialCharge), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetResidue", VALUEFUNC(_wrap_OBResidueAtomIter_GetResidue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetParent", VALUEFUNC(_wrap_OBResidueAtomIter_GetParent), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetNewBondVector", VALUEFUNC(_wrap_OBResidueAtomIter_GetNewBondVector), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetBond", VALUEFUNC(_wrap_OBResidueAtomIter_GetBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetNextAtom", VALUEFUNC(_wrap_OBResidueAtomIter_GetNextAtom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "BeginBonds", VALUEFUNC(_wrap_OBResidueAtomIter_BeginBonds), -1);
  rb_define_method(cOBResidueAtomIter.klass, "EndBonds", VALUEFUNC(_wrap_OBResidueAtomIter_EndBonds), -1);
  rb_define_method(cOBResidueAtomIter.klass, "BeginBond", VALUEFUNC(_wrap_OBResidueAtomIter_BeginBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "NextBond", VALUEFUNC(_wrap_OBResidueAtomIter_NextBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "BeginNbrAtom", VALUEFUNC(_wrap_OBResidueAtomIter_BeginNbrAtom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "NextNbrAtom", VALUEFUNC(_wrap_OBResidueAtomIter_NextNbrAtom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetDistance", VALUEFUNC(_wrap_OBResidueAtomIter_GetDistance), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetAngle", VALUEFUNC(_wrap_OBResidueAtomIter_GetAngle), -1);
  rb_define_method(cOBResidueAtomIter.klass, "NewResidue", VALUEFUNC(_wrap_OBResidueAtomIter_NewResidue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "AddResidue", VALUEFUNC(_wrap_OBResidueAtomIter_AddResidue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "DeleteResidue", VALUEFUNC(_wrap_OBResidueAtomIter_DeleteResidue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "AddBond", VALUEFUNC(_wrap_OBResidueAtomIter_AddBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "InsertBond", VALUEFUNC(_wrap_OBResidueAtomIter_InsertBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "DeleteBond", VALUEFUNC(_wrap_OBResidueAtomIter_DeleteBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "ClearBond", VALUEFUNC(_wrap_OBResidueAtomIter_ClearBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HtoMethyl", VALUEFUNC(_wrap_OBResidueAtomIter_HtoMethyl), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetHybAndGeom", VALUEFUNC(_wrap_OBResidueAtomIter_SetHybAndGeom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "ForceNoH", VALUEFUNC(_wrap_OBResidueAtomIter_ForceNoH), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasNoHForced", VALUEFUNC(_wrap_OBResidueAtomIter_HasNoHForced), -1);
  rb_define_method(cOBResidueAtomIter.klass, "CountFreeOxygens", VALUEFUNC(_wrap_OBResidueAtomIter_CountFreeOxygens), -1);
  rb_define_method(cOBResidueAtomIter.klass, "ImplicitHydrogenCount", VALUEFUNC(_wrap_OBResidueAtomIter_ImplicitHydrogenCount), -1);
  rb_define_method(cOBResidueAtomIter.klass, "ExplicitHydrogenCount", VALUEFUNC(_wrap_OBResidueAtomIter_ExplicitHydrogenCount), -1);
  rb_define_method(cOBResidueAtomIter.klass, "MemberOfRingCount", VALUEFUNC(_wrap_OBResidueAtomIter_MemberOfRingCount), -1);
  rb_define_method(cOBResidueAtomIter.klass, "MemberOfRingSize", VALUEFUNC(_wrap_OBResidueAtomIter_MemberOfRingSize), -1);
  rb_define_method(cOBResidueAtomIter.klass, "CountRingBonds", VALUEFUNC(_wrap_OBResidueAtomIter_CountRingBonds), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SmallestBondAngle", VALUEFUNC(_wrap_OBResidueAtomIter_SmallestBondAngle), -1);
  rb_define_method(cOBResidueAtomIter.klass, "AverageBondAngle", VALUEFUNC(_wrap_OBResidueAtomIter_AverageBondAngle), -1);
  rb_define_method(cOBResidueAtomIter.klass, "BOSum", VALUEFUNC(_wrap_OBResidueAtomIter_BOSum), -1);
  rb_define_method(cOBResidueAtomIter.klass, "KBOSum", VALUEFUNC(_wrap_OBResidueAtomIter_KBOSum), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasResidue", VALUEFUNC(_wrap_OBResidueAtomIter_HasResidue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsHydrogen", VALUEFUNC(_wrap_OBResidueAtomIter_IsHydrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsCarbon", VALUEFUNC(_wrap_OBResidueAtomIter_IsCarbon), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsNitrogen", VALUEFUNC(_wrap_OBResidueAtomIter_IsNitrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsOxygen", VALUEFUNC(_wrap_OBResidueAtomIter_IsOxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsSulfur", VALUEFUNC(_wrap_OBResidueAtomIter_IsSulfur), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsPhosphorus", VALUEFUNC(_wrap_OBResidueAtomIter_IsPhosphorus), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsAromatic", VALUEFUNC(_wrap_OBResidueAtomIter_IsAromatic), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsInRing", VALUEFUNC(_wrap_OBResidueAtomIter_IsInRing), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsInRingSize", VALUEFUNC(_wrap_OBResidueAtomIter_IsInRingSize), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsHeteroatom", VALUEFUNC(_wrap_OBResidueAtomIter_IsHeteroatom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsNotCorH", VALUEFUNC(_wrap_OBResidueAtomIter_IsNotCorH), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsConnected", VALUEFUNC(_wrap_OBResidueAtomIter_IsConnected), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsOneThree", VALUEFUNC(_wrap_OBResidueAtomIter_IsOneThree), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsOneFour", VALUEFUNC(_wrap_OBResidueAtomIter_IsOneFour), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsCarboxylOxygen", VALUEFUNC(_wrap_OBResidueAtomIter_IsCarboxylOxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsPhosphateOxygen", VALUEFUNC(_wrap_OBResidueAtomIter_IsPhosphateOxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsSulfateOxygen", VALUEFUNC(_wrap_OBResidueAtomIter_IsSulfateOxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsNitroOxygen", VALUEFUNC(_wrap_OBResidueAtomIter_IsNitroOxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsAmideNitrogen", VALUEFUNC(_wrap_OBResidueAtomIter_IsAmideNitrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsPolarHydrogen", VALUEFUNC(_wrap_OBResidueAtomIter_IsPolarHydrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsNonPolarHydrogen", VALUEFUNC(_wrap_OBResidueAtomIter_IsNonPolarHydrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsAromaticNOxide", VALUEFUNC(_wrap_OBResidueAtomIter_IsAromaticNOxide), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsChiral", VALUEFUNC(_wrap_OBResidueAtomIter_IsChiral), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsAxial", VALUEFUNC(_wrap_OBResidueAtomIter_IsAxial), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsClockwise", VALUEFUNC(_wrap_OBResidueAtomIter_IsClockwise), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsAntiClockwise", VALUEFUNC(_wrap_OBResidueAtomIter_IsAntiClockwise), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsPositiveStereo", VALUEFUNC(_wrap_OBResidueAtomIter_IsPositiveStereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsNegativeStereo", VALUEFUNC(_wrap_OBResidueAtomIter_IsNegativeStereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasChiralitySpecified", VALUEFUNC(_wrap_OBResidueAtomIter_HasChiralitySpecified), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasChiralVolume", VALUEFUNC(_wrap_OBResidueAtomIter_HasChiralVolume), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsHbondAcceptor", VALUEFUNC(_wrap_OBResidueAtomIter_IsHbondAcceptor), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsHbondDonor", VALUEFUNC(_wrap_OBResidueAtomIter_IsHbondDonor), -1);
  rb_define_method(cOBResidueAtomIter.klass, "IsHbondDonorH", VALUEFUNC(_wrap_OBResidueAtomIter_IsHbondDonorH), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasAlphaBetaUnsat", VALUEFUNC(_wrap_OBResidueAtomIter_HasAlphaBetaUnsat), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasBondOfOrder", VALUEFUNC(_wrap_OBResidueAtomIter_HasBondOfOrder), -1);
  rb_define_method(cOBResidueAtomIter.klass, "CountBondsOfOrder", VALUEFUNC(_wrap_OBResidueAtomIter_CountBondsOfOrder), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasNonSingleBond", VALUEFUNC(_wrap_OBResidueAtomIter_HasNonSingleBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasSingleBond", VALUEFUNC(_wrap_OBResidueAtomIter_HasSingleBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasDoubleBond", VALUEFUNC(_wrap_OBResidueAtomIter_HasDoubleBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasAromaticBond", VALUEFUNC(_wrap_OBResidueAtomIter_HasAromaticBond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "MatchesSMARTS", VALUEFUNC(_wrap_OBResidueAtomIter_MatchesSMARTS), -1);
  rb_define_method(cOBResidueAtomIter.klass, "DoTransformations", VALUEFUNC(_wrap_OBResidueAtomIter_DoTransformations), -1);
  rb_define_method(cOBResidueAtomIter.klass, "ClassDescription", VALUEFUNC(_wrap_OBResidueAtomIter_ClassDescription), -1);
  rb_define_method(cOBResidueAtomIter.klass, "HasData", VALUEFUNC(_wrap_OBResidueAtomIter_HasData), -1);
  rb_define_method(cOBResidueAtomIter.klass, "DeleteData", VALUEFUNC(_wrap_OBResidueAtomIter_DeleteData), -1);
  rb_define_method(cOBResidueAtomIter.klass, "SetData", VALUEFUNC(_wrap_OBResidueAtomIter_SetData), -1);
  rb_define_method(cOBResidueAtomIter.klass, "DataSize", VALUEFUNC(_wrap_OBResidueAtomIter_DataSize), -1);
  rb_define_method(cOBResidueAtomIter.klass, "GetData", VALUEFUNC(_wrap_OBResidueAtomIter_GetData), -1);
  rb_define_method(cOBResidueAtomIter.klass, "BeginData", VALUEFUNC(_wrap_OBResidueAtomIter_BeginData), -1);
  rb_define_method(cOBResidueAtomIter.klass, "EndData", VALUEFUNC(_wrap_OBResidueAtomIter_EndData), -1);
  cOBResidueAtomIter.mark = 0;
  cOBResidueAtomIter.destroy = (void (*)(void *)) free_OpenBabel_OBResidueAtomIter;
  cOBResidueAtomIter.trackObjects = 0;
  
  cOBMolAngleIter.klass = rb_define_class_under(mOpenbabel, "OBMolAngleIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAngleIter, (void *) &cOBMolAngleIter);
  rb_define_alloc_func(cOBMolAngleIter.klass, _wrap_OBMolAngleIter_allocate);
  rb_define_method(cOBMolAngleIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAngleIter), -1);
  rb_define_method(cOBMolAngleIter.klass, "good", VALUEFUNC(_wrap_OBMolAngleIter_good), -1);
  rb_define_method(cOBMolAngleIter.klass, "inc", VALUEFUNC(_wrap_OBMolAngleIter_inc), -1);
  rb_define_method(cOBMolAngleIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAngleIter___ref__), -1);
  cOBMolAngleIter.mark = 0;
  cOBMolAngleIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAngleIter;
  cOBMolAngleIter.trackObjects = 0;
  
  cOBMolTorsionIter.klass = rb_define_class_under(mOpenbabel, "OBMolTorsionIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolTorsionIter, (void *) &cOBMolTorsionIter);
  rb_define_alloc_func(cOBMolTorsionIter.klass, _wrap_OBMolTorsionIter_allocate);
  rb_define_method(cOBMolTorsionIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolTorsionIter), -1);
  rb_define_method(cOBMolTorsionIter.klass, "good", VALUEFUNC(_wrap_OBMolTorsionIter_good), -1);
  rb_define_method(cOBMolTorsionIter.klass, "inc", VALUEFUNC(_wrap_OBMolTorsionIter_inc), -1);
  rb_define_method(cOBMolTorsionIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolTorsionIter___ref__), -1);
  cOBMolTorsionIter.mark = 0;
  cOBMolTorsionIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolTorsionIter;
  cOBMolTorsionIter.trackObjects = 0;
  
  cOBMolPairIter.klass = rb_define_class_under(mOpenbabel, "OBMolPairIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolPairIter, (void *) &cOBMolPairIter);
  rb_define_alloc_func(cOBMolPairIter.klass, _wrap_OBMolPairIter_allocate);
  rb_define_method(cOBMolPairIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolPairIter), -1);
  rb_define_method(cOBMolPairIter.klass, "good", VALUEFUNC(_wrap_OBMolPairIter_good), -1);
  rb_define_method(cOBMolPairIter.klass, "inc", VALUEFUNC(_wrap_OBMolPairIter_inc), -1);
  rb_define_method(cOBMolPairIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolPairIter___ref__), -1);
  cOBMolPairIter.mark = 0;
  cOBMolPairIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolPairIter;
  cOBMolPairIter.trackObjects = 0;
  
  cOBMolRingIter.klass = rb_define_class_under(mOpenbabel, "OBMolRingIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolRingIter, (void *) &cOBMolRingIter);
  rb_define_alloc_func(cOBMolRingIter.klass, _wrap_OBMolRingIter_allocate);
  rb_define_method(cOBMolRingIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolRingIter), -1);
  rb_define_method(cOBMolRingIter.klass, "good", VALUEFUNC(_wrap_OBMolRingIter_good), -1);
  rb_define_method(cOBMolRingIter.klass, "inc", VALUEFUNC(_wrap_OBMolRingIter_inc), -1);
  rb_define_method(cOBMolRingIter.klass, "deref", VALUEFUNC(_wrap_OBMolRingIter_deref), -1);
  rb_define_method(cOBMolRingIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolRingIter___ref__), -1);
  rb_define_method(cOBMolRingIter.klass, "_path=", VALUEFUNC(_wrap_OBMolRingIter__path_set), -1);
  rb_define_method(cOBMolRingIter.klass, "_path", VALUEFUNC(_wrap_OBMolRingIter__path_get), -1);
  rb_define_method(cOBMolRingIter.klass, "_pathset=", VALUEFUNC(_wrap_OBMolRingIter__pathset_set), -1);
  rb_define_method(cOBMolRingIter.klass, "_pathset", VALUEFUNC(_wrap_OBMolRingIter__pathset_get), -1);
  rb_define_method(cOBMolRingIter.klass, "Size", VALUEFUNC(_wrap_OBMolRingIter_Size), -1);
  rb_define_method(cOBMolRingIter.klass, "PathSize", VALUEFUNC(_wrap_OBMolRingIter_PathSize), -1);
  rb_define_method(cOBMolRingIter.klass, "IsAromatic", VALUEFUNC(_wrap_OBMolRingIter_IsAromatic), -1);
  rb_define_method(cOBMolRingIter.klass, "IsMember", VALUEFUNC(_wrap_OBMolRingIter_IsMember), -1);
  rb_define_method(cOBMolRingIter.klass, "IsInRing", VALUEFUNC(_wrap_OBMolRingIter_IsInRing), -1);
  rb_define_method(cOBMolRingIter.klass, "SetParent", VALUEFUNC(_wrap_OBMolRingIter_SetParent), -1);
  rb_define_method(cOBMolRingIter.klass, "GetParent", VALUEFUNC(_wrap_OBMolRingIter_GetParent), -1);
  rb_define_method(cOBMolRingIter.klass, "findCenterAndNormal", VALUEFUNC(_wrap_OBMolRingIter_findCenterAndNormal), -1);
  cOBMolRingIter.mark = 0;
  cOBMolRingIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolRingIter;
  cOBMolRingIter.trackObjects = 0;
}

